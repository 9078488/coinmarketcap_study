**Ouroboros: 一个可证明安全的POS区块链协议**

Aggelos Kiayias*  Alexander Russell†  Bernardo David‡  Roman Oliynykov§

2017年8月21日

**摘要**

我们提出“Ouroboros”，第一个基于POS的带有严格的安全保证的区块链协议。相比通过bitcoin区块链协议完成的，我们为协议建立了安全的性能。因为协议提供了POS区块链纪律。相比基于物理资源证明的区块链（e.g, POW）,它提供了质的效率优势。我们也提出了一个新奇的用于激励POS协议的奖励机制，并且我们证明，考虑到这个机制，诚实的行为是一个近似的纳什均衡，使得像利己主义的挖矿无效。我们也通过提供在交易确认和处理的实验结果，来提出我们协议在真实世界设置下的初始的证据。

**1. 介绍**

关于基于POW的区块链协议-比如Bitcoin-操作的主要的考虑是执行所需要的能量。在写作的时间里，在bitcoin区块链上生成单个区块需要超过260此的哈希操作，会导致侵袭能源需求。实际上，早期的流通现实协议的能量需求比得上一个小国家。

事情的状态激发人们研究可以通过用其他能源效率更高的另外一个方式替代他，来避免需要POW替代的区块链协议,机制也能提供相似的保证。很重要的是要之处bitcoin的POW机制促进了一种类型的随机“领导人选择”过程，选择其中一个矿工去发行下一个区块。而且，如果所有的矿工都遵循这个协议，这个选择是以和每个矿工算例称比例的随机方式执行的。（来自这个协议的误差可能成比例的扭曲，由“自私的挖矿”策略例证）

一个自然的替代机制依赖于PoS的概念。不是矿工投资矿工为了参与领导选择过程，而是他们运行一个过程，随机的选择他们中的一个，和股份成比例的，每个过程根据当前区块链账簿。

实际上，这产生了自指的区块链纪律：维护区块链依赖于利益相关者自己，基于账簿中所报告的每个过程的质量的数量来给他们安排工作（和奖励）。除了这个之外，这个纪律部需要对利益相关者进行进一步的“人造的”计算需求。在某种意义上，这个听上去很理想；但是意思到这样的PoS协议显得涉及到许多定义上的，技术的和分析的挑战。

**先前的工作** PoS概念在bitcoin论坛曾被广泛的讨论。基于PoS的区块链涉及层被Bentov et al更加正式的研究国，既在和PoW连接方面，也在作为区块链协议单独的机制。尽管Bentovet al.展示了针对一些种类的攻击他们的协议是有效的，他们没提供一个正式的依赖精确的定义的模型，用于分析基于PoS的协议或安全证明。对于许多加密货币，探索性的基于PoS的协议被提出（和实施）。基于探索性的安全论证，这些加密货币并频繁的发现从安全的观点上是有缺陷的。参照【4】作为一个各种攻击的讨论。

对于一个基于PoS的区块链协议与一个依赖固定权威这集合的经典的共识区块链也是很有意思的。区分基于PoS的区块链协议与那些假设静态的当局这的是抵押随着时间变化，因此信任假设随着系统进化。

另外一个PoW的替代是空间证明的概念，在区块链协议的背景下被特别的研究。在一个空间证明设置里，一个“证人”希望证明对空间的使用（存储/内存）；正如在PoW的情况，这个使用了物理资源，但是随着时间需要的能量少一些。一个相关的概念是空间-时间证明（PoST）。在所有的这些情况，但是一个昂贵的物理资源（存储或算力）是必要的

**PoS设计挑战** 对于基于PoS的区块链协议的基础的问题是去模拟领导选择过程。为了在利益相关者中达到一个公平的随机的选择，熵必须引入到系统力，引入熵的机制可能易于被对手操纵。例如，一个控制足足利益相关者的对手可能尝试模拟协议执行，尝试利益相关者参与者的不同的序列。这样找到一个有利于对手的利益相关者的协议附加部分。这会导致所谓的“无休止的”弱点，对手方可能用计算资源去倾斜领导者选择。

**我们的结果** 我们提出“Ouroboros”，一个可证明的安全的PoS系统。据我们所知，这是第一个有严格的安全分析的这种类型的区块链协议。更详细的，我们的结果如下。

第一，我们提供了一个模型，是的认识到基于PoS区块链协议的这个问题正式化。我们介绍的这个模型是本着 一个健壮的交易账簿的两个正式的性能，集中于持续和活跃性的精神。持续表述一旦系统的一个声明一个特定的交易为“稳定的”，剩下的节点，如果诚实的询问和回应，也会将起报告为“稳定的”。此时，稳定性被理解为一个谓语，由一些安全参数k表示，将影响确定性，那个性质保持。（例如，超过k阻止深处）。活跃性确保，一旦真诚的生成的交易可以实现为一个充足的时间足够的数量到网络节点，比如u时间步数，将会是稳定的。活跃性和持续性的结合提供了一个健壮的账簿，从某种意义上说，生成的交易被采用，并且变得不可变的。我们的模型适宜的被修改去促进基于PoS的动力学。

第二，我们描述了一个基于PoS的新奇的区块链协议。我们的协议假定当事人可以自由的创建账户和接受和支付，那个质押随着时间转换。我们使用一个（非常简单的）安全的掷硬币协议的的多党实施去生成领导选择过程的随机性。区分我们的方式（和阻止所谓的“无休止攻击”）和其他之前的解决方式是价值确定的基于区块链的当前状态或使用共同的掷硬币作为引入熵的方式。并且，对我们的方式是独特的是系统忽略循环到循环的质押修改。反而，会定时利益相关者的当前集合进行定期快照，间隔被称作"epochs";在每个这样的间隔里，会进行一个而安全的多党的计算，使用区块链本身作为广播渠道。特别地，在每个时间点上，一组从委员会随机选择出来的利益相关者，然后负责执行掷硬币协议。协议的结果决定在一个时间点执行协议的下一组利益相关者，和所有领导选择的结果一样，用于时间点。

第三，我们提供一组正式的自变数，确立没有对手方可以打破持续和活跃性。在一些看似可信的假设下，我们的协议是安全的:(1)网络是同步的，从某种意义上来说，一个上限可以被决定，在任何诚实的利益相关者可以和任何其他利益相关者沟通，(2)一些从诚实的多数中提取的一些利益相关者是可能的，当需要参与每个间隔时,(3)利益相关者不会长时段的保持离线，（4）腐败自适应从属于一个小的延迟，在轮线性衡量，在安全的参数（或替代的，选手可以访问一个发送者匿名的广播渠道）。在我们安全参数的核心是该类型的参数，根据一个组合的概念“可分叉的线”，我们规划，证明，并且也用实验方法验证。在我们的分析里，我们也区分转换共i，一种一般分叉攻击的特别种类。这里的“转换性”本着转换跌收，针对安全多党的计算协议的精神，敌方像打破这个协议，但是更喜欢不被抓到做这个。我们展示秘密地分叉串是带有更小密度的分叉串的子类；这允许我们提供两个由区别的安全参数，完成不同的折中，依照效率和安全保障。我们分叉的串分析是一个自然的，相当的普遍的工具，可以被作为PoS设置的安全参数的一部分应用。

第四，我们把我们的注意力转移到协议的激励结构。我们展示一个新的奖励机制，用于激励这个系统的参与这，我们证明起（近似于）纳什均衡。在这个方式，攻击像区块阻挡和自私挖矿会被我们的设计减轻。奖励机制背后的核心理念是去提供积极的报酬给协议行动，不能被从协议中分叉的参与方的联合扼杀。在这个方式下，可能展示这个，在貌似可信的假设下，也记忆是一定的协议执行诚实是小的，忠诚的遵循协议是一个均衡，当所有的选手是理性的。

第五，我们引入了质押委托机制，可以无缝的加入到我们区块链协议。委托是非常有用的，在我们的内容中，当我们允许协议去扩展，甚至在一种设置里，一组利益相关者是高度分裂的。在这样的情况下，委托机制使得利益相关者去委托他们的“投票权”，例如，在每个时间点参与运行领导选择协议委员会的权利。在流动性民主，（亦称，委托的民主），利益相关者由能力撤回委托任命，当他们想相互独立。

考虑到我们模型和协议描述，我们也探索可在实际中多种多样的攻击，在我们的框架内被解决。特别的，我们讨论了双花攻击，交易拒绝攻击，51%攻击，没有质押，去同步化攻击和其他。最后，我们展示了冠以我们涉及的效率的证据。第一我们考虑双花攻击。为了说明目的，我们和中本聪关于bitcoin的分析进行了一个对比，关于带有确认99.9%的交易确认时间。反对转换敌手，交易确认时间比bitcoin快10到16倍，依赖于敌对的哈希算例；对于一般的敌手确认时间，有5到10倍快。而且，我们对于双花攻击的具体分析依赖于我们的分叉和密密地分叉串的组合，并且应用到一个更加广阔敌对行为的种类，相比中本聪的更加简化的分析。我们然后调查了我们的原型实施和在Amazon云计算上进行的基准测试的报告，可以展示我们的PoS区块链协议的力量 ，依照性能。

**相关工作** 与开发我们的Ouroboros同步，一些其他协议也真被开发，用来针对多种位置，在基于PoS的分布式账簿的设计空间里。睡眠的共识认为一个固定的利益相关者分布（例如，质押不会随着时间进化），目标为一个“混合的”腐败设置，敌手被允许去适应和执行失败终止，除了拜占庭错误恢复腐败。这个实际上简单的扩展到偶们在混合的腐败设置里的分析，cf.备注2；然而，结果的安全可以被争论，仅仅在“带延迟的腐败”的设置，因此不是完全的可适应的。雪白提出了一个进化的利益相关者分布，并且采用了我们争论安全类似的腐败延迟机制。然而，与我们协议相反，雪白设计已受“无休止的”类型的攻击影响，可以偏向对敌对方有利的高可能性事件。当这个不是渐近地上海安全，它阻止了一个具体的参数化，不会考虑敌对的算例。Algorand提供了一个遵循拜占庭协议的分布式账簿，每个区块的方式，抵挡住适应的腐败。考虑到协议需要到达每个区块，这样的协议会以一个实质上比PoS区块链慢的速率生产区块。（慢下来和拜占庭同意协议的执行的期望长度），但是他们可以自由的分叉。在这方面，尽快存在分叉，区块链协议展示了允许客户去设置他们愿意承受的风险等级的灵活性，允许低风险侧面客户享受更快的处理事件，从乐观的角度。最后，Fruitchain提供了一个奖励机制和一个近似的纳什均衡证明，对于基于PoW的区块链。我们在区块链层面用了一个类似的奖励机制，虽然我们基础的结构是不同的，因为需要在PoS设置下操作。这个思想的核心是提供一个“背书”输入的POS类似，在一个公平的比例，适用相同的逻辑正如基于PoW的拜占庭同意协议，用于诚实的大多数所来的。

**白皮书综述** 我们在Sec. 2展示基本的模型。为了简化我们协议的分以，我们在我们的四个阶段展示它，被在Sec. 3中概述。总之，在Sec. 4,我们描述和分析了协议，在静态设置；我们然后再Sec. 5中过渡到动态设置。我们的激励机制和均衡参数再Sec. 7中展示。我们然后在Sec. 6中展示带有匿名渠道的协议增加，在Sec. 8中带有一个委托机制。随后，在Sec. 9中，我们讨论了在各种各样特别的利益攻击下的，在协议的恢复力。在Sec. 10,我们讨论国盾确认次数，和一般的执行结果，从在Amazon云上运行的原型实施的结果。

**2. 模型**

**时间，位置和同步** 我们考虑一个设置，时间被划分为被称作位置的不连续的单元。一个账簿，如下进行更详细的描述，一个账簿区块和每个时间位置有管（至多）。选手被装备（大概同步的）时钟，展示当前的位置。这讲允许他们实施一个分布式协议，目的是共同的布置一个区块到当前位置。总之，每个位置slr由整数r 2 {1, 2, . . .}做索引，我们假设对应每个位置的实时窗口有如下性质。

- 当前位置是有公开已知的，单调的当前时间增加函数决定的
- 每个选手可以访问当前时间。当事人本地时间之间的相差，相比由slot代表的时间长度是无关紧要的。
- 对应一个位置的时间窗口长度是足够去保证人后在时间窗口开始的时候由诚实参与者传送的信息将会在时间窗口结束时，由任何其他诚实的参与方收到（甚至对在参与方的当地时钟中的小的不一致负责）。特别，当网络延迟发生，他们从来不会超过位置的时间窗口。

**交易账簿性质** 一个协议实施了一个健壮的交易账簿，如果2维持的账簿被划分为“区块”（分配给时间位置），决定交易被包含到账簿里的顺序。它应该满足如下两个性质。

**持续** 一旦系统的一个节点宣告一个特定的交易tx作为稳定的，剩下的节点，如果查询，会在账簿的相同位置报告tx,或不会把任何和tx冲突的交易报告未稳定的，这里稳定性的概念是一个谓语，用安全参数k作为参数来表示；特别地，一个交易被声明未稳定，如果并且仅仅，如果在一个区块里，在账簿里超过k区块深。

**活跃性** 如果在系统中的所有的诚实的节点尝试去包含一个特定的交易，那么在对应u位置的时间过去后（被称为交易确认时间），所有的节点，如果诚实地查询和回复，将会将交易报告为稳定的

在[26， 35]，它被展示：持续和活跃性可以来源于如下三个基本的性质，如果协议2来源于账簿，从一个区块链形式的数据结构。

- **一般的前缀（CP）;带参数** k 2 N.链由两个诚实的参与人控制，在位置sl1 < sl2的开始，是Cdk
  1  C2,Cdk表示这个链，通过从C1移除最后的k区块获得，并且表示前缀关系。

- **链质量（CQ）;带参数** μ 2 (0, 1] 和 ` 2 N。考虑长度的任何部分，至少链的 ，由诚实的参与方控制，在循环的开始；由敌对方引起的区块比例至多是1−μ.我们称μ为链质量系数。
- **链增长（CG）;带参数**  2 (0, 1], s 2 N.考虑链C1, C2，由两个诚实的参与方控制，在两个位置sl1, sl2的开始，带有sl2,至少在sl1前面。然后它持有len(C2) − len(C1)   · s. 我们称为速度系数

一些注意在这些地方。关于一般前缀，我们多的一个一般前缀的强概念。cf. [26].关于链质量，μ,作为敌对方的比例的函数，满足μ()  ，对于利益协议。在一个理想的设置里，μ会是1−；在这个情况下，恶意区块的比例，在任何足够长的的链部分，和一组（恶意的）利益相关者的累积的质押是成比例的。

值得注意对于bitcoin,我们由μ() = (1 − 2)/(1 − ),这个限制事实上是紧的，参照[24]，争论链质量的保证。同样的会保持正确，对于协议建设。正如我们展示，这将足够，对于我们用于合适地工作的激励机制。

最后，链增长涉及到链增长的速度（对于诚实的节点）。在bitcoin的情况下，最长的链在我们协议里扮演优先的作用；这提供链增长的一个简单的保证。

**安全模型** 我们采用由[24]引入的模型，用于分析区块链协议的安全性，由理想的功能f增强。我们通过VIEWP,F
,A,Z()表示P参与方的观点，在协议2执行后，带有敌对方A，环境Z，安全参数和访问理想的功能f。类似的，我们用EXECP,F
,A,Z()表示Z的输出。

我们注意到多个不同的“功能会被f完成。与[24]相反，我们的分析是在“标准模型里”，不带由一个而随机的预言机功能，我们在理想的功能里包含的第一个界面，在协议里适用的是“传播”和“关键的和交易”功能，以FD+KT命名，会在下面描述。注意传播的功能也是机制，通过我们将获得协议的同步性。

**传播功能** 传播功能包制一个进来的字符串，对于参与的每个参与方Ui。一个参与方，如果激活，是被在任何时刻允许去取得他们进入的字符串；可能会把这个想象称一个信箱。此外，参与方会知道功能去传播一个小小，在一种情况，信息会被添加到每个参与方的进入的字符串。这个功能保持循环（地点），并且所有参与方在一个循环里传播一次。循环不前进，除非所有参与方已经传播了一个消息。敌对方，当激活后，可能也和这个功能互动，它被允许去阅读所有收件箱，和所有的传播要求，并且以它喜欢的任何顺序投递信息到收件箱里。在循环结束后，这个功能会确保包含素偶又信息的收件箱被出阿伯（但是不是必要，以相同的顺序，他们被要求被传播的）。当前的地点参数可能在任何时间由任何参与方要求。如果一个利益相关方没有取得一个特定的地点，这个信息写入到他的进入的字符串，他们会被暴露。

**关键的和交易功能** 关键登记功能是带有n个用户，U1, . . . ,Un进行初始化，和他们各自的质押s1,...,sn;考虑到这样的初始化，函数会和敌方商议，会接受一个（可能空的）（腐败的，U）信息的序列，并且标记对应的用户U作为腐败。对于在函数里登记的不带有公钥的腐败的用户，将允许敌方去设置他呢的公钥，当对于诚实的用户，这个函数会抽样取样公/私钥对，并且基于数字前面算法记录他们。腐败用户的公钥会被标记称这样。随后，如下行动的任何序列可能会发生：（i）一个用户可能要求减少它的公钥和私钥，因此这个函数会将其返回给用户。(ii)公钥的全部的目录会被要求，因此这个函数会将其返回给请求的用户。(iii)一个新用户可能被要求被创立，通过一个来自环境的消息（Create,U,C）,函数将遵循如之前的相同的步骤：它将会和敌对方商量，关于U的腐败状态，并且会设置其公开，可能私钥依赖于腐败状态；此外，它将会储存C，作为建议的初始状态。函数会根据交互作用的成功完成返回公钥到环境里。(iv)一个现行的用户可能被要求去被腐败，通过敌对方，通过一个消息（Corrupt,U）。一个用户能仅被腐化，在D位置的延迟后；特别的，一个腐败请求是登记的私钥，会被释放，在D位置已经通过，根据循环计数器，在函数出阿伯的部件重维持。

考虑到上述，我们会假设协议的执行是关于函数F，吸收了上述两个函数，和可能的额外的函数，在如下被解释的。注意一个腐败的利益相关者U会让渡它所有的状态到A；从现在开始，敌方会被激活，代替利益相关者U。超出F利用的任何限制，敌方仅仅能腐败一个利益相关者，如果是通过环境Z运行协议执行的给定的许可。许可时以消息的形式（Corrupt, U）,会通过环境被提供给敌方。总之，关于激活，我们有如下。

- 在美俄个位置Slj，环境Z被运去去精活利益相关者期望的任何子集。他们中的 每个人可能生成信息，可以被传送给其他利益相关者
- 敌方至少被激活，作为最后实体，在每个slj，（和在所有敌对方激活一样）

很容易看到以上模型在敌方上授予这样的规模打大的权利，一个能不能在利益协议上建立任何重大的保证。隐私去限制环境的适宜的（考虑协议的详情），因此我们个能争论安全性。没有元年，我们在环境上世家的限制如下：

**施加到环境的限制** 环境，负责在每一个循环激活诚实的节点，将从属于如下约束，关于运行协议的诚实节点的激活

- 在每个位置，会至少有一个诚实的激活的参与方
- 将有一个参数k 2 Z，将会表示位置的最大数，一个诚实的利益相关者会离线。假使一个诚实的利益相关者被生成，在协议的开始，通过由环境提供的它的初始化的链C，应该匹配一个诚实的参与方的链，在之前的位置是活跃的。
- 在每一个位置Slr.对于每个活跃的利益相关者Uj，会是一组公钥和形式(vki, si) 2 {0, 1} × N, for j = 1, . . . , nr的质押对，nr是这个引入的用户数，到那个位置，会代表谁是活跃的参与这，按照Uj的观点。公钥会被标记为“腐败的”，如果对于的利益相关者被腐败的。我们会说敌方会被限制小于50%的相关质押，如果它包制由总计的质押划分的腐败钥匙的总的质押小于在所有的可能的Sj(r)的50%。假使上述被事件Bad1/2违背的，对于给定的执行成为正确的。

我们注意到上述陈述的离线的限制是非常保守的，我们的协议可以容忍更长的离线事件，取决于窒息感步骤的过程的方式；然而，对于简易质押，我们使用上述限制。最终，我们注意到在我们的证明里，无论何时，我们说一个性质Q保持在所有执行上高的可能性。这捕获了这个事实，我们排除环境和敌方，触发带有不可忽视的可能性的Bad1/2。

**3. 我们的协议： 综述**

我们首先提供一个我们协议设计方式的大概的综述。这个协议的特性取决于一些如下参数：(i) k是区块数，应该由在其之上，为了成为账簿的不可变的历史的一部分，(ii)是优势，依照诚实的利益相关者的质押，针对敌对方(iii)D是腐败延迟，在敌对方上施加，例如，一个诚实的利益相关者将会被腐败，在D位置后，当一个腐败信心在执行期间由敌方传递；(iv)L是系统的寿命，在位置里衡量；（v）R是事件点的长度，在位置中衡量。

我们展示我们的协议描述，在相继的四阶段，提供它所能抵挡的敌方的模型。在所有的阶段里，一个“理想的功能”，对于参与者是可行的。函数捕获了资源，在所有参与方中作为前提存在，用对协议的安全的操作（例如，创世块会由指定）

**阶段 1：静态质押** D= L。在第一阶段，信任假设是静态的，并带有利用相关者初始集保持。由一个初始的质押分布， 会被硬编码进创世块，包含利益相关者{(vki, si)}ni
=1.的公钥。基于我们对环境的限制，带有优点的诚实的大多数假定在这些初始的利益相关者中。特别的，环境初始地会允许一些利益相关者的腐败，它的相关质押表示1−用于一些 > 0.环境允许通过提供形式（Corrupt, U)的tokens到敌对方去允许参与方腐败；注意由于在第一阶段事实的腐败延迟，任何进一步的腐败会反对参与方，最初没有质押，因此腐败模型和“静态腐败类似的”。FD,F将随后取样p,会播种一个“由质押重量”的利益相关者取样，在这个放肆导致m keys vki1 , . . . , vkim的子集的选择，到形成一个委员会，会控制待在m带有压倒性可能性的诚实的大多数，（这用了事实，由恶意参与方控制的相关质押是1−
2），m到的现行依赖会被施加在这个阶段）。更详细的，委员会将会被含蓄的选择，通过指定利益相关者，带有可能性，和它的质押成比例，对L位置的每个人。随后，利益相关者讲法发行区块，遵循这个计划表，由slot作业决定。最长链规则会被应用，对于敌对方是可能去分叉区块链视角，诚实方。然而，我们将证明，带有一个Markov链论证，可能性，一个分叉可能被维持，在一个n位置的序列，以指数方式降低，至少p
n, cf.定理4.12针对一般敌对者。一个更加喜欢的反省可以针对转变敌对方所做的。例子，更喜欢保持“在雷达下的”定理4.23.

**阶段2： 动态的状态，带有一个灯塔，R位置的时间点期间，**D = R  L. 以上协议的寿命的扩展的中心思想是去考虑他的若干调用的相继的构成，我们详述一个做这个方法，在这样的假设下，一个可信任的灯塔定期发出一个一致的随机字符串。更具体的说，这个灯塔，在位置{j ·R+1, . . . , (j+1)R},现实j-th随机字符喜欢，播种领导选择函数。和静态状态协议相比的决定性的不同是质押分布被允许去该白，是从区块链自身得到的。这意味着一个特定的位置sl,属于j-th时间点（带j  2），被使用的质押分布是在最近区块链里报告的，带有小于j · R − 2k.的时间戳。

关于进化的质押分布，交易会被持续的生成和传送，通过环境在利益相关者之间，选手会包含被同胞的交易在基于他们维护的账簿的区块链。为了适应被创建的新的账户，函数使得一个新的(vk, sk)即期被创建，并安排给一个新的参与方Ui.特别的，环境会创建一个新的参与方，会和相互作用，为了他们的公/私钥，在一个方式，将其作为一个可信任的部件去对待，维护他们钱包的秘密。注意，敌对方可以妨碍一个新的参与方的创建，腐败他，提供他自己的（敌对创建的）公钥替代。如以前，环境，可能要求在来自利益相关者的，账户之间的交易，他能生成交易，和敌方勾结。为了腐败的账户。回忆：我们的假设是，在任何位置，按照诚实的选手的观点，利益相关者分布满足诚实的大多数，带有优点（注意不同的诚实的选手可能理解一个不同的利益相关者分布，在一个特定的位置）。而且，质押能够转换，通过至多统计距离，通过特定数量的位置。这里被衡量的统计距离考虑基础的分布，作为更具质押获得权重的采样器，以及他瑞华随着规定的时间间隔改变。安全证明可以被看做一个感应现象，在时间点L/R的数量，带有基础情况，由静态的质押协议的证明提供。最后，我们会讨论在这个设置里，一个限制，在敌对的之压力，对安全是最后的，一个单个的抽签（观察委员会的尺寸，m,现在应该被选择去克服，也一个累计的属于，尺寸ln(L/R)，考虑到系统的寿命，包含这样一个连续点的时间）。腐败延迟保持在D = R，可以被选择任意小于L的，因此使得敌对方去执行适应的腐败，只要这不是即时的。

**阶段3 动态的状态，不带有灯塔，R位置的时间点阶段R = (k)和延迟D 2 (R, 2R)  L.**在第三个阶段，我们移除了对于灯塔的从属，通过引入一个安全的多方协议，带有一个“保证的输出传递”，模拟他。在这个方式，我们可以获得长活跃性，如阶段2描述的设计，不仅仅在阶段1设计的假设下，例如，这仅有的一个初始化随机字符串的可能性，和一个带有诚实大多数的初始化利益相关者分布。核心思想如下：考虑到我们保证，在选择的利益相关者中诚实的大多数将保持非常高的可能性，我们能进一步的使用选择的设置作为参与者，到一个安全的多方的计算协议的实例。这将要求时间点的长度的选择会是充足的，所以可以容纳MPC协议的运行。从安全的角度来看，和前面的情况主要的不同是，灯塔的输出会被敌对方知道，在被诚实参与方知道之前。然后，我们会证明诚实参与方也会不可避免的知道它，在较少的位置后。为了对这个事实进行解释，敌方抢先了（可能由执行适合的腐败开发），我们增加等待时间，用于腐败，从R到一个合适的值在(R, 2R)，否定这个优点，依赖安全的MPC设计。从加密设计角度看，这个节点的特点是，账簿本身的使用，对于一个可靠的传播的模拟 ，支持MPC协议。

**阶段4 输入背书人，利益相关者委托，匿名通信** 在我们设计的第一个阶段，我们增加了这个协议，带有两个新的任务，为实体，运行协议和考虑匿名通信的好处。输入背书人创建了一个交易的第二层，先于区块包含背书。这个机制使得这个协议可以抵挡误差，比如利己的挖矿，和使得我可以去展示诚实的行为是一个近似的纳什均衡，在合理的假设下，关于运行协议的成本。注意输入背书者被分配给位置，以相同的方法，一些位置领导是，并且被包含在区块里的输入仅仅可接受，如果他们由一个合格的输入背书者背书。第二，授权特点允许利益相关者去转移委员会参与给被选择的委托，假定在运行协议里的利益相关者的责任（包括参与到MPC和区块的发布）。委托自然的引起“质押池”，能够以相同的方式行动，正如bitcoin中的矿池。最后，我们我们观察到，通过包含一个匿名通信的层，我们可以移除腐败延迟要求，在我们分析中被利用的。这个以对于诚实参与方增加在线时间要求为代价。

**4 我们的协议：静态状态**

**4.1 基本的概念和协议描述**

我们通过在“静态质押”设置里描述区块链协议开始，领导会被分给给区块链位置，带有可能性，和他们（固定的）初始的质押成比例，是有效的质押分布，通过执行。为了简化我们的描述，我们抽象化领导选择处理，将其简单的对待为一个“理想的功能”，如实的执行随机分配利益相关者给位置的过程。在如下的章节，我们解释如何距离说明这个功能，带有特定的安全计算。

我们注意到，甚至带有一个而理想的领导分配过程--分析标准“最长链”优先权规则，在我们的PoS的设定中，变得需要重要的新注意。产生这个挑战是因为许多位置（时间点，如上所述）被立刻分配给利益相关者；当这个有有利的性质，从一个效率（和激励）角度，它给敌对方提供了一个新奇的攻击方式。特别地，一个控制特定利益相关者人口的敌对方能够，在一个时间点的开始，选择，当标准“链更新”广播消息被传递给诚实的节点，带有未来位置分配的全部知识，到利益相关者。与之相反，在典型的POW中设置中敌对方被限制去做这样的决定，在一个在线的方式。我们注意到这个有一个引人注目的效果，在敌对方生成敌对链的能力上；参在如下“分叉字符串的”讨论，用于详细的讨论。

在静态质押的情况，我们假定固定的n利益相关者u1...un的集合通过协议相互作用。利益相关者Ui用用si质押，在协议开始之前。对于每个利益相关者Ui,一个认证和签署钥对（vki, ski）对于一个规定的签名组合被生成；我们假设不损失普遍性的情况下，验证钥vk1..被所以的利益相关者知道。在描述这个协议，我们建议里基本的定义，遵循如下的概念。

**定义 4.1** (创世区块)。创世区块B0包含有他们公钥识别的利益相关者的李彪，他们分别质押（vk1,s1）....(Vkn,sn)和辅助的信息p

具有仙剑，我们注意的辅助信息P将被用作播种位置领导选择过程。

**定义 4.2**(状态)。 一个状态是一个字符串2 {0, 1}.

**定义4.3** (区块)。 一个区块在位置生成，包含当前状态，数据，位置数sli和一个前面，在SKI下计算的，对应利益相关者Ui生成区块。

**定义 4.4** （区块链）区块链（或简单地链）涉及创世块B0是一个区块B1，...Bn的序列 ，与一个严格的块的增长序列有关系，对于他和Bi的状态等于H(Bi-1),H是一个规定的康冲突的哈希函数。一个链的len(C)=n的长度是它的区块数。区块Bn是链的头，表示为head(C)。我们将空字符串看做一个合法的链，通过约定设置head=

让C成为一个长度为N的链，k是任何非负整数。我们用Ck表示链，起因于C的最右面的区块移除。如果k大于等于len(C),我们定义Ck=.我们让C1  C2表示链C1是链C2的前缀。

**定义 4.5** （时间点）。时间点是R邻近的位置S={Sl1,...SLR}的集合

（值R是协议的参数，我们在这一章节分析的）

**定义 4.6** （敌对的质押比例）。让Ua成为由敌对方控制的利益相关者的集合。那么敌对质押比例被质押为：



n是利益相关者的综述，si是利益相关者Ui的质押

**位置领导者选择** 在这一章里描述的协议中，对于每个0<j<r,一个位置领导者Ej被决定，谁由这个（唯一的）权利去在slj处生成一个区块。特别地，对于每个位置，一个利益相关者被选择为位置领导者，带有可能性pi，和他们在创世块B0中登记的它的质押成比例；这个分配在位置间是独立的。在这个静态的质押情况，创世块也成为过程，选择领导者，由理想的函数决定，在图标1中定义。这个函数由用参数表示，分配给每个利益相关者它的分别的质押，一个分布D，提供辅助的信息p和一个领导选择函数F，如下定义：

**定义 4.7** (领导者选择处理)。一个领导者选择处理，关于利益相关者分布 是一个对，由分布和确定性函数组成，比如，当p d,它保持，对于所有，输出，带有可能性。

si是由利益相关者Ui持有的质押（我们称之为根据质押的权重）；此外，随机参数的家族是独立的。

我们注意到和质押成比例取样可以被实施，以一个简单的方式。例如，一个间的处理操作如下。让。对于每个，如果没有利益相关者被选择，这个处理掷p倾向的币；如果币的结果是1，参与方Ui被选择为这个位置，这个处理被完成。（注意pn=1,所以这个过程被确定去完成，带有一个独立的梯子）。当我们实施这个过程，作为函数F.足够的随机性必须被分配去模拟有偏见的掷硬币。如果我们实施上述，带有精度，对于每个独立的掷硬币，然后选择一个利益相关者会要求随机字节，总计。注意使用一个伪随机数生成器（PRG），一个人可能用较短的“种子”字符串，然后拉伸它，使用PRG到合适的长度。
**功能**

[模式] 包含传播和私钥/交易函数，来自章节2，由公钥和最初利益相关者的分别的质押的参数确定，分布D和函数F，因此（D,F）是一个领导者选择过程。另外，是被mode的参数确定的，决定签名验证钥是如何生成的。当[模式]实例化，带有mode=SIG(resp. mode=FDSIG),被表示为（）。和利益相关者交互作用，如下：

- **签名钥对生成：** 生成签名的和验证的钥ski,vki,对于利益相关者Ui,通过执行。生成，通过查询，带有，代表Ui（带有一个唯一的会议标识符sidi,和Ui相关联），设置（ski = sidi, vki=vi）(从Fdsig接受作为回复)，对于i=1,....n.设置。

- **创世块生成**  再接受（ ），从利益相关者，如下开始。如果p还没有被设置，抽样 pd.无论如何，发送给Ui
- **签名和验证** 提供通向Fdisg界面的访问

**在模型的协议** 我们通过描述一个基于区块链协议的简单的PoS开始，考虑静态的质押，在混合的模型，例如，当创世块B0（和因此位置的领导者）被决定，由理想的函数。提供利益相关者，带有创始块，包括一个质押分布，由签名验证私钥为索引，由EUF-CMA签名组合生成，当从签名的理想函数中获得这样的钥。微妙的不同开始起作用，当描述一个理想的版本，在过渡的混合自变数使用的，安全的证明，会在章节4.2中讨论。利益相关者U1，....UM在他们自己中互相作用，带有，通过协议，在图标2中描述的。

这个协议依赖于maxvalidS(C,C)函数，选择一个链，考虑到当前的链C，和一组有效链C的，在网络中存在。在静态的情况下，简单的“最长链”规则（在动态的情况下，这个由一个普通的链长度确定参数；参照章节5）

函数maxvalid(C,C):返回最长链，从。结被打破，由利于C，如果有最大的长度，或武断地，否则。

**协议**

是一个由利益相关者U1,....Un运行的协议,和相互影响，在一系列的位置S={}处理如下：

1. **初始化** 利益相关者Ui 2 {U1, . . . ,Un，从密钥登记界面接受，它的公司钥。然后它收到当前的位置，从广播界面，假释它是SL1,它发送，到，收到作为答案。Ui设置本地区块链C = B0 = (S0, )，并且最初的内部状态。否则，它从密钥登记界面收到最初的链C，设置本地区块链到C和最初的内部状态st = H(head(C)).
2. **链扩展** 对于每个位置slj 2 S,每个利益相关者Ui执行如下步骤

(a) 收集所有的有效链，通过广播到集合C收到的，验证，对于每个链和每个链，它包制，当vk时利益相关者的验证密钥，计算=，作为新的本地链，设置状态。

(b) 如果Ui时位置领导者，由F决定的，它生成一个新的区块B=，st时它的当前状态，d时交易数据，是一个在。。商店额签名，Ui计算，广播C,设置C，作为新的本地链，设置状态。

3. **交易生成** 考虑到交易模板tx, Ui返回，如果tx按照Ui的观点和账簿的状态一致。

**4.2 理想协议的安全分析**

作为SPoS的安全分析的第一步，我们将引入一个理想化的协议iSPoS，并展示一个过渡的混合的自变数，展示从计算方面讲，和SPoS不能区分的

代替依赖FD,FLS [SIG]和一个EUF-CMA签名组合，iSPoS带有一个理想的签名组合操作。为了那个目的，iSPoS和FD,FLS [FDSIG]相互作用，为了获得签名和验证密钥，用于在协议中采用的签名的理想组合。在下面的学期中，我们会证明iSPoS是安全的，通过一系列组合的论证。我们首先展示这个混合的原因是，我们打算隔离这些组合的参数，从特定的细节，基础的签名组合，被用来举例证明SPoS和偏差，这些组合可能在SPoS的分布中结束，集中，替代理想的执行，几秒组合被完美的意识到，影响我们协议的真实属性。

**功能 Fdsig**

FDSIG按如下方式和利益相关者交互作用：

**密钥生成**  在收到来自利益相关者Ui的信息(KeyGen, sid)，为一些sid验证sid =(Ui, sid0)。如果不是，忽略这个要求。另外，将(KeyGen, sid)交给敌对放。在从敌对放收到(VerificationKey, sid, v)，输出(VerificationKey, sid, v)到Ui,记录对(Ui, v).

**签名生成** 从Ui处收到一个消息(Sign, sid,m)，为一些sid0验证sid =(Ui, sid0)。如果不是，那么忽略要求。另外，发送(Sign, sid,m)给敌对放，在收到从敌对方收到(Signature, sid, m, )，验证没有条目(m, , v, 0)被记录。如果是，那么输出一个错误的信息给Ui,并且停止。此外，输出(Signature, sid, m, )给Ui,并且记录条目(m, , v, 0).

**签名验证** 在从利益相关者Ui收到一个信息(Verify, sid, m, , v0)，把(Verify, sid, m, , v0)交给敌对方。在从敌对方处收到(Verified, sid, m, )：

1. 如果v0 = v，并且条目(m, , v, 1)被记录，那么设置f = 1.（这个条件确保完整：如果验证密钥v0是登记的那个，是为m合理的生成的签名，那么验证成功）
2. 另外，如果v0 = v,签名者没有被夫八百，并且没有对于任何0的条目(m, 0, v, 1)被记录，那么设置f = 0，并且记录条目(m, , v, 0).（这个条件确保不可伪造性：如果v0是登记的那个，签名者不会被腐败，并且从不会签署m,那么验证失败）
3. 另外，如果有一个条目(m, , v0, f0)被记录，那么让f = f0.（这个条件确保一致性：所有的验证要求，带有完全相同的参数会导致相同的答案）
4. 另外，让f = ，并且记录条目(m, , v0, ).

输出(Verified, sid, m, f)给Ui.

第一，在图形3，我们展示了函数Fdsig,在【14】中被定义的，也被展示位EUF-CMA签名组合认识到Fdsig.注意这个事实会被用做去展示我们理想的协议可以实际的被认识到，基于实际的数字签名组合，比如DSA和 ECDSA），最后，iSPoS和SPoS.是不能区分。

理想的协议iSPoS被利益相关者运行，和FD,FLS [FDSIG] 与FDSIG相互作用。基本上，iSPoS作为SPoS来运转，除了条用Vrfvk() 和 Signsk(m).也就是说，不是本地计算Signski(m)，Ui发送(Sign, sid,m)给FDSIG,收到(Signature, sid, m, )并且输出作为签名。此外，不是本地计算Vrfvk0(,m)，Ui发送(Verify, sidi, m, , v0)给FDSIG（v0对应验证密钥vk0），输出在消息(Verified, sidi, m, f)中收到的值。协议iSPoS在图形4中被描述。理想的描述会被进一步的开发，当讨论动态的质押情况，额外的建立的区块必须在理想的协议里被考虑。

如下的名命题是一个结果的立即的推论，在展示,EUF-CMA签名组合意识到FDSIG

**命题 4.8** 对每个PPT A,Z它保持，那儿有一个PPT S，因此EXECP,FD,FLS [SIG]SPoS,A,Z ()和EXECP,FD,FLS [FDSIG]iSPoS,S,Z ()从计算方面讲是不能区分的

鉴于上述命题，在剩下的分析里我们会集中于这些协议iSPoS的性质。（注意这个含义不会适用于任何性质，一个人可能在为iSPoS执行考虑；然而我们讲为iSPoS证明的性质都由环境z可证实的,作为结果，他们可以被SPoS集成，由于命题）

**协议**

iSPoS是由利益相关者U1, . . . ,Un运行的而协议，和FD,FLS [FDSIG]相互作用，在一系列位置上，处理如下：

1. **初始化** 利益相关者Ui 2 {U1, . . . ,Un},从密钥登记接口处收到它的公钥和私钥。然后它从散开的接口收到当前的位置，假使它是本地sl1,它发送(genblock req,Ui)到FD,FLS [FDSIG],收到(genblock, S0, , F)作为答案。Ui设置本地去快快C = B0 = (S0, )，并且初始的内部的状态st=H(B0).另外，它从密钥登记接口收到初始的链C，设置本地区块链C和初始的内部状态st = H(head(C)).
2. **链拓展** 对于每个位置slj 2 S,每个利益相关者Ui执行如下步骤：

(a) 收集所有有效的链，通过广播到一个集合C接受，验证：对于每个链C0 2 C和每个区块B0 = (st0, d0, sl0, 0) 2 C0，它保持FDSIG答复，带有(Verified, sid, (st0, d0, sl0), 1)，在被带有(Verify, sid, (st0, d0, sl0), 0, vk0),查询，vk0是利益相关者U0 = F(S0, , sl0).的验证私钥。Ui计算C0 = maxvalid(C,C),设置C0作为新的本地链，设置状态st = H(head(C0)).

(b) 如果Ui是由F(S0, , slj )决定的位置领导者，它生成了一个新的区块B = (st, d, slj , )，st是当前的状态，d 2 {0, 1}是加偶i数据，是从FDSIG’s的答复(Signature, sid, (st, d, slj), )得到的，在被带有(Sign, sidi, (st, d, slj )).查询

3. **交易生成** 考虑到一个交易模板tx，Ui返回，从FDSIG’s答复(Signature, sidi, tx, )获得，在被带有(Sign, sidi, tx)查询，如果tx是和账簿的状态是一致的，按照Ui的观点。

**4.3 可分叉的字符串**

在我们的安全参数里，我们例行公事地用{0, 1}n的元素去表面哪个位置，在一个特别的长度为n的位置窗口，被分配给敌对的利益分配者。当字符串有这样的解释时，我们涉及他们作为特有的字符串。

**定义 4.9** (特有的字符串) 确定一个带有创世块B0的执行，敌对方A,和环境Z.让S = {sli+1, . . . , sli+n}表示一系列长度|S| = n的位置。S的特有的字符串w 2 {0, 1}n被定义，因此wk = 1，如果，并且只有如果敌对方控制位置sli+k的位置领导者。对于这样一个特有的字符串w 2 {0, 1}，我们说索引i是敌对的，如果i哦wi = 1，并且诚实，否则。

我们从一些我们方式的直觉上去分析这个协议。让w 2 {0, 1}n成为一个特有的字符串，对于一系列位置S。考虑到两个观察(i)立即下线，限于S的开始，(ii.)有当前链的相同的观点C0，先于S的开始，(iii.)回到线上，在S的最后位置，要求他们链的一个更新。在我们的分析里一个基本的关心是可能性，这样的观察者能够被展示，带有一个发散的视角，在序列S上：特别地，这个可能性，敌对方能强迫两个观察者去采用两个不同的链C1,C2,其普通的前缀是C0.

我们观察到不是所有的特有的字符串允许这个。例如，字符串（完全诚实的）0n确保两个观察者采用相同的链C，包含n新的区块，在普通的前缀C0之上。另外一方面，其他字符串不能确保C0的这样的普通的扩展；在1n的情况下，对于敌对方是可以生成两个完全不同的历史，在位置S的序列期间，给两个观察者提供两个有区别的链C1,C2,仅仅共享普通的前缀C0。在这一张的剩余部分，我们建立，允许这样分叉的字符串非常少，事实上，我们展示，他们有密度，只要敌对方位置的部分是1/2 − .

关于特有的字符串w 2 {0, 1}n,分叉的原因，我们定义如下正式的分叉的概念，捕获在链广播之间的关系，通过诚实的位置领导人，在协议iSPoS的执行期间。为了对定义做准备，我们回想起诚实的选手总是选这去扩展一个最大长度的链，在这些对网络中选手可能的选项中。此外，如果这个一个最大的链C包含一个区块B，之前由诚实的选手广播，C的前缀优先于B必须完全的和链一致（在B处中止），由前面的诚实选手广播。跟随性质即刻跟随，从这个事实，任何诚实的区块的状态有效地焦黑一个独特的链，在创世块开始的。最后，然和由诚实选手广播的链C以一个由诚实选手之前生成的链开始（或者，替代地，创世块），继续，带有一个可能的敌对区块的空的序列，最后，带有一个诚实的区块而终止。它遵循由诚实选手广播的链形成一个自然的直接树形网络。诚实选手可可信赖的广播他们的链，并且总是在最长可能的链上建立的事实引入了这个树的第二哥重要性质：各种各样诚实区块的深度，由诚实选手添加，在协议必须全部是可区分的。

当然，由iSPoS的执行引起的实际的链由区块组成，包含各种各样的数据，对于关于分叉的原因是无形的，为此。以下分叉的正式概念仅仅反应直接的树，由相关链形成的，选手的身份，被表达成在字符串w,对在这些链上生成区块负责。

**分叉和分叉的字符串** 我们定义，如下，基本的组成结构骂我们用来去推出可能的观点，由诚实的选手观察的，在一个协议执行期间，带有特别的字符串

**定义 4.1 (分叉)** 让w 2 {0, 1}n，并且让H = {i | wi = 0}表示诚实的指数的集合。对于字符串w的分叉是一个直接的，根源的树F = (V,E)，带有一个标签`：V ! {0, 1, . . . , n}，因此：

- F的每个优势都是从根来;
- 根r 2 V是给定的标签`(r) = 0
- 标签，和任何直接的路径一起，在树上，是严格的增长的
- 每个诚实的索引i 2 H是精确的F的顶点
- 函数d : H ! {1, . . . , n},定义，因此d(i)是在F,独特的顶点v,对于`(v) = i是严格的增加的。（特别的，如果i, j 2 H and i < j, 那么 d(i) < d(j).)）

图形 5：对于字符串w = 010100110的分叉F；顶点出现，带有他们的标签和诚实的顶点用双边界强调。注意诚实顶点的深度，和诚实的w指数相关联，被严格的增加。两个尖头在图形中被区分：一个以ˆt为标签，在以9为标签的顶点终止，在分叉中是最长的尖头；第二个尖头在标签为3的顶点终止。数量gap(t)表明在长度上的不同，在t和ˆt之间；在这个情况下gap(t) = 4.数量reserve(t) = |{i | `(v) < i  |w| and wi = 1}|表示敌对指数的数量，在最后诚实顶点V的标签后出现，在这个尖头里；在这个情况reserve(t) = 3.当每个F的叶子是诚实的，F被关闭了。

作为注释的问题，我们写F ` w去表示F是对于字符串w的一个分叉。我们说分叉是不重要的，如果他包含一个单个的顶点，根。

**定义 4.11** （尖头，深度，和高度；~关系）。在从根引起的分叉F的路径叫做尖头。对于尖头t，我们让length(t)表示他的长度，等于在路径中的边缘的数量。对于顶点v,我们让depth(v)表示（独特的）尖头的长度，在v处终止。一个分叉的高度（和一个树一样平常，被定义为最长尖头的长度）。

我们过载符号`()，因此他们应用到尖头上，通过定义`(t) , `(v),v是在尖头t上的终点的顶点。对于分叉F的两个尖头t1 和t2，我们写t1  t2，如果他们分享一个边缘。注意那个是一个等价关系，在非平凡的尖头的设置上；换句话说，如果t表示“空的”尖头，单独的包含根顶点，那么对于任何尖头t,t 6 t.

如果分叉的顶点V带上一个敌方的索引做标签的（例如，w`(v) = 1），我们说顶点是敌对的；否则，我们说顶点是诚实的。为了方便起见，空的尖头t是诚实的。

参照图片5作为例子，也证明了上述的和这个章节剩下的当众定义的一些数量。在图形中展示的分叉反映了一个执行，在诚实的选手，和第一个位置联系，直接在创世块上建立的（正如他必须），（ii）诚实的选手，和位置5关联的，被展示位长度2的链，在步骤链上建立的。带有一个进一步的敌对的区块最大，由位置的选手生成等。

**定义 4.12** 我们说分叉是平的，如果有长度的两个尖头t1 6 t2，等于分叉的高度。字符串w 2 {0, 1}据说分叉，如果有一个平的分叉F ` w.

注意位了一个iSPoS的执行，去产出两个完全最大长度的不连贯的链，和执行相关的特有的字符串将会被分叉。我们的目标是去建立如下上限，在分叉字符串的数量上。

**定理 4.13** 让 2 (0, 1)，并且让w成为一个字符串，另外子{0, 1}n，通过独立的给每个wi = 1赋值，带有可能性(1 − )/2。那么Pr[w is forkable] = 2−(p、n).

注意，在随后的工作重，Russell et al.改进这个限制到2−(n).

 **分叉的结构的特点：关闭的分叉，前缀，到达，和边缘** 我们通过为两个分叉定义一个自然的包含概念开始：

**定义 4.14** （分叉前缀）如果w是字符串w0 2 {0, 1}的前缀，F ` w, 并且 F0 ` w0,我们说F是F0的前缀，写作F v F0,如果F是F0.的一致的标签的子图，特别地，F的每个顶点和边缘在F0重出现，除外，给予任何顶点的标签在F 和F0重出现的是完全相同的。

在许多情况下，和分叉一起工作是方便的，不发表任何超过最终诚实指数的事情。

**定义 4.15** （关闭的分叉）。一个分叉被关闭，如果每个叶子都是诚实的。根据惯例，轻微的分叉，单独的包含一个根顶点，被关闭。

注意，一个关闭的分叉有一个独特的最长尖头（当所有的最大尖头带有一个诚实的顶点终止，并且这些必须有明显的深度）。注意，此外，如果w是w的前缀，并且F ` w,那么哪里有一个独特的关闭的分叉ˇ F ` ˇ w，对于F v F.尤其，使得w = w,我们注意到对于任何分叉F ` w,有一个独特的分叉F ` w，对于F v F;在这个情况下，我们说F是F的终止。

**定义 4.16** (缺口，储备和延伸)。让F ` w成为一个关闭的分叉，并且让ˆt表示（独特的）在F重的最大长度的尖头。我们定义尖头t的差距，表示为gap(t)，成为ˆ和ˆ之间的长度上的不同：

gap(t) = length(ˆt) − length(t) .

我们定义尖头t的储备成为敌对的指数数量，出现在w重，在t的最后的指数后；特别的，如果t是由path (r, v1, . . . , vk),给定的，r是F的根，我们定义：

reserve(t) = |{i | wi = 1 and i > `(vk)}| .

我们注意到这个数量取决于F和特定的字符串w，和F相关联。最后，对于尖头t,我们定义：

reach(t) = reserve(t) − gap(t) .

**定义 4.17** （利润）。对于一个关闭的分叉F ` w，我们定义(F)为最大的延申，接管所有在F重的尖头：

(F) = maxtreach(t) .

同样的，我们定F的边缘，表示为μ(F),成为倒数第二的延申，接管F的边缘-脱散：特别低

margin(F) = μ(F) = max
t16t2

min{reach(t1), reach(t2)}

. (1)

我们注意到上述极限总是由诚实的尖头获得。特别低，如果t是一个分叉F ` w,的敌对方的尖头，延申reach(t)  reach(t),t是t的最长的诚实的前缀。

正如在非空尖头上是一个等价关系，它遵循，那总是有一对（边缘-打散）尖头t1 和 t2，完成最大的，在定义的等式中，满足reach(t1) = (F)  reach(t2) = μ(F).

利润的对于可分叉概念的关联在下述命题中被反映：

**命题 4.18** 字符串w是可分叉的，如果，仅仅如果又一个关闭的分叉F ` w，对于margin(F)  0.

证明。如果w没有诚实的指标，那么微小的分叉，包含一个单个的根节点是平的，关闭，并且没有非负利润；因此，两种情况是平等的。考虑分叉的字符串w,带有至少一个诚实的指标，用ˆi表示w的最大的诚实的指标。让F称为平的分叉，对于w.让F ` w称为F的关闭（从F处获得，通过移除任何敌对的至高点，来自F的尖头的结尾）。主义尖头ˆt包含ˆi，是F中的最长的尖头，当这个是w的最长的诚实的指标。另一方面，F是平的，在情况：有两个边缘-打散尖头t1和t2,带有长度，至少是ˆt的。在F中的这些两个尖头的前缀必须清晰的有储备，不小于间距（因此非负到达）； 因此margin(F)  0作为要求的。

另一方面，假设w有一个关闭的分叉，带有margin(F)  0，有F的两个边缘-分散尖头，t1和t2，对于到达ti)  0.那么我们能生成一个平的分叉，通过简单地给每个ti增加一个gap(ti)至高点的路径，以随后的敌对的指数为标签，由reserve()的定义允诺。

根据这个命题，对于字符串w，我们把注意力几种在数量上：

并且，为了方便

注意这过载符号(·) 和 μ(·)，因此他们适用于分叉和字符串，但是设置会从环境中清楚。我们决策定义不保证一个优先的(w) and μ(w)可以被相同的分叉完成，虽然这会在如下引理中建立。无论如何，是对于字符串w，(w)  0 和 (w)  μ(w)清楚的；此外，根据命题4.18，字符串w是可分叉的，如果并且仅仅如果μ(w)  0.我们指的是μ(w)作为字符串w的利润。

为了证明定理4.13做准备，我们建立一个递归的描述，对于这些数量。

**引理 4.19** m() = (0, 0)，对于所有的非空字符串2 {0, 1}

此外，对于每个字符串w,由一个关于的分叉Fw ` w，对于m(w) = ((Fw), μ(Fw)).证明。这个证明通过归纳法进行，如果w = ,定义F称为席位的分叉；F ` w是独特的分叉，对于字符串，并且m() = (0, 0) = ((F), μ(F)),作为要求。

总之，我们考虑m(w0)，对于字符串w0 = wx—where w 2 {0, 1} 和x 2 {0, 1};论证递归地扩展m(w0)，根据m(w)和最后符号x的值。在每种情况，我们考虑在两个关闭分叉v F0之间的关系，F ` w和 F0 ` w0 = wx。

在x=1的情况下，我们必须有如图表所示F = F0，因为分叉被认为是被关闭的；容易看到F ` w的任何尖头t的到达增加，精确的1，当看作F0 ` w0的尖头。我们写到达F0(t) = reachF (t) + 1，我们引入符号reach()去表示在特定分叉丽的到达。它遵循(F0) = (F) + 1 和μ(F0) = μ(F) + 1。如果F ` w0是关闭的分叉，对于(F) = (w0),注意F可能被作为对于w的一个分叉对待，并且使用上述论证，我们发现(w0)  (w)+1，一个相似的论证意味着μ(w0)  μ(w) + 1.另一方面，通过归纳法，有一个分叉Fw，对于m(w) = ((Fw), μ(Fw))，因此m(w0)  ((w) + 1, μ(w) + 1).我们推断：

m(w0) = ((w) + 1, μ(w) + 1) .

此外，m(w0) = ((Fw), μ(Fw)),Fw 被作为对于w0 = w1作为分叉对待。

x = 0的情况是更雅致的。如上，我们考虑在两个关闭分叉F ` w and F0 ` w0 = w0之间的挂巴西，对于F v F0.这里F0必要地从F中获得，通过修改一个路径，标签为一个字符串，形式1a0到F的尖头t的末尾。（实际上，容易看到我们可能总是假定这个被附加到一个诚实的尖头上）。为了让这个称为可能，gap(t)  reserve(t)（可以说reach(t)  0），特别地，gap(t)  a  reserve(t):对于第一个不平等注意新的诚实的顶点的深度必须超过F中最深的（诚实的）顶点，因此a  gap(t);关于第二个不平等，仅仅reserve(t)可能敌对的指数，可能被添加到t中，因此a  reserve(t).我们定义数量a  0，通过等式a = gap(t) + ˜a，用t0表示尖头（F0的），有扩展t在这个方式导致的。我们说˜是参数低于分叉F v F0.的对。

当然，每个F的诚实的尖头t是一个F0的诚实的尖头，清楚的是reachF0(t) =
reachF (t) − (˜a + 1)，当在F0中最长的尖头t0超过F的最长的尖头的长度，通过精确的˜a + 1.注意新的诚实的尖头t0(在 F0)的到达总是0，当gap(t0)和reserve(t0)是0.保持去描述μ(w) and (w)如何被这个过程决定的。

情况(w) > μ(w) = 0。通过归纳法，有一个分叉Fw，对于m(w) = ((Fw), μ(Fw)).让t1 和 t2称为Fw的边缘-松散的尖头，对于(Fw) = reach(t1) and μ(Fw) = reach(t2).定义F0 ` w0为分叉，通过扩展Fw的尖头t2来获取，带有参数˜a = 0去生成在F0中的新的t02。那么到达F0(t1) = (w)−1和到达F0(t02) = 0。它遵循(w0)  (w) − 1 and μ(w0)  0.。我们将展示(w0)  (w) − 1和μ(w0)  0,μ(w0)  0,情况我们可以推断：

(w0) = (w) − 1 and μ(w0) = 0 .

此外，分叉Fw0 = F0获得这些统计资料，作为要求。

我们返回到建立(w0)  (w) − 1和μ(w0)  0.让F ` w0称为一个关闭的分叉，对于(w0) = (F)，让F ` w称为独特的关闭的分叉，对于F v F;同上，用˜a表示对于这个扩展的参数。让t称为F的诚实的尖头，因此reachF(t) = (w0).如果t是F的尖头，reachF(t) = reachF (t) − (˜a + 1)  (w) − 1.否则，t从扩展中获得，通过扩展，reachF(t) = 0  (w) − 1通过假设。在任何一种情况(w0)  (w) − 1,如要求。保持去展示μ(w0)  0。现在考虑F ` w0称为关闭的分叉，对于μ(F) = μ(w0).让t1 和 t称为F*的两个边缘-松散的诚实的尖头，因此，reachF(t1 ) = (F) and reachF(t2) = μ(F) = μ(w0).让F ` w称为独特的关闭的分叉，对于F v F。让a称为对于这个扩展的参数。t1和 t两者是F的尖头，达成reachF(t
i ) = reachF (t
i ) − (˜a + 1)，特别地，达成(t1)  reachF (t2 ).它遵循reachF (t2 )  μ(F)  μ(w) = 0，因此μ(w0) < 0.否则，两个尖头中的一个是扩展的结果，有0reach()在F中，正如F(t1 )  reachF(t2),在任何情况，它遵循μ(F) = reachF(t2 )  0,如要求。

**情况** (w) = 0。通过归纳法，有一个分叉Fw，对于m(w) = ((Fw), μ(Fw)).让t1和 t2成为FW的边缘-大三的尖头，which (Fw) = reach(t1) and μ(Fw) = reach(t2).定义F0 ` w0称为分叉，通过扩展Fw的尖头t1获得，带有参数˜a = 0，去产出新的尖头t01，在F0.然后达成F0(t01) = 0，并且达成F0(t2) = reachF (t2) − 1.它遵循(w0)  0 and μ(w0)  μ(w) − 1.我们会展示(w0)  0 and that μ(w0)  μ(w) − 1,在这种情况下我们可以推断

(w0) = 0 and μ(w0) = μ(w) − 1 .

而且，分叉Fw0 = F0获得这些统计资料，如需求。

我们返回去建立(w0)  0和μ(w0)  μ(w) − 1.让F ` w0称为一个关闭的分叉，对于(w0) = (F)，让F ` w称为毒液的关闭的分叉，对于F v F；如上，用a标示对于这个扩展的参数。让t称为F的诚实的尖头，因此达成F(t) = (w0).注意t不能称为F的将头；如果它然后reachF(t) = reachF (t) − (˜a + 1)  (w) − 1 < 0，和(w0)  0矛盾。因此t由扩展获得，并且达成F(t) = 0.它保持去展示μ(w0)  0。现在让F ` w0称为一个关闭的分叉，对于μ(F) = μ(w0).让t1 和 t2成为F的两个边缘-打散的诚实的尖头，因此达成F(t1) = (F) 并且reachF(t2) = μ(F) = μ(w0).让F ` w称为F的独特的尖头；如果是，(F) = reachF(t1 ) = reachF (t1 )−(˜a+1)  (F)−1 
(w) − 1 < 0，和(F)  0.矛盾，它遵循t1必须扩展一个F的尖头t1，对于reachF (t1) = 0,i那位扩展仅仅能发生，对于非负的到达的尖头和(F) = 0 = (w).因此t2是F的尖头，并且t1 6 t2，因此reachF (t2)  μ(F)  μ(w)，并且我们得出结论μ(w0) = reachF(t2)  reachF (t2 ) − 1  μ(w) − 1,如要求。

**情况** (w) > 0, μ(w) 6= 0.通过归纳法，有一个分叉Fw，对于m(w) = ((Fw), μ(Fw)).让t1和 t2成为Fw的边缘-拆散的尖头，对于(Fw) = reach(t1) and μ(Fw) = reach(t2).实际上，Fw的任何扩展都将足够构建；举个具体例子，定义F0 `
w0称为分叉，从扩展Fw的尖头t1获得，带有参数˜a = 0.那么reachF0(ti) = reachFw(ti) − 1.它遵循(w0)  (w) − 1 和 μ(w0)  μ(w) − 1.我们将展示(w0)  (w) − 1 和 that μ(w0)  μ(w) − 1,我们将推断：

(w0) = (w) − 1 and μ(w0) = μ(w) − 1 .

此外，分叉Fw0 = F0完成这些统计数据，按照需求。

我们回到建立(w0)  (w) − 1 and that μ(w0)  μ(w) − 1.让F ` w0称为一个关闭的分叉，对于(w0) = (F)，让F ` w称为独特的关闭的分叉，对于v F；同上，用˜a表示这个扩展的参数。让t成为F的诚实节点，因此reachF(t) = (w0).注意，如果t是F的尖头，那么reachF(t) = reachF (t) − (˜a + 1) 
21
(w) − 1;否则，t通过扩展和reachF(t) = 0  (w) − 1,获得，如需求（回想起(w) > 0.)它保持展示μ(w0)  μ(w) − 1.现在让F ` w0成为关闭的分叉，对于μ(F) = μ(w0).让t1 和 t2成为F的两个边缘-打散的诚实的尖头，因此reachF(t1) = (F) and reachF(t2 ) = μ(F) = μ(w0).让F ` w成为杜特地关闭的分叉，对于F v F，让a成为对于这个扩展的参数。如果t1 和 t两者是F的尖头，那么reachF(t
i ) = reachF (t
i )−(˜a+1)，特别地，reachF (t1 )  reachF (t2 )，因此reachF (t2 )  μ(w) and reachF(t2 )  μ(w) − 1,如要求。

为了完成论证，我们认为这个情况，尖头t的其中一个通过扩展出现。注意在这个情况reachF(t2)  0,或t2是从扩展种获得的，因此有0到达，或t1从扩展种获得，因此F(t2)  reachF(t1) = 0。这里我们进一步把分析分成两种情况，在μ(w)的符号上：

- 如果μ(w) > 0,那么reachF(t2)  0  μ(w) − 1，如需求
- 如果μ(w) < 0，那么t2不能成为F种的尖头的扩展。来看这，假定相反地，t2扩展F的一个尖头t2;那么reachF (t2)  0.除外，t1必须是F的尖头，边缘-打散，从t2,并且(t1 ) = reachF(t1 ) + (˜a + 1) > 0.它遵循μ(w)  μ(F)  0,一个矛盾

其他可能性是t1是F的尖头t1的扩展，在这种情况reachF (t1) 0.注意t2是F的尖头，并且边缘-打散来自t1;因此min(reachF (t2), reachF (t1)) μ(F) < 0 and reachF (t2)  μ(F).我们推断reachF(t2 ) = reachF (t2 )−(˜a+1) 
μ(w) − 1,如要求。

在合适的位置的递归描述，我们返回定理4.13的证明，我们为了方便在下面重讲。

**定理 4.13， 重讲** 让 2 (0, 1)，并且让w成为从{0, 1}n的字符串，通过独立地赋值每个wi = 1，带有可能性(1 − )/2.那么

Pr[w is forkable] = 2−
(p
n) .

定理4.13.的证明，定理影响在{0, 1}n上的可能性分布，由独立的选择每个wi 2 {0, 1}给定，因此：

Pr[wi = 0] = 1 + 
2 = 1 − Pr[wi = 1]

w是从分布中提取的。对于字符串w1 . . .wn，带有上述可能性分布选择，定义随机变量

Rt = (w1 . . .wt) and Mt = μ(w1 . . .wt) .

我们的目标是建立

Pr[w forkable] = Pr[Mn  0] = 2−
(p
n) .

我们从引理4.19的描述中提取一些关于随机变量的事实

Rt > 0 =)
(
Rt+1 = Rt + 1 if wt+1 = 1,
Rt+1 = Rt − 1 if wt+1 = 0;
(3)
Mt < 0 =)
(
Mt+1 = Mt + 1 if wt+1 = 1,
Mt+1 = Mt − 1 if wt+1 = 0;
(4)
Rt = 0 =)
8>><
>>:
>>Rt+1 = 1 if wt+1 = 1,
>>Rt+1 = 0 if wt+1 = 0,
>>Mt+1 < 0 if wt = 0.
>>(5)
>>In

根据上述性质3，随机变量是非常行为端正的，当是正的，特别，考虑分布，在每个wi上，他们仅仅遵循相似的片面的图形6的步行。同样地，考虑性质（4），随机变量Mt尊重一个片面的随机步行当负的。证明的剩余部分组合可能性规律，带有（5），和事实Mt()  Rt()，去建立Mn < 0带有高的可能性。

我们回想起两个关于标准的基础的事实，片面的不幸，和图标6的Markov链有关联。让Zi 2 {±1} (for i = 1, 2, . . .)表示独立随机变量的家族，对于Pr[Zi = 1] = (1 − )/2.那么片面的不幸，由变量Yt = Pti
Zi给定由如下性质：

**恒定的泄露可能性；赌徒的毁灭** 带有恒定的可能性，仅仅依赖，Yt 6= 1对于所有t > 0.总之，对于每个k > 0,

Pr[9t, Yt = k] = k ,

对于一个恒定的 < 1，仅仅依赖.（实际上，常量是(1−)/(1+);参看例如[25, Chapter 12]，对于完整的开发）

**集中（切尔诺夫限制）** 考虑片面不幸的T步数，在状态0处开始；那么作为结果的值是紧紧地集中于−T .特别地，E[YT ] = −T，并且Pr

YT > −
T
2

= 2−
(T) .

（持续的隐藏在()概念，仅仅依赖。参照，例如[1, Cor. A.1.14]）

分割字符串w,我们写w = w(1) · · ·w(pn)，w(t) = w1+at−1 . . .wat and at = dt
p
ne,对于t = 0, 1, . . ..，让R(0) = 0 和 R(t) = Rat；类似地定义M(0) = 0 and M(t) = Mat。  成为小的常数

我们定义这些时间，基于随机变量R(t) 和 M(t):

**热** 我们用Hott表示事件R(t)  
p
n and M(t)  −
p
n.

**不稳定的** 我们让Volt表示事件−
p
n  M(t)  R(t) < 
p
n.

**冷** 我们让Coldt表示事件M(t) < −
p
n.

注意对于每个t,精确地这些事件中的一个发生，他们分割可能性空间，那么我们将建立:

注意通过定义发生的事件Vol0。假定这些不等式，我们观察到系统很有可能成为冷的，并且保持那个方式。假若这样，Coldpn发生，M
n < 
p
n < 0,并且w是不可分叉的。特别地，注意这个可能性系统曾经从易波动过渡到热的，不超过2−
(p
n)（当从Vol过渡到热是限制于依照2−
(p
n),以上，有不超过n的可能的过渡的机会）

注意，也是，当系统是不稳定的，它过渡到冷的，带有恒定的可能性，在每个阶段。尤其，可能性，系统对于整个过程是不稳定的，是不超过2−
(p
n).最后，注意可能性，系统曾经过渡出冷状态，是不超过2−
(p
n)（再次，有至多p
n可能的次数当这个可能发生，当任何个别的过渡发生，带有可能性2−
(p
n)).）它遵循系统是冷的，在带有可能性1 − 2−
(p
n)过程的结尾

它保持去建立三个不等式(8), (9), 和(10).

**不等式(8)** 这遵循直接来自(3) 和 (6).特别地，根据随机变量Mi罪刑简单的片面的步行的可能性的规律，当他们是负的。以M(t) = Mat < −
p
n为条件，可能性，任何未来Ms曾经攀登到值−1上，不超过−
p
n = 2−
(n),，根据需求*（这里 < 1是固定的常量，仅仅依赖于.）、

**不等式(9)** 这遵循来自(3), (5), (6), and (7).特别地，以Volt为条件，R(t) 

p
n.从(3)回想，随机变量Ri遵循简单的片面步行的可能性规律，当他们是正的。让D成为事件，Ri > 0，对于所有at  i < at+2
p
n.根据（7），那么，我们取T = 2
p
n, Pr[D]  2−
(p
n).带有接近的确定性，那么随机变量Ri访问值0在这个期间。观察如果Ri = 0那么，根据（5），Mi+1  −1带有恒定的可能性，并且（以这个为条件），根据（6），带有恒定的可能性，带有随后的随机变量Mj不返回到值0.此外，根据（7），可能性，有一个长度至少2(/)p
n的序列，对于：

超过(p
n)22−
(p
n).，它遵循，带有恒定的可能性，步行（Ri）碰撞0，如上描述，并且，那么Mi在一个小于−
p
n.的值处终止。

**不等式** (10):这遵循(3), (5), (6), 和 (7).特别地，以Volt为条件，R(t) 。从（3）中回忆：随机变量R遵循简单的片面的步行的可能性规律，当他们是正的。让D诚实事件，Ri > 0对于所有at  i < at+2
p
n.根据（7），那么，我们取T = 2
p
n, Pr[D]  2−
(p
n).带有接近的确定性，那么，随机变量Ri访问值0，在这个期间，以D为条件，为了Rat+1  
p
n，必须先有这些随机变量0 = Ri,Ri+1, . . . ,Rj =
b
p
nc的一个序列，因此，他们中都不取值0，除了第一个。（这样一个序列升起，通过取i成为最后的事件，变量Rat , . . .访问0和j,第一个随后的事件，序列大于
p
n.)）根据(6)，这样一个序列的可能性出现在一个特定的值对于i是不超过−
p
n.它遵循可能性，Rat+1  
p
n小于p
n−
p
n = 2−
(p
n),

**提取分叉的可能性，用于n的明确的值** 为了获得进一步的洞察力，关于分叉字符串的密度，我们精确地计算可能性，一个字符串w,从二项分布中提取，带有参数p 2 {.40, .41, . . . , .50}，是可分叉的，对于若干不同的长度。这些结果在图形8中表示。

**4.3.1  秘密的敌对方，秘密的分叉，秘密地可分叉字符串**

在上述定义4.10中定义的分叉的一般的概念反映了敌对的位置的领导者可能广播多重的区块，对于一个单个的位置；这样的敌对的重要的机会去和协议terfere,它留下一个可疑的“审核足迹”--多重的敌对方，广播部超过一个区块每个位置。这样一个敌手可能仍然从协议脱离，通过扩展短的链，但是不生成这样的可以的证据，并且因此它的策略是更多的“可否定的”：它能归咎于网络延迟，对于它的行为。

这样一个敌对方产出一个限制的分叉的定义，定义如下：

图标8：可能性的图标，一个从二项分布中提取的字符串是可分叉的。对于字符串长度n = 500, 1000, 1500, 2000图表被带有参数.40, .41, . . . , .49, .50.显示。

**定义 4.20** 让F ` w成一个分叉，对于一个字符串w 2 {0, 1}.我们说F是秘密的如果标签` : V ! {0, 1, . . . , }是单射的。尤其，，没有敌对的指数被超过一个节点归类。

当在通常情况下，我们定义分叉字符串的概念，对于这样的敌对方。

**定义 4.21** 我们说字符串w是秘密地可分叉，如果有一个平的秘密的分叉F ` w.

秘密的敌对方和分叉有更简单的结构，相比一般的敌对方。特别地，一个字符串秘密地可分叉，如果并且仅仅如果它的指数的大多数是敌对的。这对于秘密地可分叉字符串提供了命题4.18的类似物。

**命题 4.22** 一个字符串w 2 {0, 1}n是秘密的可分叉，如果并且仅仅如果wt(w)  n/2.

证明。让w成为一个秘密的可分叉的字符串和F ` w一个平的秘密的分叉。当F是平的，有两个边缘打散尖头，t1 和 t2,带有长度，等于height(F)。它遵循F中顶点的数量至少是2 · height(F) + 1.在秘密的情况下，归类功能是内射的，并且它遵顼n  2 · height(F).（回想根顶点被贴上标签0，不是一个进入w的指数）。换句话说，F的高度至少是w的诚实指数的数量。我们推断w的长度至少是最诚实的指标的数量的两倍，根据要求。

如果wt(w)  n/2,我们能生成一个平的秘密的分叉F ` w，通过在一个普通的尖头t1上放置所有的最诚实的指数，选择length(t1)敌对的指数去形成一个边缘-打算的第二的尖头t2.

当秘密的可分叉的字符串的结构是如此简单，定理4.13的类似物，对于秘密地可分叉的字符串的密度，直接的遵循，来自标准的大的偏差限制。

**定理 4.23** 让 2 (0, 1)，并且让w成为从{0, 1}n中提取的字符串，通过独立地赋值每个wi = 1，带有可能性(1 − )/2.那么

Pr[w is covertly forkable] = 2−(n) .

证明。这个从标准的估计产生，对于二项分布的累积的密度函数。

**秘密的可分叉性的精确的可能性，对于n的明确的值** 为了和一般情况比较，我们计算可能性，一个从二项分布提取的字符串秘密地可分叉。这些结果在图形9中展现。（注意这些可能性是二项分布的累积的密度函数的简单的适当的评估）。对于一般情况的类似的结果在图形9中出现。

秘密的可分叉性的可能性

图形9： 可能性图标，一个从二项分布中提取的字符串是秘密地可分叉。对于字符串长度n = 500, 1000, 1500, 2000的图表带有参数.40, .41, . . . , .49, .50.显示。

**4.4 普通的前缀**

回忆由最诚实的选手组成的链，在iSPoS的执行期间，符合分叉的建有，正如在前面的章节定义和学习的。位置的随机分配，对于由FD,F给定的利益相关者确保相关联的典型的字符串w的坐标遵循二项式分布，带有可能性，等于敌对的质押。因此，定理4.13建立了，协议iSPoS没有执行会引起两个尖头（链），最大长度不带有普通的前缀.

在iSPoS的情况下,但是,我们希望建立一个更加强壮的普通前缀性质.链的任何对,可以,原则上,由敌对方呈现给最诚实的方,有一个"最近的"普通的前缀,从某种意义上说,移除一小部分区块,从较短的链上,导致更长的链的前缀.

为了正式地明确有力的表达和证明这个性质,我们介绍一些进一步的定义,关于尖头和分叉.我们借用"截词符",对于链在论文中更早的描述的:对于一个尖头t,我们用tdk表示这个尖头,通过移除最后的k边缘获得的;如果length(t)  k,我们定义length(t)  k,仅仅由根组成.

**定义 4.24** (可行性) 让F ` w成为一个分叉,对于字符串w 2 {0, 1}n,让t成为F的一个尖头.我们说t是可行的,如果,对于所有诚实的指数h  `(t),,我们有:

d(h)  length(t) .

(回忆`(t)是t的终点的顶点的标签)

如果t是可行的,一个外部的(诚实的)观察者证明这个执行,在时间`(t),如果提供了尖头t,带有所有诚实的尖头,生成到时间`(t),可以理解的选择t,通过maxvalid()规则.观察到任何诚实的尖头是可行的:通过定义,诚实的尖头的最终的顶点的深度超过所有优先的诚实的尖头.

**定义 4.25** (分歧) 让F成为对于字符串w 2 {0, 1}的分叉.对于两个可行F的尖头t1和 t2,定义他们的差异成为数量:

div(t1, t2) = min
i
(length(ti) − length(t1 \ t2)) ,

t1\t2表示t1\t2的普通的前缀.我们过载这个概念,通过定义差异,对于F,当最大的超过可行的尖头的所有的对:

div(F) = max
t1, t2 viable
tines of F

最后,定义w的差异为最大数,比如差异超过所有可能的分叉,对于w:

div(w) = max
F`w
div(F) .

观察到,如果div(t1, t2)  k,说length(t1)  length(t2),尖头tdk是t2的一个前缀.

我们首先建立了一个字符串带有大的差异,必须有一个大的可分叉的子字符串.我们然后应用这个,在下述定理4.27,去推断,典型的字符串从iSPoS升起,是不可能有大的差异,因此拥有普通的前缀性质.

**定理 4.26** 让w 2 {0, 1}然后又一个分叉的子字符串,w,带有| ˇ w|  div(w).

证明.考虑一个分叉F ` w金额一对可行的尖头(t1, t2),对于:

div(t1, t2) = div(w) .

为简单起见,我们假定尖头被归类,因此`(t1) < `(t2),进一步这样:

|`(t2) − `(t1)|是最小的,在尖头的所有对上,对于持有

我们通过确定子字符串w开始;证明的余下部分致力于建立一个平的分叉,对于ˇ,建立分叉可行性.让y表示最后的顶点,在尖头t1 \ t2上,正如在如下图标里,让 , `(y) = `(t1 \ t2).

用表示w的最小的诚实的指数，对于  `(t2),带有惯例，如果有这样的指数，我们定义 = n + 1.我们观察，无论如何，`(t1) < `(t2)，并且因此 − 1  `(t1). 这些指数，和 ,区分子字符串w = w+1 . . .w−1,，是证明的剩余部分的主题。当函数`(·)是严格的增加，随着任何时间，观察到

| ˇ w| =  −  − 1  `(t1) − `(y)  length(t1) − length(t1 \ t2)
 min(length(t1), length(t2)) − length(t1 \ t2) = div(w) ,

所以有预期的长度，它满足去建立，它是可分叉的

我们简略地概括这个证明，在展现细节之前。我们通过建立尖头t1 和 t2的若干结构的性质，由上述假设(11) 和(12)产生。去建立ˇ w是可分叉的，我们然后i从F从提取一个平的分叉（对于w），通过两步：(i.)分叉经受一些较小的重组去确保所有的“长”尖头通过y;(ii.)一个平的分叉是通过对待顶点y的方式创建，当以w的指数为标签的的F的子树的部分的根。在建造终了时，两个尖头t1 和 t2将产出需求的“长的，打散的”尖头，满足可分叉的定义。

我们观察，首先，顶点y不能时敌手的：否则容易创建一个替代的分叉F ` w和一对尖头在，完成更大的差异。特别地，创建˜，从F，通过增加一个新的（敌手的）顶点 ˜到F，对于`(˜y) = `(y),增加一个边缘到y，从顶点领先y,替代t1的边缘，遵循y,带有一个来自˜；然后分叉的其他的而相关性质会被保持，但是，作为结果的尖头的差异增加了1.（参照下述图表）

一个相似的论证意味着分叉F0 ` w1 . . .w通过包含仅仅F的尖头获得，带有标签，小于或等于 = `(y)，由一个独特的深度depth(y)的顶点（也就是y本身）。在另外带有深度depth(y),一个顶点y（F0的）在场的情况下，使t1改方向，通过˜（正如在上述论证中）会同样地导致一个带有更大差异的分叉。注意`(·)实际上增加，带有新的尖头（来自重新定向t1），因为`(˜y)  `(y)，根据F0的定义。当时字符串的最后的索引，这额外地意味着F0没有深度超过depth(y)的尖头。

我们注意到极小性假设(12)意味着任何诚实的指数h,对于h < 有深度，步超过min(length(t1), length(t2)):特别地，

h <  =) d(h)  min(length(t1), length(t2)) .

来看这个，考虑诚实的指数h < 和一个尖头th，对于`(th) = h.回想t1 和t2 是可行的；当h < `(t2)，它遵循立即地，d(h)  length(t2).类似的，如果h  `(t1)，那么d(h)  length(t1),所以它保持去解决这个情况，当`(t1) < h < `(t2):特别地，在这个管理体制，我们希望同样的确保d(h)  length(t1).为了否认的利益，假定length(th) = d(h) > length(t1).考虑尖头th,我们分别第调查两个情况，取决于是否th共享和t1一个边缘,在顶点y后。如果，实际上，th 和 t1贡献一个边缘，在顶点y后，然后th和 t2不分享这样的边缘，我们观察到div(th, t2)  div(t1, t2) while |`(t2) − h| < |`(t2) − `(t1)|，和（12）矛盾。如果，换句话说，th在y后和t1不共享任何边缘，我们类似地观察到div(t1, th)  div(t1, t2)，当|th − `(t1)| < |`(t2) − `(t1)|,和（12）矛盾

In light of the remarks above, we observe that the fork F may be “pinched” at y to yield an
essentially identical fork FByC ` w with the exception





