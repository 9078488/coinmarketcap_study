**Ouroboros: 一个可证明安全的POS区块链协议**

Aggelos Kiayias*  Alexander Russell†  Bernardo David‡  Roman Oliynykov§

2017年8月21日

**摘要**

我们提出“Ouroboros”，第一个基于POS的带有严格的安全保证的区块链协议。相比通过bitcoin区块链协议完成的，我们为协议建立了安全的性能。因为协议提供了POS区块链纪律。相比基于物理资源证明的区块链（e.g, POW）,它提供了质的效率优势。我们也提出了一个新奇的用于激励POS协议的奖励机制，并且我们证明，考虑到这个机制，诚实的行为是一个近似的纳什均衡，使得像利己主义的挖矿无效。我们也通过提供在交易确认和处理的实验结果，来提出我们协议在真实世界设置下的初始的证据。

**1. 介绍**

关于基于POW的区块链协议-比如Bitcoin-操作的主要的考虑是执行所需要的能量。在写作的时间里，在bitcoin区块链上生成单个区块需要超过260此的哈希操作，会导致侵袭能源需求。实际上，早期的流通现实协议的能量需求比得上一个小国家。

事情的状态激发人们研究可以通过用其他能源效率更高的另外一个方式替代他，来避免需要POW替代的区块链协议,机制也能提供相似的保证。很重要的是要之处bitcoin的POW机制促进了一种类型的随机“领导人选择”过程，选择其中一个矿工去发行下一个区块。而且，如果所有的矿工都遵循这个协议，这个选择是以和每个矿工算例称比例的随机方式执行的。（来自这个协议的误差可能成比例的扭曲，由“自私的挖矿”策略例证）

一个自然的替代机制依赖于PoS的概念。不是矿工投资矿工为了参与领导选择过程，而是他们运行一个过程，随机的选择他们中的一个，和股份成比例的，每个过程根据当前区块链账簿。

实际上，这产生了自指的区块链纪律：维护区块链依赖于利益相关者自己，基于账簿中所报告的每个过程的质量的数量来给他们安排工作（和奖励）。除了这个之外，这个纪律部需要对利益相关者进行进一步的“人造的”计算需求。在某种意义上，这个听上去很理想；但是意思到这样的PoS协议显得涉及到许多定义上的，技术的和分析的挑战。

**先前的工作** PoS概念在bitcoin论坛曾被广泛的讨论。基于PoS的区块链涉及层被Bentov et al更加正式的研究国，既在和PoW连接方面，也在作为区块链协议单独的机制。尽管Bentovet al.展示了针对一些种类的攻击他们的协议是有效的，他们没提供一个正式的依赖精确的定义的模型，用于分析基于PoS的协议或安全证明。对于许多加密货币，探索性的基于PoS的协议被提出（和实施）。基于探索性的安全论证，这些加密货币并频繁的发现从安全的观点上是有缺陷的。参照【4】作为一个各种攻击的讨论。

对于一个基于PoS的区块链协议与一个依赖固定权威这集合的经典的共识区块链也是很有意思的。区分基于PoS的区块链协议与那些假设静态的当局这的是抵押随着时间变化，因此信任假设随着系统进化。

另外一个PoW的替代是空间证明的概念，在区块链协议的背景下被特别的研究。在一个空间证明设置里，一个“证人”希望证明对空间的使用（存储/内存）；正如在PoW的情况，这个使用了物理资源，但是随着时间需要的能量少一些。一个相关的概念是空间-时间证明（PoST）。在所有的这些情况，但是一个昂贵的物理资源（存储或算力）是必要的

**PoS设计挑战** 对于基于PoS的区块链协议的基础的问题是去模拟领导选择过程。为了在利益相关者中达到一个公平的随机的选择，熵必须引入到系统力，引入熵的机制可能易于被对手操纵。例如，一个控制足足利益相关者的对手可能尝试模拟协议执行，尝试利益相关者参与者的不同的序列。这样找到一个有利于对手的利益相关者的协议附加部分。这会导致所谓的“无休止的”弱点，对手方可能用计算资源去倾斜领导者选择。

**我们的结果** 我们提出“Ouroboros”，一个可证明的安全的PoS系统。据我们所知，这是第一个有严格的安全分析的这种类型的区块链协议。更详细的，我们的结果如下。

第一，我们提供了一个模型，是的认识到基于PoS区块链协议的这个问题正式化。我们介绍的这个模型是本着 一个健壮的交易账簿的两个正式的性能，集中于持续和活跃性的精神。持续表述一旦系统的一个声明一个特定的交易为“稳定的”，剩下的节点，如果诚实的询问和回应，也会将起报告为“稳定的”。此时，稳定性被理解为一个谓语，由一些安全参数k表示，将影响确定性，那个性质保持。（例如，超过k阻止深处）。活跃性确保，一旦真诚的生成的交易可以实现为一个充足的时间足够的数量到网络节点，比如u时间步数，将会是稳定的。活跃性和持续性的结合提供了一个健壮的账簿，从某种意义上说，生成的交易被采用，并且变得不可变的。我们的模型适宜的被修改去促进基于PoS的动力学。

第二，我们描述了一个基于PoS的新奇的区块链协议。我们的协议假定当事人可以自由的创建账户和接受和支付，那个质押随着时间转换。我们使用一个（非常简单的）安全的掷硬币协议的的多党实施去生成领导选择过程的随机性。区分我们的方式（和阻止所谓的“无休止攻击”）和其他之前的解决方式是价值确定的基于区块链的当前状态或使用共同的掷硬币作为引入熵的方式。并且，对我们的方式是独特的是系统忽略循环到循环的质押修改。反而，会定时利益相关者的当前集合进行定期快照，间隔被称作"epochs";在每个这样的间隔里，会进行一个而安全的多党的计算，使用区块链本身作为广播渠道。特别地，在每个时间点上，一组从委员会随机选择出来的利益相关者，然后负责执行掷硬币协议。协议的结果决定在一个时间点执行协议的下一组利益相关者，和所有领导选择的结果一样，用于时间点。

第三，我们提供一组正式的自变数，确立没有对手方可以打破持续和活跃性。在一些看似可信的假设下，我们的协议是安全的:(1)网络是同步的，从某种意义上来说，一个上限可以被决定，在任何诚实的利益相关者可以和任何其他利益相关者沟通，(2)一些从诚实的多数中提取的一些利益相关者是可能的，当需要参与每个间隔时,(3)利益相关者不会长时段的保持离线，（4）腐败自适应从属于一个小的延迟，在轮线性衡量，在安全的参数（或替代的，选手可以访问一个发送者匿名的广播渠道）。在我们安全参数的核心是该类型的参数，根据一个组合的概念“可分叉的线”，我们规划，证明，并且也用实验方法验证。在我们的分析里，我们也区分转换共i，一种一般分叉攻击的特别种类。这里的“转换性”本着转换跌收，针对安全多党的计算协议的精神，敌方像打破这个协议，但是更喜欢不被抓到做这个。我们展示秘密地分叉串是带有更小密度的分叉串的子类；这允许我们提供两个由区别的安全参数，完成不同的折中，依照效率和安全保障。我们分叉的串分析是一个自然的，相当的普遍的工具，可以被作为PoS设置的安全参数的一部分应用。

第四，我们把我们的注意力转移到协议的激励结构。我们展示一个新的奖励机制，用于激励这个系统的参与这，我们证明起（近似于）纳什均衡。在这个方式，攻击像区块阻挡和自私挖矿会被我们的设计减轻。奖励机制背后的核心理念是去提供积极的报酬给协议行动，不能被从协议中分叉的参与方的联合扼杀。在这个方式下，可能展示这个，在貌似可信的假设下，也记忆是一定的协议执行诚实是小的，忠诚的遵循协议是一个均衡，当所有的选手是理性的。

第五，我们引入了质押委托机制，可以无缝的加入到我们区块链协议。委托是非常有用的，在我们的内容中，当我们允许协议去扩展，甚至在一种设置里，一组利益相关者是高度分裂的。在这样的情况下，委托机制使得利益相关者去委托他们的“投票权”，例如，在每个时间点参与运行领导选择协议委员会的权利。在流动性民主，（亦称，委托的民主），利益相关者由能力撤回委托任命，当他们想相互独立。

考虑到我们模型和协议描述，我们也探索可在实际中多种多样的攻击，在我们的框架内被解决。特别的，我们讨论了双花攻击，交易拒绝攻击，51%攻击，没有质押，去同步化攻击和其他。最后，我们展示了冠以我们涉及的效率的证据。第一我们考虑双花攻击。为了说明目的，我们和中本聪关于bitcoin的分析进行了一个对比，关于带有确认99.9%的交易确认时间。反对转换敌手，交易确认时间比bitcoin快10到16倍，依赖于敌对的哈希算例；对于一般的敌手确认时间，有5到10倍快。而且，我们对于双花攻击的具体分析依赖于我们的分叉和密密地分叉串的组合，并且应用到一个更加广阔敌对行为的种类，相比中本聪的更加简化的分析。我们然后调查了我们的原型实施和在Amazon云计算上进行的基准测试的报告，可以展示我们的PoS区块链协议的力量 ，依照性能。

**相关工作** 与开发我们的Ouroboros同步，一些其他协议也真被开发，用来针对多种位置，在基于PoS的分布式账簿的设计空间里。睡眠的共识认为一个固定的利益相关者分布（例如，质押不会随着时间进化），目标为一个“混合的”腐败设置，敌手被允许去适应和执行失败终止，除了拜占庭错误恢复腐败。这个实际上简单的扩展到偶们在混合的腐败设置里的分析，cf.备注2；然而，结果的安全可以被争论，仅仅在“带延迟的腐败”的设置，因此不是完全的可适应的。雪白提出了一个进化的利益相关者分布，并且采用了我们争论安全类似的腐败延迟机制。然而，与我们协议相反，雪白设计已受“无休止的”类型的攻击影响，可以偏向对敌对方有利的高可能性事件。当这个不是渐近地上海安全，它阻止了一个具体的参数化，不会考虑敌对的算例。Algorand提供了一个遵循拜占庭协议的分布式账簿，每个区块的方式，抵挡住适应的腐败。考虑到协议需要到达每个区块，这样的协议会以一个实质上比PoS区块链慢的速率生产区块。（慢下来和拜占庭同意协议的执行的期望长度），但是他们可以自由的分叉。在这方面，尽快存在分叉，区块链协议展示了允许客户去设置他们愿意承受的风险等级的灵活性，允许低风险侧面客户享受更快的处理事件，从乐观的角度。最后，Fruitchain提供了一个奖励机制和一个近似的纳什均衡证明，对于基于PoW的区块链。我们在区块链层面用了一个类似的奖励机制，虽然我们基础的结构是不同的，因为需要在PoS设置下操作。这个思想的核心是提供一个“背书”输入的POS类似，在一个公平的比例，适用相同的逻辑正如基于PoW的拜占庭同意协议，用于诚实的大多数所来的。

**白皮书综述** 我们在Sec. 2展示基本的模型。为了简化我们协议的分以，我们在我们的四个阶段展示它，被在Sec. 3中概述。总之，在Sec. 4,我们描述和分析了协议，在静态设置；我们然后再Sec. 5中过渡到动态设置。我们的激励机制和均衡参数再Sec. 7中展示。我们然后在Sec. 6中展示带有匿名渠道的协议增加，在Sec. 8中带有一个委托机制。随后，在Sec. 9中，我们讨论了在各种各样特别的利益攻击下的，在协议的恢复力。在Sec. 10,我们讨论国盾确认次数，和一般的执行结果，从在Amazon云上运行的原型实施的结果。

**2. 模型**

**时间，位置和同步** 我们考虑一个设置，时间被划分为被称作位置的不连续的单元。一个账簿，如下进行更详细的描述，一个账簿区块和每个时间位置有管（至多）。选手被装备（大概同步的）时钟，展示当前的位置。这讲允许他们实施一个分布式协议，目的是共同的布置一个区块到当前位置。总之，每个位置slr由整数r 2 {1, 2, . . .}做索引，我们假设对应每个位置的实时窗口有如下性质。

- 当前位置是有公开已知的，单调的当前时间增加函数决定的
- 每个选手可以访问当前时间。当事人本地时间之间的相差，相比由slot代表的时间长度是无关紧要的。
- 对应一个位置的时间窗口长度是足够去保证人后在时间窗口开始的时候由诚实参与者传送的信息将会在时间窗口结束时，由任何其他诚实的参与方收到（甚至对在参与方的当地时钟中的小的不一致负责）。特别，当网络延迟发生，他们从来不会超过位置的时间窗口。

**交易账簿性质** 一个协议实施了一个健壮的交易账簿，如果2维持的账簿被划分为“区块”（分配给时间位置），决定交易被包含到账簿里的顺序。它应该满足如下两个性质。

**持续** 一旦系统的一个节点宣告一个特定的交易tx作为稳定的，剩下的节点，如果查询，会在账簿的相同位置报告tx,或不会把任何和tx冲突的交易报告未稳定的，这里稳定性的概念是一个谓语，用安全参数k作为参数来表示；特别地，一个交易被声明未稳定，如果并且仅仅，如果在一个区块里，在账簿里超过k区块深。

**活跃性** 如果在系统中的所有的诚实的节点尝试去包含一个特定的交易，那么在对应u位置的时间过去后（被称为交易确认时间），所有的节点，如果诚实地查询和回复，将会将交易报告为稳定的

在[26， 35]，它被展示：持续和活跃性可以来源于如下三个基本的性质，如果协议2来源于账簿，从一个区块链形式的数据结构。

- **一般的前缀（CP）;带参数** k 2 N.链由两个诚实的参与人控制，在位置sl1 < sl2的开始，是Cdk
  1  C2,Cdk表示这个链，通过从C1移除最后的k区块获得，并且表示前缀关系。

- **链质量（CQ）;带参数** μ 2 (0, 1] 和 ` 2 N。考虑长度的任何部分，至少链的 ，由诚实的参与方控制，在循环的开始；由敌对方引起的区块比例至多是1−μ.我们称μ为链质量系数。
- **链增长（CG）;带参数**  2 (0, 1], s 2 N.考虑链C1, C2，由两个诚实的参与方控制，在两个位置sl1, sl2的开始，带有sl2,至少在sl1前面。然后它持有len(C2) − len(C1)   · s. 我们称为速度系数

一些注意在这些地方。关于一般前缀，我们多的一个一般前缀的强概念。cf. [26].关于链质量，μ,作为敌对方的比例的函数，满足μ()  ，对于利益协议。在一个理想的设置里，μ会是1−；在这个情况下，恶意区块的比例，在任何足够长的的链部分，和一组（恶意的）利益相关者的累积的质押是成比例的。

值得注意对于bitcoin,我们由μ() = (1 − 2)/(1 − ),这个限制事实上是紧的，参照[24]，争论链质量的保证。同样的会保持正确，对于协议建设。正如我们展示，这将足够，对于我们用于合适地工作的激励机制。

最后，链增长涉及到链增长的速度（对于诚实的节点）。在bitcoin的情况下，最长的链在我们协议里扮演优先的作用；这提供链增长的一个简单的保证。

**安全模型** 我们采用由[24]引入的模型，用于分析区块链协议的安全性，由理想的功能f增强。我们通过VIEWP,F
,A,Z()表示P参与方的观点，在协议2执行后，带有敌对方A，环境Z，安全参数和访问理想的功能f。类似的，我们用EXECP,F
,A,Z()表示Z的输出。

我们注意到多个不同的“功能会被f完成。与[24]相反，我们的分析是在“标准模型里”，不带由一个而随机的预言机功能，我们在理想的功能里包含的第一个界面，在协议里适用的是“传播”和“关键的和交易”功能，以FD+KT命名，会在下面描述。注意传播的功能也是机制，通过我们将获得协议的同步性。

**传播功能** 传播功能包制一个进来的字符串，对于参与的每个参与方Ui。一个参与方，如果激活，是被在任何时刻允许去取得他们进入的字符串；可能会把这个想象称一个信箱。此外，参与方会知道功能去传播一个小小，在一种情况，信息会被添加到每个参与方的进入的字符串。这个功能保持循环（地点），并且所有参与方在一个循环里传播一次。循环不前进，除非所有参与方已经传播了一个消息。敌对方，当激活后，可能也和这个功能互动，它被允许去阅读所有收件箱，和所有的传播要求，并且以它喜欢的任何顺序投递信息到收件箱里。在循环结束后，这个功能会确保包含素偶又信息的收件箱被出阿伯（但是不是必要，以相同的顺序，他们被要求被传播的）。当前的地点参数可能在任何时间由任何参与方要求。如果一个利益相关方没有取得一个特定的地点，这个信息写入到他的进入的字符串，他们会被暴露。

**关键的和交易功能** 关键登记功能是带有n个用户，U1, . . . ,Un进行初始化，和他们各自的质押s1,...,sn;考虑到这样的初始化，函数会和敌方商议，会接受一个（可能空的）（腐败的，U）信息的序列，并且标记对应的用户U作为腐败。对于在函数里登记的不带有公钥的腐败的用户，将允许敌方去设置他呢的公钥，当对于诚实的用户，这个函数会抽样取样公/私钥对，并且基于数字前面算法记录他们。腐败用户的公钥会被标记称这样。随后，如下行动的任何序列可能会发生：（i）一个用户可能要求减少它的公钥和私钥，因此这个函数会将其返回给用户。(ii)公钥的全部的目录会被要求，因此这个函数会将其返回给请求的用户。(iii)一个新用户可能被要求被创立，通过一个来自环境的消息（Create,U,C）,函数将遵循如之前的相同的步骤：它将会和敌对方商量，关于U的腐败状态，并且会设置其公开，可能私钥依赖于腐败状态；此外，它将会储存C，作为建议的初始状态。函数会根据交互作用的成功完成返回公钥到环境里。(iv)一个现行的用户可能被要求去被腐败，通过敌对方，通过一个消息（Corrupt,U）。一个用户能仅被腐化，在D位置的延迟后；特别的，一个腐败请求是登记的私钥，会被释放，在D位置已经通过，根据循环计数器，在函数出阿伯的部件重维持。

考虑到上述，我们会假设协议的执行是关于函数F，吸收了上述两个函数，和可能的额外的函数，在如下被解释的。注意一个腐败的利益相关者U会让渡它所有的状态到A；从现在开始，敌方会被激活，代替利益相关者U。超出F利用的任何限制，敌方仅仅能腐败一个利益相关者，如果是通过环境Z运行协议执行的给定的许可。许可时以消息的形式（Corrupt, U）,会通过环境被提供给敌方。总之，关于激活，我们有如下。

- 在美俄个位置Slj，环境Z被运去去精活利益相关者期望的任何子集。他们中的 每个人可能生成信息，可以被传送给其他利益相关者
- 敌方至少被激活，作为最后实体，在每个slj，（和在所有敌对方激活一样）

很容易看到以上模型在敌方上授予这样的规模打大的权利，一个能不能在利益协议上建立任何重大的保证。隐私去限制环境的适宜的（考虑协议的详情），因此我们个能争论安全性。没有元年，我们在环境上世家的限制如下：

**施加到环境的限制** 环境，负责在每一个循环激活诚实的节点，将从属于如下约束，关于运行协议的诚实节点的激活

- 在每个位置，会至少有一个诚实的激活的参与方
- 将有一个参数k 2 Z，将会表示位置的最大数，一个诚实的利益相关者会离线。假使一个诚实的利益相关者被生成，在协议的开始，通过由环境提供的它的初始化的链C，应该匹配一个诚实的参与方的链，在之前的位置是活跃的。
- 在每一个位置Slr.对于每个活跃的利益相关者Uj，会是一组公钥和形式(vki, si) 2 {0, 1} × N, for j = 1, . . . , nr的质押对，nr是这个引入的用户数，到那个位置，会代表谁是活跃的参与这，按照Uj的观点。公钥会被标记为“腐败的”，如果对于的利益相关者被腐败的。我们会说敌方会被限制小于50%的相关质押，如果它包制由总计的质押划分的腐败钥匙的总的质押小于在所有的可能的Sj(r)的50%。假使上述被事件Bad1/2违背的，对于给定的执行成为正确的。

我们注意到上述陈述的离线的限制是非常保守的，我们的协议可以容忍更长的离线事件，取决于窒息感步骤的过程的方式；然而，对于简易质押，我们使用上述限制。最终，我们注意到在我们的证明里，无论何时，我们说一个性质Q保持在所有执行上高的可能性。这捕获了这个事实，我们排除环境和敌方，触发带有不可忽视的可能性的Bad1/2。

**3. 我们的协议： 综述**

我们首先提供一个我们协议设计方式的大概的综述。这个协议的特性取决于一些如下参数：(i) k是区块数，应该由在其之上，为了成为账簿的不可变的历史的一部分，(ii)是优势，依照诚实的利益相关者的质押，针对敌对方(iii)D是腐败延迟，在敌对方上施加，例如，一个诚实的利益相关者将会被腐败，在D位置后，当一个腐败信心在执行期间由敌方传递；(iv)L是系统的寿命，在位置里衡量；（v）R是事件点的长度，在位置中衡量。

我们展示我们的协议描述，在相继的四阶段，提供它所能抵挡的敌方的模型。在所有的阶段里，一个“理想的功能”，对于参与者是可行的。函数捕获了资源，在所有参与方中作为前提存在，用对协议的安全的操作（例如，创世块会由指定）

**阶段 1：静态质押** D= L。在第一阶段，信任假设是静态的，并带有利用相关者初始集保持。由一个初始的质押分布， 会被硬编码进创世块，包含利益相关者{(vki, si)}ni
=1.的公钥。基于我们对环境的限制，带有优点的诚实的大多数假定在这些初始的利益相关者中。特别的，环境初始地会允许一些利益相关者的腐败，它的相关质押表示1−用于一些 > 0.环境允许通过提供形式（Corrupt, U)的tokens到敌对方去允许参与方腐败；注意由于在第一阶段事实的腐败延迟，任何进一步的腐败会反对参与方，最初没有质押，因此腐败模型和“静态腐败类似的”。FD,F将随后取样p,会播种一个“由质押重量”的利益相关者取样，在这个放肆导致m keys vki1 , . . . , vkim的子集的选择，到形成一个委员会，会控制待在m带有压倒性可能性的诚实的大多数，（这用了事实，由恶意参与方控制的相关质押是1−
2），m到的现行依赖会被施加在这个阶段）。更详细的，委员会将会被含蓄的选择，通过指定利益相关者，带有可能性，和它的质押成比例，对L位置的每个人。随后，利益相关者讲法发行区块，遵循这个计划表，由slot作业决定。最长链规则会被应用，对于敌对方是可能去分叉区块链视角，诚实方。然而，我们将证明，带有一个Markov链论证，可能性，一个分叉可能被维持，在一个n位置的序列，以指数方式降低，至少p
n, cf.定理4.12针对一般敌对者。一个更加喜欢的反省可以针对转变敌对方所做的。例子，更喜欢保持“在雷达下的”定理4.23.

**阶段2： 动态的状态，带有一个灯塔，R位置的时间点期间，**D = R  L. 以上协议的寿命的扩展的中心思想是去考虑他的若干调用的相继的构成，我们详述一个做这个方法，在这样的假设下，一个可信任的灯塔定期发出一个一致的随机字符串。更具体的说，这个灯塔，在位置{j ·R+1, . . . , (j+1)R},现实j-th随机字符喜欢，播种领导选择函数。和静态状态协议相比的决定性的不同是质押分布被允许去该白，是从区块链自身得到的。这意味着一个特定的位置sl,属于j-th时间点（带j  2），被使用的质押分布是在最近区块链里报告的，带有小于j · R − 2k.的时间戳。

关于进化的质押分布，交易会被持续的生成和传送，通过环境在利益相关者之间，选手会包含被同胞的交易在基于他们维护的账簿的区块链。为了适应被创建的新的账户，函数使得一个新的(vk, sk)即期被创建，并安排给一个新的参与方Ui.特别的，环境会创建一个新的参与方，会和相互作用，为了他们的公/私钥，在一个方式，将其作为一个可信任的部件去对待，维护他们钱包的秘密。注意，敌对方可以妨碍一个新的参与方的创建，腐败他，提供他自己的（敌对创建的）公钥替代。如以前，环境，可能要求在来自利益相关者的，账户之间的交易，他能生成交易，和敌方勾结。为了腐败的账户。回忆：我们的假设是，在任何位置，按照诚实的选手的观点，利益相关者分布满足诚实的大多数，带有优点（注意不同的诚实的选手可能理解一个不同的利益相关者分布，在一个特定的位置）。而且，质押能够转换，通过至多统计距离，通过特定数量的位置。这里被衡量的统计距离考虑基础的分布，作为更具质押获得权重的采样器，以及他瑞华随着规定的时间间隔改变。安全证明可以被看做一个感应现象，在时间点L/R的数量，带有基础情况，由静态的质押协议的证明提供。最后，我们会讨论在这个设置里，一个限制，在敌对的之压力，对安全是最后的，一个单个的抽签（观察委员会的尺寸，m,现在应该被选择去克服，也一个累计的属于，尺寸ln(L/R)，考虑到系统的寿命，包含这样一个连续点的时间）。腐败延迟保持在D = R，可以被选择任意小于L的，因此使得敌对方去执行适应的腐败，只要这不是即时的。

**阶段3 动态的状态，不带有灯塔，R位置的时间点阶段R = (k)和延迟D 2 (R, 2R)  L.**在第三个阶段，我们移除了对于灯塔的从属，通过引入一个安全的多方协议，带有一个“保证的输出传递”，模拟他。在这个方式，我们可以获得长活跃性，如阶段2描述的设计，不仅仅在阶段1设计的假设下，例如，这仅有的一个初始化随机字符串的可能性，和一个带有诚实大多数的初始化利益相关者分布。核心思想如下：考虑到我们保证，在选择的利益相关者中诚实的大多数将保持非常高的可能性，我们能进一步的使用选择的设置作为参与者，到一个安全的多方的计算协议的实例。这将要求时间点的长度的选择会是充足的，所以可以容纳MPC协议的运行。从安全的角度来看，和前面的情况主要的不同是，灯塔的输出会被敌对方知道，在被诚实参与方知道之前。然后，我们会证明诚实参与方也会不可避免的知道它，在较少的位置后。为了对这个事实进行解释，敌方抢先了（可能由执行适合的腐败开发），我们增加等待时间，用于腐败，从R到一个合适的值在(R, 2R)，否定这个优点，依赖安全的MPC设计。从加密设计角度看，这个节点的特点是，账簿本身的使用，对于一个可靠的传播的模拟 ，支持MPC协议。

**阶段4 输入背书人，利益相关者委托，匿名通信** 在我们设计的第一个阶段，我们增加了这个协议，带有两个新的任务，为实体，运行协议和考虑匿名通信的好处。输入背书人创建了一个交易的第二层，先于区块包含背书。这个机制使得这个协议可以抵挡误差，比如利己的挖矿，和使得我可以去展示诚实的行为是一个近似的纳什均衡，在合理的假设下，关于运行协议的成本。注意输入背书者被分配给位置，以相同的方法，一些位置领导是，并且被包含在区块里的输入仅仅可接受，如果他们由一个合格的输入背书者背书。第二，授权特点允许利益相关者去转移委员会参与给被选择的委托，假定在运行协议里的利益相关者的责任（包括参与到MPC和区块的发布）。委托自然的引起“质押池”，能够以相同的方式行动，正如bitcoin中的矿池。最后，我们我们观察到，通过包含一个匿名通信的层，我们可以移除腐败延迟要求，在我们分析中被利用的。这个以对于诚实参与方增加在线时间要求为代价。

**4 我们的协议：静态状态**

**4.1 基本的概念和协议描述**

我们通过在“静态质押”设置里描述区块链协议开始，领导会被分给给区块链位置，带有可能性，和他们（固定的）初始的质押成比例，是有效的质押分布，通过执行。为了简化我们的描述，我们抽象化领导选择处理，将其简单的对待为一个“理想的功能”，如实的执行随机分配利益相关者给位置的过程。在如下的章节，我们解释如何距离说明这个功能，带有特定的安全计算。

我们注意到，甚至带有一个而理想的领导分配过程--分析标准“最长链”优先权规则，在我们的PoS的设定中，变得需要重要的新注意。产生这个挑战是因为许多位置（时间点，如上所述）被立刻分配给利益相关者；当这个有有利的性质，从一个效率（和激励）角度，它给敌对方提供了一个新奇的攻击方式。特别地，一个控制特定利益相关者人口的敌对方能够，在一个时间点的开始，选择，当标准“链更新”广播消息被传递给诚实的节点，带有未来位置分配的全部知识，到利益相关者。与之相反，在典型的POW中设置中敌对方被限制去做这样的决定，在一个在线的方式。我们注意到这个有一个引人注目的效果，在敌对方生成敌对链的能力上；参在如下“分叉字符串的”讨论，用于详细的讨论。

在静态质押的情况，我们假定固定的n利益相关者u1...un的集合通过协议相互作用。利益相关者Ui用用si质押，在协议开始之前。对于每个利益相关者Ui,一个认证和签署钥对（vki, ski）对于一个规定的签名组合被生成；我们假设不损失普遍性的情况下，验证钥vk1..被所以的利益相关者知道。在描述这个协议，我们建议里基本的定义，遵循如下的概念。

**定义 4.1** (创世区块)。创世区块B0包含有他们公钥识别的利益相关者的李彪，他们分别质押（vk1,s1）....(Vkn,sn)和辅助的信息p

具有仙剑，我们注意的辅助信息P将被用作播种位置领导选择过程。

**定义 4.2**(状态)。 一个状态是一个字符串2 {0, 1}.

**定义4.3** (区块)。 一个区块在位置生成，包含当前状态，数据，位置数sli和一个前面，在SKI下计算的，对应利益相关者Ui生成区块。

**定义 4.4** （区块链）区块链（或简单地链）涉及创世块B0是一个区块B1，...Bn的序列 ，与一个严格的块的增长序列有关系，对于他和Bi的状态等于H(Bi-1),H是一个规定的康冲突的哈希函数。一个链的len(C)=n的长度是它的区块数。区块Bn是链的头，表示为head(C)。我们将空字符串看做一个合法的链，通过约定设置head=

让C成为一个长度为N的链，k是任何非负整数。我们用Ck表示链，起因于C的最右面的区块移除。如果k大于等于len(C),我们定义Ck=.我们让C1  C2表示链C1是链C2的前缀。

**定义 4.5** （时间点）。时间点是R邻近的位置S={Sl1,...SLR}的集合

（值R是协议的参数，我们在这一章节分析的）

**定义 4.6** （敌对的质押比例）。让Ua成为由敌对方控制的利益相关者的集合。那么敌对质押比例被质押为：



n是利益相关者的综述，si是利益相关者Ui的质押

**位置领导者选择** 在这一章里描述的协议中，对于每个0<j<r,一个位置领导者Ej被决定，谁由这个（唯一的）权利去在slj处生成一个区块。特别地，对于每个位置，一个利益相关者被选择为位置领导者，带有可能性pi，和他们在创世块B0中登记的它的质押成比例；这个分配在位置间是独立的。在这个静态的质押情况，创世块也成为过程，选择领导者，由理想的函数决定，在图标1中定义。这个函数由用参数表示，分配给每个利益相关者它的分别的质押，一个分布D，提供辅助的信息p和一个领导选择函数F，如下定义：

**定义 4.7** (领导者选择处理)。一个领导者选择处理，关于利益相关者分布 是一个对，由分布和确定性函数组成，比如，当p d,它保持，对于所有，输出，带有可能性。

si是由利益相关者Ui持有的质押（我们称之为根据质押的权重）；此外，随机参数的家族是独立的。

我们注意到和质押成比例取样可以被实施，以一个简单的方式。例如，一个间的处理操作如下。让。对于每个，如果没有利益相关者被选择，这个处理掷p倾向的币；如果币的结果是1，参与方Ui被选择为这个位置，这个处理被完成。（注意pn=1,所以这个过程被确定去完成，带有一个独立的梯子）。当我们实施这个过程，作为函数F.足够的随机性必须被分配去模拟有偏见的掷硬币。如果我们实施上述，带有精度，对于每个独立的掷硬币，然后选择一个利益相关者会要求随机字节，总计。注意使用一个伪随机数生成器（PRG），一个人可能用较短的“种子”字符串，然后拉伸它，使用PRG到合适的长度。
**功能**

[模式] 包含传播和私钥/交易函数，来自章节2，由公钥和最初利益相关者的分别的质押的参数确定，分布D和函数F，因此（D,F）是一个领导者选择过程。另外，是被mode的参数确定的，决定签名验证钥是如何生成的。当[模式]实例化，带有mode=SIG(resp. mode=FDSIG),被表示为（）。和利益相关者交互作用，如下：

- **签名钥对生成：** 生成签名的和验证的钥ski,vki,对于利益相关者Ui,通过执行。生成，通过查询，带有，代表Ui（带有一个唯一的会议标识符sidi,和Ui相关联），设置（ski = sidi, vki=vi）(从Fdsig接受作为回复)，对于i=1,....n.设置。

- **创世块生成**  再接受（ ），从利益相关者，如下开始。如果p还没有被设置，抽样 pd.无论如何，发送给Ui
- **签名和验证** 提供通向Fdisg界面的访问

**在模型的协议** 我们通过描述一个基于区块链协议的简单的PoS开始，考虑静态的质押，在混合的模型，例如，当创世块B0（和因此位置的领导者）被决定，由理想的函数。提供利益相关者，带有创始块，包括一个质押分布，由签名验证私钥为索引，由EUF-CMA签名组合生成，当从签名的理想函数中获得这样的钥。微妙的不同开始起作用，当描述一个理想的版本，在过渡的混合自变数使用的，安全的证明，会在章节4.2中讨论。利益相关者U1，....UM在他们自己中互相作用，带有，通过协议，在图标2中描述的。

这个协议依赖于maxvalidS(C,C)函数，选择一个链，考虑到当前的链C，和一组有效链C的，在网络中存在。在静态的情况下，简单的“最长链”规则（在动态的情况下，这个由一个普通的链长度确定参数；参照章节5）

函数maxvalid(C,C):返回最长链，从。结被打破，由利于C，如果有最大的长度，或武断地，否则。

**协议**

是一个由利益相关者U1,....Un运行的协议,和相互影响，在一系列的位置S={}处理如下：

1. **初始化** 利益相关者Ui 2 {U1, . . . ,Un，从密钥登记界面接受，它的公司钥。然后它收到当前的位置，从广播界面，假释它是SL1,它发送，到，收到作为答案。Ui设置本地区块链C = B0 = (S0, )，并且最初的内部状态。否则，它从密钥登记界面收到最初的链C，设置本地区块链到C和最初的内部状态st = H(head(C)).
2. **链扩展** 对于每个位置slj 2 S,每个利益相关者Ui执行如下步骤

(a) 收集所有的有效链，通过广播到集合C收到的，验证，对于每个链和每个链，它包制，当vk时利益相关者的验证密钥，计算=，作为新的本地链，设置状态。

(b) 如果Ui时位置领导者，由F决定的，它生成一个新的区块B=，st时它的当前状态，d时交易数据，是一个在。。商店额签名，Ui计算，广播C,设置C，作为新的本地链，设置状态。

3. **交易生成** 考虑到交易模板tx, Ui返回，如果tx按照Ui的观点和账簿的状态一致。

**4.2 理想协议的安全分析**

作为SPoS的安全分析的第一步，我们将引入一个理想化的协议iSPoS，并展示一个过渡的混合的自变数，展示从计算方面讲，和SPoS不能区分的

代替依赖FD,FLS [SIG]和一个EUF-CMA签名组合，iSPoS带有一个理想的签名组合操作。为了那个目的，iSPoS和FD,FLS [FDSIG]相互作用，为了获得签名和验证密钥，用于在协议中采用的签名的理想组合。在下面的学期中，我们会证明iSPoS是安全的，通过一系列组合的论证。我们首先展示这个混合的原因是，我们打算隔离这些组合的参数，从特定的细节，基础的签名组合，被用来举例证明SPoS和偏差，这些组合可能在SPoS的分布中结束，集中，替代理想的执行，几秒组合被完美的意识到，影响我们协议的真实属性。

**功能 Fdsig**

FDSIG按如下方式和利益相关者交互作用：

**密钥生成**  在收到来自利益相关者Ui的信息(KeyGen, sid)，为一些sid验证sid =(Ui, sid0)。如果不是，忽略这个要求。另外，将(KeyGen, sid)交给敌对放。在从敌对放收到(VerificationKey, sid, v)，输出(VerificationKey, sid, v)到Ui,记录对(Ui, v).

**签名生成** 从Ui处收到一个消息(Sign, sid,m)，为一些sid0验证sid =(Ui, sid0)。如果不是，那么忽略要求。另外，发送(Sign, sid,m)给敌对放，在收到从敌对方收到(Signature, sid, m, )，验证没有条目(m, , v, 0)被记录。如果是，那么输出一个错误的信息给Ui,并且停止。此外，输出(Signature, sid, m, )给Ui,并且记录条目(m, , v, 0).

**签名验证** 在从利益相关者Ui收到一个信息(Verify, sid, m, , v0)，把(Verify, sid, m, , v0)交给敌对方。在从敌对方处收到(Verified, sid, m, )：

1. 如果v0 = v，并且条目(m, , v, 1)被记录，那么设置f = 1.（这个条件确保完整：如果验证密钥v0是登记的那个，是为m合理的生成的签名，那么验证成功）
2. 另外，如果v0 = v,签名者没有被夫八百，并且没有对于任何0的条目(m, 0, v, 1)被记录，那么设置f = 0，并且记录条目(m, , v, 0).（这个条件确保不可伪造性：如果v0是登记的那个，签名者不会被腐败，并且从不会签署m,那么验证失败）
3. 另外，如果有一个条目(m, , v0, f0)被记录，那么让f = f0.（这个条件确保一致性：所有的验证要求，带有完全相同的参数会导致相同的答案）
4. 另外，让f = ，并且记录条目(m, , v0, ).

输出(Verified, sid, m, f)给Ui.

第一，在图形3，我们展示了函数Fdsig,在【14】中被定义的，也被展示位EUF-CMA签名组合认识到Fdsig.注意这个事实会被用做去展示我们理想的协议可以实际的被认识到，基于实际的数字签名组合，比如DSA和 ECDSA），最后，iSPoS和SPoS.是不能区分。

理想的协议iSPoS被利益相关者运行，和FD,FLS [FDSIG] 与FDSIG相互作用。基本上，iSPoS作为SPoS来运转，除了条用Vrfvk() 和 Signsk(m).也就是说，不是本地计算Signski(m)，Ui发送(Sign, sid,m)给FDSIG,收到(Signature, sid, m, )并且输出作为签名。此外，不是本地计算Vrfvk0(,m)，Ui发送(Verify, sidi, m, , v0)给FDSIG（v0对应验证密钥vk0），输出在消息(Verified, sidi, m, f)中收到的值。协议iSPoS在图形4中被描述。理想的描述会被进一步的开发，当讨论动态的质押情况，额外的建立的区块必须在理想的协议里被考虑。

如下的名命题是一个结果的立即的推论，在展示,EUF-CMA签名组合意识到FDSIG

**命题 4.8** 对每个PPT A,Z它保持，那儿有一个PPT S，因此EXECP,FD,FLS [SIG]SPoS,A,Z ()和EXECP,FD,FLS [FDSIG]iSPoS,S,Z ()从计算方面讲是不能区分的

鉴于上述命题，在剩下的分析里我们会集中于这些协议iSPoS的性质。（注意这个含义不会适用于任何性质，一个人可能在为iSPoS执行考虑；然而我们讲为iSPoS证明的性质都由环境z可证实的,作为结果，他们可以被SPoS集成，由于命题）

**协议**

iSPoS是由利益相关者U1, . . . ,Un运行的而协议，和FD,FLS [FDSIG]相互作用，在一系列位置上，处理如下：

1. **初始化** 利益相关者Ui 2 {U1, . . . ,Un},从密钥登记接口处收到它的公钥和私钥。然后它从散开的接口收到当前的位置，假使它是本地sl1,它发送(genblock req,Ui)到FD,FLS [FDSIG],收到(genblock, S0, , F)作为答案。Ui设置本地去快快C = B0 = (S0, )，并且初始的内部的状态st=H(B0).另外，它从密钥登记接口收到初始的链C，设置本地区块链C和初始的内部状态st = H(head(C)).
2. **链拓展** 对于每个位置slj 2 S,每个利益相关者Ui执行如下步骤：

(a) 收集所有有效的链，通过广播到一个集合C接受，验证：对于每个链C0 2 C和每个区块B0 = (st0, d0, sl0, 0) 2 C0，它保持FDSIG答复，带有(Verified, sid, (st0, d0, sl0), 1)，在被带有(Verify, sid, (st0, d0, sl0), 0, vk0),查询，vk0是利益相关者U0 = F(S0, , sl0).的验证私钥。Ui计算C0 = maxvalid(C,C),设置C0作为新的本地链，设置状态st = H(head(C0)).

(b) 如果Ui是由F(S0, , slj )决定的位置领导者，它生成了一个新的区块B = (st, d, slj , )，st是当前的状态，d 2 {0, 1}是加偶i数据，是从FDSIG’s的答复(Signature, sid, (st, d, slj), )得到的，在被带有(Sign, sidi, (st, d, slj )).查询

3. **交易生成** 考虑到一个交易模板tx，Ui返回，从FDSIG’s答复(Signature, sidi, tx, )获得，在被带有(Sign, sidi, tx)查询，如果tx是和账簿的状态是一致的，按照Ui的观点。

**4.3 可分叉的字符串**

在我们的安全参数里，我们例行公事地用{0, 1}n的元素去表面哪个位置，在一个特别的长度为n的位置窗口，被分配给敌对的利益分配者。当字符串有这样的解释时，我们涉及他们作为特有的字符串。

**定义 4.9** (特有的字符串) 确定一个带有创世块B0的执行，敌对方A,和环境Z.让S = {sli+1, . . . , sli+n}表示一系列长度|S| = n的位置。S的特有的字符串w 2 {0, 1}n被定义，因此wk = 1，如果，并且只有如果敌对方控制位置sli+k的位置领导者。对于这样一个特有的字符串w 2 {0, 1}，我们说索引i是敌对的，如果i哦wi = 1，并且诚实，否则。

我们从一些我们方式的直觉上去分析这个协议。让w 2 {0, 1}n成为一个特有的字符串，对于一系列位置S。考虑到两个观察(i)立即下线，限于S的开始，(ii.)有当前链的相同的观点C0，先于S的开始，(iii.)回到线上，在S的最后位置，要求他们链的一个更新。在我们的分析里一个基本的关心是可能性，这样的观察者能够被展示，带有一个发散的视角，在序列S上：特别地，这个可能性，敌对方能强迫两个观察者去采用两个不同的链C1,C2,其普通的前缀是C0.

我们观察到不是所有的特有的字符串允许这个。例如，字符串（完全诚实的）0n确保两个观察者采用相同的链C，包含n新的区块，在普通的前缀C0之上。另外一方面，其他字符串不能确保C0的这样的普通的扩展；在1n的情况下，对于敌对方是可以生成两个完全不同的历史，在位置S的序列期间，给两个观察者提供两个有区别的链C1,C2,仅仅共享普通的前缀C0。在这一张的剩余部分，我们建立，允许这样分叉的字符串非常少，事实上，我们展示，他们有密度，只要敌对方位置的部分是1/2 − .

关于特有的字符串w 2 {0, 1}n,分叉的原因，我们定义如下正式的分叉的概念，捕获在链广播之间的关系，通过诚实的位置领导人，在协议iSPoS的执行期间。为了对定义做准备，我们回想起诚实的选手总是选这去扩展一个最大长度的链，在这些对网络中选手可能的选项中。此外，如果这个一个最大的链C包含一个区块B，之前由诚实的选手广播，C的前缀优先于B必须完全的和链一致（在B处中止），由前面的诚实选手广播。跟随性质即刻跟随，从这个事实，任何诚实的区块的状态有效地焦黑一个独特的链，在创世块开始的。最后，然和由诚实选手广播的链C以一个由诚实选手之前生成的链开始（或者，替代地，创世块），继续，带有一个可能的敌对区块的空的序列，最后，带有一个诚实的区块而终止。它遵循由诚实选手广播的链形成一个自然的直接树形网络。诚实选手可可信赖的广播他们的链，并且总是在最长可能的链上建立的事实引入了这个树的第二哥重要性质：各种各样诚实区块的深度，由诚实选手添加，在协议必须全部是可区分的。

当然，由iSPoS的执行引起的实际的链由区块组成，包含各种各样的数据，对于关于分叉的原因是无形的，为此。以下分叉的正式概念仅仅反应直接的树，由相关链形成的，选手的身份，被表达成在字符串w,对在这些链上生成区块负责。

**分叉和分叉的字符串** 我们定义，如下，基本的组成结构骂我们用来去推出可能的观点，由诚实的选手观察的，在一个协议执行期间，带有特别的字符串

**定义 4.1 (分叉)** 让w 2 {0, 1}n，并且让H = {i | wi = 0}表示诚实的指数的集合。对于字符串w的分叉是一个直接的，根源的树F = (V,E)，带有一个标签`：V ! {0, 1, . . . , n}，因此：

- F的每个优势都是从根来;
- 根r 2 V是给定的标签`(r) = 0
- 标签，和任何直接的路径一起，在树上，是严格的增长的
- 每个诚实的索引i 2 H是精确的F的顶点
- 函数d : H ! {1, . . . , n},定义，因此d(i)是在F,独特的顶点v,对于`(v) = i是严格的增加的。（特别的，如果i, j 2 H and i < j, 那么 d(i) < d(j).)）

图形 5：对于字符串w = 010100110的分叉F；顶点出现，带有他们的标签和诚实的顶点用双边界强调。注意诚实顶点的深度，和诚实的w指数相关联，被严格的增加。两个尖头在图形中被区分：一个以ˆt为标签，在以9为标签的顶点终止，在分叉中是最长的尖头；第二个尖头在标签为3的顶点终止。数量gap(t)表明在长度上的不同，在t和ˆt之间；在这个情况下gap(t) = 4.数量reserve(t) = |{i | `(v) < i  |w| and wi = 1}|表示敌对指数的数量，在最后诚实顶点V的标签后出现，在这个尖头里；在这个情况reserve(t) = 3.当每个F的叶子是诚实的，F被关闭了。

作为注释的问题，我们写F ` w去表示F是对于字符串w的一个分叉。我们说分叉是不重要的，如果他包含一个单个的顶点，根。

**定义 4.11** （尖头，深度，和高度；~关系）。在从根引起的分叉F的路径叫做尖头。对于尖头t，我们让length(t)表示他的长度，等于在路径中的边缘的数量。对于顶点v,我们让depth(v)表示（独特的）尖头的长度，在v处终止。一个分叉的高度（和一个树一样平常，被定义为最长尖头的长度）。

我们过载符号`()，因此他们应用到尖头上，通过定义`(t) , `(v),v是在尖头t上的终点的顶点。对于分叉F的两个尖头t1 和t2，我们写t1  t2，如果他们分享一个边缘。注意那个是一个等价关系，在非平凡的尖头的设置上；换句话说，如果t表示“空的”尖头，单独的包含根顶点，那么对于任何尖头t,t 6 t.

如果分叉的顶点V带上一个敌方的索引做标签的（例如，w`(v) = 1），我们说顶点是敌对的；否则，我们说顶点是诚实的。为了方便起见，空的尖头t是诚实的。

参照图片5作为例子，也证明了上述的和这个章节剩下的当众定义的一些数量。在图形中展示的分叉反映了一个执行，在诚实的选手，和第一个位置联系，直接在创世块上建立的（正如他必须），（ii）诚实的选手，和位置5关联的，被展示位长度2的链，在步骤链上建立的。带有一个进一步的敌对的区块最大，由位置的选手生成等。

**定义 4.12** 我们说分叉是平的，如果有长度的两个尖头t1 6 t2，等于分叉的高度。字符串w 2 {0, 1}据说分叉，如果有一个平的分叉F ` w.

注意位了一个iSPoS的执行，去产出两个完全最大长度的不连贯的链，和执行相关的特有的字符串将会被分叉。我们的目标是去建立如下上限，在分叉字符串的数量上。

**定理 4.13** 让 2 (0, 1)，并且让w成为一个字符串，另外子{0, 1}n，通过独立的给每个wi = 1赋值，带有可能性(1 − )/2。那么Pr[w is forkable] = 2−(p、n).

注意，在随后的工作重，Russell et al.改进这个限制到2−(n).

 **分叉的结构的特点：关闭的分叉，前缀，到达，和边缘** 我们通过为两个分叉定义一个自然的包含概念开始：

**定义 4.14** （分叉前缀）如果w是字符串w0 2 {0, 1}的前缀，F ` w, 并且 F0 ` w0,我们说F是F0的前缀，写作F v F0,如果F是F0.的一致的标签的子图，特别地，F的每个顶点和边缘在F0重出现，除外，给予任何顶点的标签在F 和F0重出现的是完全相同的。

在许多情况下，和分叉一起工作是方便的，不发表任何超过最终诚实指数的事情。

**定义 4.15** （关闭的分叉）。一个分叉被关闭，如果每个叶子都是诚实的。根据惯例，轻微的分叉，单独的包含一个根顶点，被关闭。

注意，一个关闭的分叉有一个独特的最长尖头（当所有的最大尖头带有一个诚实的顶点终止，并且这些必须有明显的深度）。注意，此外，如果w是w的前缀，并且F ` w,那么哪里有一个独特的关闭的分叉ˇ F ` ˇ w，对于F v F.尤其，使得w = w,我们注意到对于任何分叉F ` w,有一个独特的分叉F ` w，对于F v F;在这个情况下，我们说F是F的终止。

**定义 4.16** (缺口，储备和延伸)。让F ` w成为一个关闭的分叉，并且让ˆt表示（独特的）在F重的最大长度的尖头。我们定义尖头t的差距，表示为gap(t)，成为ˆ和ˆ之间的长度上的不同：

gap(t) = length(ˆt) − length(t) .

我们定义尖头t的储备成为敌对的指数数量，出现在w重，在t的最后的指数后；特别的，如果t是由path (r, v1, . . . , vk),给定的，r是F的根，我们定义：

reserve(t) = |{i | wi = 1 and i > `(vk)}| .

我们注意到这个数量取决于F和特定的字符串w，和F相关联。最后，对于尖头t,我们定义：

reach(t) = reserve(t) − gap(t) .

**定义 4.17** （利润）。对于一个关闭的分叉F ` w，我们定义(F)为最大的延申，接管所有在F重的尖头：

(F) = maxtreach(t) .

同样的，我们定F的边缘，表示为μ(F),成为倒数第二的延申，接管F的边缘-脱散：特别低

margin(F) = μ(F) = max
t16t2

min{reach(t1), reach(t2)}

. (1)

我们注意到上述极限总是由诚实的尖头获得。特别低，如果t是一个分叉F ` w,的敌对方的尖头，延申reach(t)  reach(t),t是t的最长的诚实的前缀。

正如在非空尖头上是一个等价关系，它遵循，那总是有一对（边缘-打散）尖头t1 和 t2，完成最大的，在定义的等式中，满足reach(t1) = (F)  reach(t2) = μ(F).

利润的对于可分叉概念的关联在下述命题中被反映：

**命题 4.18** 字符串w是可分叉的，如果，仅仅如果又一个关闭的分叉F ` w，对于margin(F)  0.

证明。如果w没有诚实的指标，那么微小的分叉，包含一个单个的根节点是平的，关闭，并且没有非负利润；因此，两种情况是平等的。考虑分叉的字符串w,带有至少一个诚实的指标，用ˆi表示w的最大的诚实的指标。让F称为平的分叉，对于w.让F ` w称为F的关闭（从F处获得，通过移除任何敌对的至高点，来自F的尖头的结尾）。主义尖头ˆt包含ˆi，是F中的最长的尖头，当这个是w的最长的诚实的指标。另一方面，F是平的，在情况：有两个边缘-打散尖头t1和t2,带有长度，至少是ˆt的。在F中的这些两个尖头的前缀必须清晰的有储备，不小于间距（因此非负到达）； 因此margin(F)  0作为要求的。

另一方面，假设w有一个关闭的分叉，带有margin(F)  0，有F的两个边缘-分散尖头，t1和t2，对于到达ti)  0.那么我们能生成一个平的分叉，通过简单地给每个ti增加一个gap(ti)至高点的路径，以随后的敌对的指数为标签，由reserve()的定义允诺。

根据这个命题，对于字符串w，我们把注意力几种在数量上：

并且，为了方便

注意这过载符号(·) 和 μ(·)，因此他们适用于分叉和字符串，但是设置会从环境中清楚。我们决策定义不保证一个优先的(w) and μ(w)可以被相同的分叉完成，虽然这会在如下引理中建立。无论如何，是对于字符串w，(w)  0 和 (w)  μ(w)清楚的；此外，根据命题4.18，字符串w是可分叉的，如果并且仅仅如果μ(w)  0.我们指的是μ(w)作为字符串w的利润。

为了证明定理4.13做准备，我们建立一个递归的描述，对于这些数量。

**引理 4.19** m() = (0, 0)，对于所有的非空字符串2 {0, 1}

此外，对于每个字符串w,由一个关于的分叉Fw ` w，对于m(w) = ((Fw), μ(Fw)).证明。这个证明通过归纳法进行，如果w = ,定义F称为席位的分叉；F ` w是独特的分叉，对于字符串，并且m() = (0, 0) = ((F), μ(F)),作为要求。

总之，我们考虑m(w0)，对于字符串w0 = wx—where w 2 {0, 1} 和x 2 {0, 1};论证递归地扩展m(w0)，根据m(w)和最后符号x的值。在每种情况，我们考虑在两个关闭分叉v F0之间的关系，F ` w和 F0 ` w0 = wx。

在x=1的情况下，我们必须有如图表所示F = F0，因为分叉被认为是被关闭的；容易看到F ` w的任何尖头t的到达增加，精确的1，当看作F0 ` w0的尖头。我们写到达F0(t) = reachF (t) + 1，我们引入符号reach()去表示在特定分叉丽的到达。它遵循(F0) = (F) + 1 和μ(F0) = μ(F) + 1。如果F ` w0是关闭的分叉，对于(F) = (w0),注意F可能被作为对于w的一个分叉对待，并且使用上述论证，我们发现(w0)  (w)+1，一个相似的论证意味着μ(w0)  μ(w) + 1.另一方面，通过归纳法，有一个分叉Fw，对于m(w) = ((Fw), μ(Fw))，因此m(w0)  ((w) + 1, μ(w) + 1).我们推断：

m(w0) = ((w) + 1, μ(w) + 1) .

此外，m(w0) = ((Fw), μ(Fw)),Fw 被作为对于w0 = w1作为分叉对待。

x = 0的情况是更雅致的。如上，我们考虑在两个关闭分叉F ` w and F0 ` w0 = w0之间的挂巴西，对于F v F0.这里F0必要地从F中获得，通过修改一个路径，标签为一个字符串，形式1a0到F的尖头t的末尾。（实际上，容易看到我们可能总是假定这个被附加到一个诚实的尖头上）。为了让这个称为可能，gap(t)  reserve(t)（可以说reach(t)  0），特别地，gap(t)  a  reserve(t):对于第一个不平等注意新的诚实的顶点的深度必须超过F中最深的（诚实的）顶点，因此a  gap(t);关于第二个不平等，仅仅reserve(t)可能敌对的指数，可能被添加到t中，因此a  reserve(t).我们定义数量a  0，通过等式a = gap(t) + ˜a，用t0表示尖头（F0的），有扩展t在这个方式导致的。我们说˜是参数低于分叉F v F0.的对。

当然，每个F的诚实的尖头t是一个F0的诚实的尖头，清楚的是reachF0(t) =
reachF (t) − (˜a + 1)，当在F0中最长的尖头t0超过F的最长的尖头的长度，通过精确的˜a + 1.注意新的诚实的尖头t0(在 F0)的到达总是0，当gap(t0)和reserve(t0)是0.保持去描述μ(w) and (w)如何被这个过程决定的。

情况(w) > μ(w) = 0。通过归纳法，有一个分叉Fw，对于m(w) = ((Fw), μ(Fw)).让t1 和 t2称为Fw的边缘-松散的尖头，对于(Fw) = reach(t1) and μ(Fw) = reach(t2).定义F0 ` w0为分叉，通过扩展Fw的尖头t2来获取，带有参数˜a = 0去生成在F0中的新的t02。那么到达F0(t1) = (w)−1和到达F0(t02) = 0。它遵循(w0)  (w) − 1 and μ(w0)  0.。我们将展示(w0)  (w) − 1和μ(w0)  0,μ(w0)  0,情况我们可以推断：

(w0) = (w) − 1 and μ(w0) = 0 .

此外，分叉Fw0 = F0获得这些统计资料，作为要求。

我们返回到建立(w0)  (w) − 1和μ(w0)  0.让F ` w0称为一个关闭的分叉，对于(w0) = (F)，让F ` w称为独特的关闭的分叉，对于F v F;同上，用˜a表示对于这个扩展的参数。让t称为F的诚实的尖头，因此reachF(t) = (w0).如果t是F的尖头，reachF(t) = reachF (t) − (˜a + 1)  (w) − 1.否则，t从扩展中获得，通过扩展，reachF(t) = 0  (w) − 1通过假设。在任何一种情况(w0)  (w) − 1,如要求。保持去展示μ(w0)  0。现在考虑F ` w0称为关闭的分叉，对于μ(F) = μ(w0).让t1 和 t称为F*的两个边缘-松散的诚实的尖头，因此，reachF(t1 ) = (F) and reachF(t2) = μ(F) = μ(w0).让F ` w称为独特的关闭的分叉，对于F v F。让a称为对于这个扩展的参数。t1和 t两者是F的尖头，达成reachF(t
i ) = reachF (t
i ) − (˜a + 1)，特别地，达成(t1)  reachF (t2 ).它遵循reachF (t2 )  μ(F)  μ(w) = 0，因此μ(w0) < 0.否则，两个尖头中的一个是扩展的结果，有0reach()在F中，正如F(t1 )  reachF(t2),在任何情况，它遵循μ(F) = reachF(t2 )  0,如要求。

**情况** (w) = 0。通过归纳法，有一个分叉Fw，对于m(w) = ((Fw), μ(Fw)).让t1和 t2成为FW的边缘-大三的尖头，which (Fw) = reach(t1) and μ(Fw) = reach(t2).定义F0 ` w0称为分叉，通过扩展Fw的尖头t1获得，带有参数˜a = 0，去产出新的尖头t01，在F0.然后达成F0(t01) = 0，并且达成F0(t2) = reachF (t2) − 1.它遵循(w0)  0 and μ(w0)  μ(w) − 1.我们会展示(w0)  0 and that μ(w0)  μ(w) − 1,在这种情况下我们可以推断

(w0) = 0 and μ(w0) = μ(w) − 1 .

而且，分叉Fw0 = F0获得这些统计资料，如需求。

我们返回去建立(w0)  0和μ(w0)  μ(w) − 1.让F ` w0称为一个关闭的分叉，对于(w0) = (F)，让F ` w称为毒液的关闭的分叉，对于F v F；如上，用a标示对于这个扩展的参数。让t称为F的诚实的尖头，因此达成F(t) = (w0).注意t不能称为F的将头；如果它然后reachF(t) = reachF (t) − (˜a + 1)  (w) − 1 < 0，和(w0)  0矛盾。因此t由扩展获得，并且达成F(t) = 0.它保持去展示μ(w0)  0。现在让F ` w0称为一个关闭的分叉，对于μ(F) = μ(w0).让t1 和 t2成为F的两个边缘-打散的诚实的尖头，因此达成F(t1) = (F) 并且reachF(t2) = μ(F) = μ(w0).让F ` w称为F的独特的尖头；如果是，(F) = reachF(t1 ) = reachF (t1 )−(˜a+1)  (F)−1 
(w) − 1 < 0，和(F)  0.矛盾，它遵循t1必须扩展一个F的尖头t1，对于reachF (t1) = 0,i那位扩展仅仅能发生，对于非负的到达的尖头和(F) = 0 = (w).因此t2是F的尖头，并且t1 6 t2，因此reachF (t2)  μ(F)  μ(w)，并且我们得出结论μ(w0) = reachF(t2)  reachF (t2 ) − 1  μ(w) − 1,如要求。

**情况** (w) > 0, μ(w) 6= 0.通过归纳法，有一个分叉Fw，对于m(w) = ((Fw), μ(Fw)).让t1和 t2成为Fw的边缘-拆散的尖头，对于(Fw) = reach(t1) and μ(Fw) = reach(t2).实际上，Fw的任何扩展都将足够构建；举个具体例子，定义F0 `
w0称为分叉，从扩展Fw的尖头t1获得，带有参数˜a = 0.那么reachF0(ti) = reachFw(ti) − 1.它遵循(w0)  (w) − 1 和 μ(w0)  μ(w) − 1.我们将展示(w0)  (w) − 1 和 that μ(w0)  μ(w) − 1,我们将推断：

(w0) = (w) − 1 and μ(w0) = μ(w) − 1 .

此外，分叉Fw0 = F0完成这些统计数据，按照需求。

我们回到建立(w0)  (w) − 1 and that μ(w0)  μ(w) − 1.让F ` w0称为一个关闭的分叉，对于(w0) = (F)，让F ` w称为独特的关闭的分叉，对于v F；同上，用˜a表示这个扩展的参数。让t成为F的诚实节点，因此reachF(t) = (w0).注意，如果t是F的尖头，那么reachF(t) = reachF (t) − (˜a + 1) 
21
(w) − 1;否则，t通过扩展和reachF(t) = 0  (w) − 1,获得，如需求（回想起(w) > 0.)它保持展示μ(w0)  μ(w) − 1.现在让F ` w0成为关闭的分叉，对于μ(F) = μ(w0).让t1 和 t2成为F的两个边缘-打散的诚实的尖头，因此reachF(t1) = (F) and reachF(t2 ) = μ(F) = μ(w0).让F ` w成为杜特地关闭的分叉，对于F v F，让a成为对于这个扩展的参数。如果t1 和 t两者是F的尖头，那么reachF(t
i ) = reachF (t
i )−(˜a+1)，特别地，reachF (t1 )  reachF (t2 )，因此reachF (t2 )  μ(w) and reachF(t2 )  μ(w) − 1,如要求。

为了完成论证，我们认为这个情况，尖头t的其中一个通过扩展出现。注意在这个情况reachF(t2)  0,或t2是从扩展种获得的，因此有0到达，或t1从扩展种获得，因此F(t2)  reachF(t1) = 0。这里我们进一步把分析分成两种情况，在μ(w)的符号上：

- 如果μ(w) > 0,那么reachF(t2)  0  μ(w) − 1，如需求
- 如果μ(w) < 0，那么t2不能成为F种的尖头的扩展。来看这，假定相反地，t2扩展F的一个尖头t2;那么reachF (t2)  0.除外，t1必须是F的尖头，边缘-打散，从t2,并且(t1 ) = reachF(t1 ) + (˜a + 1) > 0.它遵循μ(w)  μ(F)  0,一个矛盾

其他可能性是t1是F的尖头t1的扩展，在这种情况reachF (t1) 0.注意t2是F的尖头，并且边缘-打散来自t1;因此min(reachF (t2), reachF (t1)) μ(F) < 0 and reachF (t2)  μ(F).我们推断reachF(t2 ) = reachF (t2 )−(˜a+1) 
μ(w) − 1,如要求。

在合适的位置的递归描述，我们返回定理4.13的证明，我们为了方便在下面重讲。

**定理 4.13， 重讲** 让 2 (0, 1)，并且让w成为从{0, 1}n的字符串，通过独立地赋值每个wi = 1，带有可能性(1 − )/2.那么

Pr[w is forkable] = 2−
(p
n) .

定理4.13.的证明，定理影响在{0, 1}n上的可能性分布，由独立的选择每个wi 2 {0, 1}给定，因此：

Pr[wi = 0] = 1 + 
2 = 1 − Pr[wi = 1]

w是从分布中提取的。对于字符串w1 . . .wn，带有上述可能性分布选择，定义随机变量

Rt = (w1 . . .wt) and Mt = μ(w1 . . .wt) .

我们的目标是建立

Pr[w forkable] = Pr[Mn  0] = 2−
(p
n) .

我们从引理4.19的描述中提取一些关于随机变量的事实

Rt > 0 =)
(
Rt+1 = Rt + 1 if wt+1 = 1,
Rt+1 = Rt − 1 if wt+1 = 0;
(3)
Mt < 0 =)
(
Mt+1 = Mt + 1 if wt+1 = 1,
Mt+1 = Mt − 1 if wt+1 = 0;
(4)
Rt = 0 =)
8>><
>>:
>>Rt+1 = 1 if wt+1 = 1,
>>Rt+1 = 0 if wt+1 = 0,
>>Mt+1 < 0 if wt = 0.
>>(5)
>>In

根据上述性质3，随机变量是非常行为端正的，当是正的，特别，考虑分布，在每个wi上，他们仅仅遵循相似的片面的图形6的步行。同样地，考虑性质（4），随机变量Mt尊重一个片面的随机步行当负的。证明的剩余部分组合可能性规律，带有（5），和事实Mt()  Rt()，去建立Mn < 0带有高的可能性。

我们回想起两个关于标准的基础的事实，片面的不幸，和图标6的Markov链有关联。让Zi 2 {±1} (for i = 1, 2, . . .)表示独立随机变量的家族，对于Pr[Zi = 1] = (1 − )/2.那么片面的不幸，由变量Yt = Pti
Zi给定由如下性质：

**恒定的泄露可能性；赌徒的毁灭** 带有恒定的可能性，仅仅依赖，Yt 6= 1对于所有t > 0.总之，对于每个k > 0,

Pr[9t, Yt = k] = k ,

对于一个恒定的 < 1，仅仅依赖.（实际上，常量是(1−)/(1+);参看例如[25, Chapter 12]，对于完整的开发）

**集中（切尔诺夫限制）** 考虑片面不幸的T步数，在状态0处开始；那么作为结果的值是紧紧地集中于−T .特别地，E[YT ] = −T，并且Pr

YT > −
T
2

= 2−
(T) .

（持续的隐藏在()概念，仅仅依赖。参照，例如[1, Cor. A.1.14]）

分割字符串w,我们写w = w(1) · · ·w(pn)，w(t) = w1+at−1 . . .wat and at = dt
p
ne,对于t = 0, 1, . . ..，让R(0) = 0 和 R(t) = Rat；类似地定义M(0) = 0 and M(t) = Mat。  成为小的常数

我们定义这些时间，基于随机变量R(t) 和 M(t):

**热** 我们用Hott表示事件R(t)  
p
n and M(t)  −
p
n.

**不稳定的** 我们让Volt表示事件−
p
n  M(t)  R(t) < 
p
n.

**冷** 我们让Coldt表示事件M(t) < −
p
n.

注意对于每个t,精确地这些事件中的一个发生，他们分割可能性空间，那么我们将建立:

注意通过定义发生的事件Vol0。假定这些不等式，我们观察到系统很有可能成为冷的，并且保持那个方式。假若这样，Coldpn发生，M
n < 
p
n < 0,并且w是不可分叉的。特别地，注意这个可能性系统曾经从易波动过渡到热的，不超过2−
(p
n)（当从Vol过渡到热是限制于依照2−
(p
n),以上，有不超过n的可能的过渡的机会）

注意，也是，当系统是不稳定的，它过渡到冷的，带有恒定的可能性，在每个阶段。尤其，可能性，系统对于整个过程是不稳定的，是不超过2−
(p
n).最后，注意可能性，系统曾经过渡出冷状态，是不超过2−
(p
n)（再次，有至多p
n可能的次数当这个可能发生，当任何个别的过渡发生，带有可能性2−
(p
n)).）它遵循系统是冷的，在带有可能性1 − 2−
(p
n)过程的结尾

它保持去建立三个不等式(8), (9), 和(10).

**不等式(8)** 这遵循直接来自(3) 和 (6).特别地，根据随机变量Mi罪刑简单的片面的步行的可能性的规律，当他们是负的。以M(t) = Mat < −
p
n为条件，可能性，任何未来Ms曾经攀登到值−1上，不超过−
p
n = 2−
(n),，根据需求*（这里 < 1是固定的常量，仅仅依赖于.）、

**不等式(9)** 这遵循来自(3), (5), (6), and (7).特别地，以Volt为条件，R(t) 

p
n.从(3)回想，随机变量Ri遵循简单的片面步行的可能性规律，当他们是正的。让D成为事件，Ri > 0，对于所有at  i < at+2
p
n.根据（7），那么，我们取T = 2
p
n, Pr[D]  2−
(p
n).带有接近的确定性，那么随机变量Ri访问值0在这个期间。观察如果Ri = 0那么，根据（5），Mi+1  −1带有恒定的可能性，并且（以这个为条件），根据（6），带有恒定的可能性，带有随后的随机变量Mj不返回到值0.此外，根据（7），可能性，有一个长度至少2(/)p
n的序列，对于：

超过(p
n)22−
(p
n).，它遵循，带有恒定的可能性，步行（Ri）碰撞0，如上描述，并且，那么Mi在一个小于−
p
n.的值处终止。

**不等式** (10):这遵循(3), (5), (6), 和 (7).特别地，以Volt为条件，R(t) 。从（3）中回忆：随机变量R遵循简单的片面的步行的可能性规律，当他们是正的。让D诚实事件，Ri > 0对于所有at  i < at+2
p
n.根据（7），那么，我们取T = 2
p
n, Pr[D]  2−
(p
n).带有接近的确定性，那么，随机变量Ri访问值0，在这个期间，以D为条件，为了Rat+1  
p
n，必须先有这些随机变量0 = Ri,Ri+1, . . . ,Rj =
b
p
nc的一个序列，因此，他们中都不取值0，除了第一个。（这样一个序列升起，通过取i成为最后的事件，变量Rat , . . .访问0和j,第一个随后的事件，序列大于
p
n.)）根据(6)，这样一个序列的可能性出现在一个特定的值对于i是不超过−
p
n.它遵循可能性，Rat+1  
p
n小于p
n−
p
n = 2−
(p
n),

**提取分叉的可能性，用于n的明确的值** 为了获得进一步的洞察力，关于分叉字符串的密度，我们精确地计算可能性，一个字符串w,从二项分布中提取，带有参数p 2 {.40, .41, . . . , .50}，是可分叉的，对于若干不同的长度。这些结果在图形8中表示。

**4.3.1  秘密的敌对方，秘密的分叉，秘密地可分叉字符串**

在上述定义4.10中定义的分叉的一般的概念反映了敌对的位置的领导者可能广播多重的区块，对于一个单个的位置；这样的敌对的重要的机会去和协议terfere,它留下一个可疑的“审核足迹”--多重的敌对方，广播部超过一个区块每个位置。这样一个敌手可能仍然从协议脱离，通过扩展短的链，但是不生成这样的可以的证据，并且因此它的策略是更多的“可否定的”：它能归咎于网络延迟，对于它的行为。

这样一个敌对方产出一个限制的分叉的定义，定义如下：

图标8：可能性的图标，一个从二项分布中提取的字符串是可分叉的。对于字符串长度n = 500, 1000, 1500, 2000图表被带有参数.40, .41, . . . , .49, .50.显示。

**定义 4.20** 让F ` w成一个分叉，对于一个字符串w 2 {0, 1}.我们说F是秘密的如果标签` : V ! {0, 1, . . . , }是单射的。尤其，，没有敌对的指数被超过一个节点归类。

当在通常情况下，我们定义分叉字符串的概念，对于这样的敌对方。

**定义 4.21** 我们说字符串w是秘密地可分叉，如果有一个平的秘密的分叉F ` w.

秘密的敌对方和分叉有更简单的结构，相比一般的敌对方。特别地，一个字符串秘密地可分叉，如果并且仅仅如果它的指数的大多数是敌对的。这对于秘密地可分叉字符串提供了命题4.18的类似物。

**命题 4.22** 一个字符串w 2 {0, 1}n是秘密的可分叉，如果并且仅仅如果wt(w)  n/2.

证明。让w成为一个秘密的可分叉的字符串和F ` w一个平的秘密的分叉。当F是平的，有两个边缘打散尖头，t1 和 t2,带有长度，等于height(F)。它遵循F中顶点的数量至少是2 · height(F) + 1.在秘密的情况下，归类功能是内射的，并且它遵顼n  2 · height(F).（回想根顶点被贴上标签0，不是一个进入w的指数）。换句话说，F的高度至少是w的诚实指数的数量。我们推断w的长度至少是最诚实的指标的数量的两倍，根据要求。

如果wt(w)  n/2,我们能生成一个平的秘密的分叉F ` w，通过在一个普通的尖头t1上放置所有的最诚实的指数，选择length(t1)敌对的指数去形成一个边缘-打算的第二的尖头t2.

当秘密的可分叉的字符串的结构是如此简单，定理4.13的类似物，对于秘密地可分叉的字符串的密度，直接的遵循，来自标准的大的偏差限制。

**定理 4.23** 让 2 (0, 1)，并且让w成为从{0, 1}n中提取的字符串，通过独立地赋值每个wi = 1，带有可能性(1 − )/2.那么

Pr[w is covertly forkable] = 2−(n) .

证明。这个从标准的估计产生，对于二项分布的累积的密度函数。

**秘密的可分叉性的精确的可能性，对于n的明确的值** 为了和一般情况比较，我们计算可能性，一个从二项分布提取的字符串秘密地可分叉。这些结果在图形9中展现。（注意这些可能性是二项分布的累积的密度函数的简单的适当的评估）。对于一般情况的类似的结果在图形9中出现。

秘密的可分叉性的可能性

图形9： 可能性图标，一个从二项分布中提取的字符串是秘密地可分叉。对于字符串长度n = 500, 1000, 1500, 2000的图表带有参数.40, .41, . . . , .49, .50.显示。

**4.4 普通的前缀**

回忆由最诚实的选手组成的链，在iSPoS的执行期间，符合分叉的建有，正如在前面的章节定义和学习的。位置的随机分配，对于由FD,F给定的利益相关者确保相关联的典型的字符串w的坐标遵循二项式分布，带有可能性，等于敌对的质押。因此，定理4.13建立了，协议iSPoS没有执行会引起两个尖头（链），最大长度不带有普通的前缀.

在iSPoS的情况下,但是,我们希望建立一个更加强壮的普通前缀性质.链的任何对,可以,原则上,由敌对方呈现给最诚实的方,有一个"最近的"普通的前缀,从某种意义上说,移除一小部分区块,从较短的链上,导致更长的链的前缀.

为了正式地明确有力的表达和证明这个性质,我们介绍一些进一步的定义,关于尖头和分叉.我们借用"截词符",对于链在论文中更早的描述的:对于一个尖头t,我们用tdk表示这个尖头,通过移除最后的k边缘获得的;如果length(t)  k,我们定义length(t)  k,仅仅由根组成.

**定义 4.24** (可行性) 让F ` w成为一个分叉,对于字符串w 2 {0, 1}n,让t成为F的一个尖头.我们说t是可行的,如果,对于所有诚实的指数h  `(t),,我们有:

d(h)  length(t) .

(回忆`(t)是t的终点的顶点的标签)

如果t是可行的,一个外部的(诚实的)观察者证明这个执行,在时间`(t),如果提供了尖头t,带有所有诚实的尖头,生成到时间`(t),可以理解的选择t,通过maxvalid()规则.观察到任何诚实的尖头是可行的:通过定义,诚实的尖头的最终的顶点的深度超过所有优先的诚实的尖头.

**定义 4.25** (分歧) 让F成为对于字符串w 2 {0, 1}的分叉.对于两个可行F的尖头t1和 t2,定义他们的差异成为数量:

div(t1, t2) = min
i
(length(ti) − length(t1 \ t2)) ,

t1\t2表示t1\t2的普通的前缀.我们过载这个概念,通过定义差异,对于F,当最大的超过可行的尖头的所有的对:

div(F) = max
t1, t2 viable
tines of F

最后,定义w的差异为最大数,比如差异超过所有可能的分叉,对于w:

div(w) = max
F`w
div(F) .

观察到,如果div(t1, t2)  k,说length(t1)  length(t2),尖头tdk是t2的一个前缀.

我们首先建立了一个字符串带有大的差异,必须有一个大的可分叉的子字符串.我们然后应用这个,在下述定理4.27,去推断,典型的字符串从iSPoS升起,是不可能有大的差异,因此拥有普通的前缀性质.

**定理 4.26** 让w 2 {0, 1}然后又一个分叉的子字符串,w,带有| ˇ w|  div(w).

证明.考虑一个分叉F ` w金额一对可行的尖头(t1, t2),对于:

div(t1, t2) = div(w) .

为简单起见,我们假定尖头被归类,因此`(t1) < `(t2),进一步这样:

|`(t2) − `(t1)|是最小的,在尖头的所有对上,对于持有

我们通过确定子字符串w开始;证明的余下部分致力于建立一个平的分叉,对于ˇ,建立分叉可行性.让y表示最后的顶点,在尖头t1 \ t2上,正如在如下图标里,让 , `(y) = `(t1 \ t2).

用表示w的最小的诚实的指数，对于  `(t2),带有惯例，如果有这样的指数，我们定义 = n + 1.我们观察，无论如何，`(t1) < `(t2)，并且因此 − 1  `(t1). 这些指数，和 ,区分子字符串w = w+1 . . .w−1,，是证明的剩余部分的主题。当函数`(·)是严格的增加，随着任何时间，观察到

| ˇ w| =  −  − 1  `(t1) − `(y)  length(t1) − length(t1 \ t2)
 min(length(t1), length(t2)) − length(t1 \ t2) = div(w) ,

所以有预期的长度，它满足去建立，它是可分叉的

我们简略地概括这个证明，在展现细节之前。我们通过建立尖头t1 和 t2的若干结构的性质，由上述假设(11) 和(12)产生。去建立ˇ w是可分叉的，我们然后i从F从提取一个平的分叉（对于w），通过两步：(i.)分叉经受一些较小的重组去确保所有的“长”尖头通过y;(ii.)一个平的分叉是通过对待顶点y的方式创建，当以w的指数为标签的的F的子树的部分的根。在建造终了时，两个尖头t1 和 t2将产出需求的“长的，打散的”尖头，满足可分叉的定义。

我们观察，首先，顶点y不能时敌手的：否则容易创建一个替代的分叉F ` w和一对尖头在，完成更大的差异。特别地，创建˜，从F，通过增加一个新的（敌手的）顶点 ˜到F，对于`(˜y) = `(y),增加一个边缘到y，从顶点领先y,替代t1的边缘，遵循y,带有一个来自˜；然后分叉的其他的而相关性质会被保持，但是，作为结果的尖头的差异增加了1.（参照下述图表）

一个相似的论证意味着分叉F0 ` w1 . . .w通过包含仅仅F的尖头获得，带有标签，小于或等于 = `(y)，由一个独特的深度depth(y)的顶点（也就是y本身）。在另外带有深度depth(y),一个顶点y（F0的）在场的情况下，使t1改方向，通过˜（正如在上述论证中）会同样地导致一个带有更大差异的分叉。注意`(·)实际上增加，带有新的尖头（来自重新定向t1），因为`(˜y)  `(y)，根据F0的定义。当时字符串的最后的索引，这额外地意味着F0没有深度超过depth(y)的尖头。

我们注意到极小性假设(12)意味着任何诚实的指数h,对于h < 有深度，步超过min(length(t1), length(t2)):特别地，

h <  =) d(h)  min(length(t1), length(t2)) .

来看这个，考虑诚实的指数h < 和一个尖头th，对于`(th) = h.回想t1 和t2 是可行的；当h < `(t2)，它遵循立即地，d(h)  length(t2).类似的，如果h  `(t1)，那么d(h)  length(t1),所以它保持去解决这个情况，当`(t1) < h < `(t2):特别地，在这个管理体制，我们希望同样的确保d(h)  length(t1).为了否认的利益，假定length(th) = d(h) > length(t1).考虑尖头th,我们分别第调查两个情况，取决于是否th共享和t1一个边缘,在顶点y后。如果，实际上，th 和 t1贡献一个边缘，在顶点y后，然后th和 t2不分享这样的边缘，我们观察到div(th, t2)  div(t1, t2) while |`(t2) − h| < |`(t2) − `(t1)|，和（12）矛盾。如果，换句话说，th在y后和t1不共享任何边缘，我们类似地观察到div(t1, th)  div(t1, t2)，当|th − `(t1)| < |`(t2) − `(t1)|,和（12）矛盾

根据上述注意，我们观察到分叉F可能是被“捏”住，在y，去生成一个本质上完全相同的分叉FByC ` w，带有例外长度超过depth(y)的所有尖头穿过顶点y。特别地，分叉FByC ` w被定义成图表，从F获得，通过改变F的每个边缘，指向到一个长度为depth(y) + 1的顶点，所以他起源于 y.去看到结果树是一个精心设计的分叉，他满足去检查`(·)仍任随着所有FByC的尖头一起增加。为了这个目的，考虑这个打尖的影响，在一个独立的尖头t,在特别的顶点v处终止-他用尖头tByC替代，定义，所以：

- 如果length(t)  depth(y),尖头t是未改变的：tByC = t.
- 否则，length(t) > depth(y)，并且t有一个深度为depth(y) + 1的尖头；注意`(z) > `(y)，因为F0不包含任何深度超过depth(y)的尖头。那么tByC被定义为这个路径，通过尖头在y处终止，一个（新的）边缘来自y到z,并且t的后缀在z处开始（正如`(z) > `(y)，这拥有增加的标签性质）

因此树FByC是一个合法的分叉，在相同的顶点集；注意F中顶点的深度和FByC是完全相同的

通过删除根植于y的树，从这个捏的分叉FByC，我们可能提取一个分叉，对于字符串w+1 . . .wn。特别地，考虑感应的FByC的子图，由顶点{y} [ {z | depth(z) > depth(y)}改变。通过把y对待为一个根顶点，适当地定义标签`yC of FyC so that `yC(z) = `(z) − `(y), 这个子图定义了一个分叉的性质，对于w+1 . . .wn.特别，，考虑是诚实的，它遵循每个诚实的指数h > 有深度depth d(h) > length(y)，因此归类一个顶点在FyC.对于FByC的尖头t,我们用tyC表示在y处开始的尖头的后缀，在FyC中形成一个尖头（如果length(t)  depth(y)，我们定义tyC去仅仅包含顶点y)。注意在分叉FyC中，tyC
1 和 tyC
2部共享边缘。

最后，用ˇ表示一个树，从FyC处获得，当FyC的所有尖头t的联合，因此t的所有的标签从提取（当它出现，作为w+1 . . .wn的前缀），并且

length(t)  max
h| ˇ w|
h honest

它是直接的ˇ F ` ˇ w.为了推断这个证明，我们显示是平的。为了这个目的，我们考虑尖头tyC
1 and tyC。如上所述，他们在FyC不共享任何边缘，因此在ˇ出现的(of tyC
1 和 tyC
2的 )前缀t1 和 ˇ t2不共享边缘。我们希望看到这些前缀在中有最大的长度，在是平的情况下，如要求。这个是立即的，对于尖头t1，因为tyC的所有标签都从w处提取，考虑(13)，它的深度至少是所有相关的诚实的顶点。正如对于ˇ t2,观察到如果`(t2)不是诚实的，那么 > `(t2)，因此，正如带有ˇ t1,尖头ˇ t2被w归类，因此相同的论证，依靠(13),确保t2有长度，至少是所有的相关的诚实的顶点。如果`(t2)是诚实的， = `(t2),并且tyC的终点的顶点不会在F中出现（当它不用ˇ做索引）。在这种情况，但是length(tyC
2 ) > d(h)，对于任何w的诚实的索引，它遵循length( ˇ t2) = length(tyC
2 ) − 1是至少任何w的诚实的指数的深度，如要求。
**定理 4.27** 让k,R 2 N 和  2 (0, 1). 这个可能性，iSPoS协议，当带有敌对方质押的a (1 − )/2 f小部分执行时，违反普通的前缀性质，带有参数k，遍及R位置的时间点不超过exp(−
(
p
k) + lnR);，常量通过()概念隐藏，依赖.

梗概。 观察iSPoS的执行违反普通的前缀性质，带有参数k，R精确地，当分叉F有执行引起的有div(F)  k.因此，我们希望去战时这个可能性，div(w)  k不超过exp(−
(
p
k) + logR).用Bad来表示事件，div(w)  k.

它从定理4.26推断出，如果div(w)  k,有一个长度至少是k的可分叉的字符串w

因此

Pr[common prefix violation]  Pr

9,  2 {1, . . . ,R} so that +k −1   and
w . . .w is forkable


X
1R
X
+k−1R
Pr[w . . .w is forkable]
| {z }

回想典型的字符串w 2 {0, 1}R，对于这样iSPoS的执行是被赋值wi = 1决定的，独立地带有可能性(1 − )/2.根据定理4.13，可能性，长度为t的字符串，从分布里提取，是可分叉的，不超过exp(−c
p
t)，对于证的常数c，注意对于任何  1,

XR
t=+k−1
e−c
p
t 
Z 1
k−1
e−c
p
t dt = (2/c2)(1 + c
p
k − 1)e−c
p
k−1 = e−
(
p
k)

他遵循上述sum ()是exp(−
(p
t)).因此

Pr[common prefix violation]  R · exp(−
(
p
k))  exp(lnR − 
(
p
k)) ,

被需求。

**4.4.1 普通的前缀，带有秘密的敌对方**

我们再访问普通前缀的概念，在秘密敌对方的设置里。我们定义w的秘密的差异称为最大差异，在所有可能的秘密分叉，对于w：

cdiv(w) = max
F`w
F covert
div(F) .

正如在带有一般敌对方的设置里，我们希望去建立一个带有更大的秘密的差异的字符串，必须有一个更大的秘密地可分叉的子字符串。定理4.27的直接的类似物意味着典型的字符串，从iSPoS升起，不可能有打的秘密的差异，因此，掌握普通的前缀性质，对抗秘密的敌对方。

我们记录定理4.26的类似物，对于秘密的敌对方

**定理 4.28** 让w 2 {0, 1}，那么那有一个秘密地分叉的w的子字符串w，带有| ˇ w| 
cdiv(w).

证明。我们更间接，作为证明的部分，有直接的类似物，在定理4.26的证明里有直接的类似物，考虑一个秘密的分叉F ` w和一对F的可行的尖头(t1, t2)，对于div(t1, t2) = cdiv(w);我们假定尖头是被识别的，因此`(t1) < `(t2)，并且，在一般情况的证明下，假定尖头的对最小化数量|`(t2)−`(t1)|，在所有的对中，带有等于cdiv(w)的差异。

用y表示最后的顶点在尖头t1 \ t2.与带有一般敌对方的设置的对照里，不清楚y是诚实的，他激励着一个轻微的不同的选择，对于字符串w的开始：定义称为最大的诚实的w的指数，在尖头t1 \ t2,带有惯例， = 0，如果没有这样的指数。正如在定理4.26的证明，定义称为最小的诚实的w的指数，对于  `(t2),带有惯例 = n + 1，如果没有这样的诚实的w的指数。那么定义w = w+1 . . .w−1;在定理4.26的证明里，确认| ˇ w| = ( −1)−  `(t1)−`(t1 \ t2)  cdiv(w).是容易的。证明的剩余部门证明w是秘密的分叉的。

正如在定理4.26的证明里，任何诚实的指数h < 的深度d(h)不超过min(length(t1), length(t2)):如果h  `(t1)，他直接由可行性的定义推断。否则，`(t1) < h < `(t2)，并且我们考虑尖头th，标签为h:如果length(th) 
min(length(t1), length(t2))，那么尖头th，与t1 或 t2结合，将会产生一对带有差异的尖头，不超过div(t1, t2),但是对于|`(·) − `(·)|是严格的小于|`(t1) − `(t2)|.

为了完成这个证明，我们定义了一个单射的函数i:H ! A,用H表示诚实的指数集，在{+1, . . . , −1}和A补足-w的敌对指数的集合。这样的函数的存在意味着|H|  |A|，因此w是秘密地可分叉的，通过在命题4.22中的给出的标准。让A0  A表示w的敌对方的指数的集合，作为两个尖头t1和t2上的标签出现。函数i被定义成如下：i(h)，对于一个诚实的指数h 2 H,是A的最小的（敌对的）指数，标签一个顶点，在深度等于d(h).假定这个函数是定义明确的，他清楚地内射的，当标签不能出现在一个秘密分叉的多重的顶点上，诚实顶点的深度是成对地有区别的。

为了确认i(h)是明确定义的，注意对于任何h 2 H，我们必须有d() < d(h) 
min(length(t1), length(t2))，因此有至少一个顶点v在t1和t2的每个上，带有等于d(h)的深度；除外，通过定义 h和的性质，这个顶点被标签未w的一个索引。如果d(h)  length(t1 \ t2),在这些尖头上有一个普通的顶点v,对于length(v) = d(h);注意这个顶点不能是诚实的，通过,的定义，所以i(h) = `(v)在这种情况下是定义明确的。如果d(h) > length(t1 \ t2),两个尖头有区别的顶点，在深度d(h)，这些当中的一个必须然后是敌对的-因此i(h)在这种情况下也是明确定义的。

最终，我们注意定理4.27的证明通过较小的改编，到秘密的情况。

**定理 4.29** 让k,R 2 N和 2 (0, 1).可能性，iSPoS协议，带有敌对方质押的a (1 − )/2部分执行，一个秘密的敌对方，违反普通前缀性质，带有参数 k,遍及R的一个阶段，不超过exp(−
(k)+lnR);通过() notation概念隐藏的常熟仅仅依赖.

*证明* 定理4.27的证明直接应用；在这种情况下，渐进依赖定理4.23，如下的限制在一个方式下应用，常数c仅仅依赖.

t=k
e−ct 
Z 1
k−1
e−ct dt = e−(k) .

**链增长和链质量**

预见这两个证明，我们记录一个累积的Chernoff–Hoeffding的限制（参照例子[29]，对于一个证明）

**定理 4.3** （Chernoff–Hoeffdin 限制）让X1, . . . ,XT称为独立随机变量，带有E[Xi] = pi 和 Xi 2 [0, 1].r昂X = PTi
=1 Xi and μ = PTi
=1 pi = E[X].那么，对于所有  0,

Pr[X  (1 + )μ]  e− 2
2+ μ and Pr[X  (1 − )μ]  e− 2
2+ μ .

我们将带着链增长性质开始。

**定理 4.31** iSPoS协议满足链增长性质，带有参数 = 1 −
, s 2 N，遍及R位置的一个事件点，带有可能性至少1−exp(−
(2s)+lnR)，针对一个敌对的持有一个 − 部分，总的质押。

*证明* 定义Hama()称为事件，典型的字符串的汉明重量比例，对应位置[a, a + s − 1]，不超过.考虑到敌对的质押是 − ,k位置的每个有可能性 − ，被分配给敌对方，隐藏可能性，汉明质量大于s，在s中以指数方式降低。特别地，用Chernoff限制的累积的版本，我们有Pr[¬Hama()]  exp(−22s).它遵循：

Pr[Ham]  1 − exp(−22s) .

考虑到上述我们知道，当Ham发生，将有至少(1 − )s诚实的位置，在S循环期间。考虑到每个诚实的位置，使得一个诚实的方可以去生成一个区块，所有的诚实的参与方会前进，通过至少许多区块。使用一个联盟限制，它遵循速度系数，可以被设置未 = (1 − )，它被满足带有带有可能性，至少1 − exp(−22s + ln(R)).

已经建立了链增长，我们现在把我们的注意力转向链质量。回忆链质量性质，带有参数μ 和 `，主张，每一个`连环的区块，在链中（由诚实的用户拥有），敌对发的区块的部分不超过μ.

**定理 4.32** 让 − 称为敌对的质量率。iSPoS协议满足链质量属性。带有参数μ( − ) = /(1 − )，并且` 2 N，遍及R位置的每个时间点，至少带有可能性

1 − exp􀀀
−
(2`) + lnR

.

**证明** 第一，从对于链增长的证明（定理4.31），我们知道带有高可能性，`循环的部分将设计(1−)`位置，带有诚实的领导者；因此，结果的链必须增长，通过至少(1−)`区块。通过类似的推理，敌对方和不超过`位置关联，因此能够贡献不超过`区块，到任何特定的链，在这个期间。它遵循关联的链，由任何诚实的参与方拥有，包含敌对区块的部分/(1 − )，带有可能性1−exp(−
(2 min(, 1−)`)+lnR).

**5. 我们的协议：动态的质押**

**5.1 用一个可信任的信号浮标**

在前面的章节中协议的静态的版本，我们假定质押是静态的，在整个执行期间（例如，一个时间点），意味着质押改变手，在一个给定的时间点。不影响领导者的选择。现在，我们提出一个协议SPoS的修改，能后被执行，在多个事件点，以这样的方式，每个时间点的领导者选择过程是被参数，通过质押分布，在之前的时间点的一个特定的指定的点，允许在质押分中的质押，跨域事件点，去影响领导者选择过程。如之前，我们建造协议，以一个混合的方式，增强FD,F理想的功能到现在提供不可测性和辅助的信息，对于领导者选择过程，遍及所有时间点（增加的功能被称作FD,F
DLS).）我们然后讨论如何去实施FD,F
DLS，仅仅用FD,F，并且在这个方式减少假设，回到简单的普通的随机的字符串，在设置利选择的。

在描述对于动态质押的情况的协议之前，我们需要解释FD,F的修改，所以多个时间点是被考虑的。结果的功能FD,F
DLS,允许利益相关者去查询它，对于领导选择数据，针对每个时间点。FD,F
DLS通过每个利益相关者的最初的质押的参数表示，在第一个时间点e1开始时；在随后的时间中，参与方会考虑到质押分布，在之前的时间点的第一的R − 2k位置的最近的区块。考虑到没有利益相关者分布的预先决定的视角，函数FD,F
DLS将仅提供一个随机的字符串，将离开解释，根据利益相关者分布，到参与方，调用它。有效的利益相关者分布时序列S1, S2, . . .，定义如下：S1是最初的利益相关者分布；对于位置{(j − 1)R + 1, . . . , jR}，对于j  2，有效的利益相关者Sj被质押分配决定，在最近的区块找到，带有时间戳，至多(j −1)R−2k,如果所有诚实的参与方同意它，或者未明确的，如果诚实的参与方未打成一直。函数FD,F
DLS被在图形10中定义。

功能FD,F

FD,F包含传播和私钥/交易功能，来自章节2，以公钥为参数，最初的（在时间点e1之前）利益相关者S0 = {(vk1, s01
), . . . , (vkn, s0
n)}分布D的分别的质押，和一个领导选择函数F.此外，FD,F
DLS操作如下：

- **创世块产生** 在从利益相关者Ui收到(genblock req,Ui)，它在那个消息上入函数FD,F
  LS [SIG]操作
- **签名私钥对生成** 它入函数FD,F
  LS [SIG].操作
- **时间点随意更新** 在从利益相关者Ui收到(epochrnd req,Ui, ej)，如果哟j  2是当前的时间点，FD,F
  DLS按如下进行。如果j没有被设置，FD,F
  DLS取样j   D，那么FD,F
  DLSf发送(epochrnd, j)给Ui.

我们现在描述协议DPoS，是SPoS的修改版本，更新它的创世块B0（并且因此领导选择过程），对于每个新的实践点。协议也采用静态maxvalidS函数的改编本，定义，所以它使选择变窄，到这些链，共享普通的前缀。特别的，它采用了如下的规则，用前缀长度k为参数：

函数maxvalid(C,C).返回最长的链，从C [ {C}，不从C分叉，超过k区块。如果多重的存在，它返回C，如果它是他们中的一个，或者它返回在C中列举处的。

协议 DPoS在图形11中描述，并且函数在FD,F
DLS混合模型。

**备注1** 对maxvalid(·)的修改不偏离超过k区块，从最后被拥有的链，要求利益相关者至少没K个位置在线。规则的关联来自事实，当质押随着时间变换， 它将是可行的，对于敌对方去腐败利益相关者，被用来拥有一个质押大多数，在某一时刻，不触发Bad1/2，因此任何被产生的敌对的链，由于这样一个时间被拒绝。它没有任何价值，这个限制可以被容易的移除，如果一个人能够信任诚实的利益相关者，去安全的擦除他们的记忆。在这个情况下，一个向前的安全的签名可以被采用去挫败任何过去的腐败尝试，试图包围Bad1/2.

协议 DPoS

DPoS是一个由一组利益相关者运行的，最初等于U1, . . . ,Un,和FD,F
DLS交互，在一个L slots S = {sl1, . . . , slL}. DPoS的序列，运行如下：

1. **初始化** 利益相关者Ui 2 {U1, . . . ,Un},从私钥登记界面收到它的公钥和私钥。然后它从传播界面收到当前的位置，在情况，它是sl1，它发送genblock req,Ui)到FD,F
   LS ,收到(genblock, S0, , F)作为答案。Ui设置本地区块链C = B0 = (S0, )和它的初始化内部的状态st = H(B0).否则，它受到来自钥登记界面，最初的链C，设置本地的区块链作为C，和最初的内部的状态st = H(head(C)).

2. **链扩展** 对于每个位置sl 2 S，每个在线的利益相关者Ui执行如下的步骤：

   (a) 如果一个新的时间点ej ,带有j  2,开始了，Ui定义Sj为利益相关者分布，提取自最近的区块，带有小于jR − 2k的时间戳，正如在C中反映的，并且发送(epochrnd req,Ui, ej)到FD,F
   LS ,收到(epochrnd, j)作为答案。

   (b) 收集所有的有效的链，通过广播进集合C收到，验证，对于每个链C0 2 C和每个区块B0 = (st0, d0, sl0, 0) 2 C0，它保持Vrfvk0 (0, (st0, d0, sl0)) = 1,vk0是利益相关者U0 = F(Sj0 , j0
   , sl0) withd的验证钥匙，带有ej0称为时间点，位置B0属于（如由sl0决定）。Ui计算C0 = maxvalid(C,C),设置C0作为新的本地链，并且设置状态st = H(head(C0)).

   (c) 如果Ui是位置领导，由在当前时间点ej中的F(Sj , j , sl)决定，它产生一个新的区块B = (st, d, sl, )，st是当前状态，d 2 {0, 1}是数据， = Signski (st, d, sl)是在(st, d, sl)上的签名。Ui计算C0 = C|B,广播C0，设置C0作为新的本地链，并且设置状态st = H(head(C0)).

   3. **交易生成** 如在协议SPoS.中

**5.2 模仿一个可信的灯塔**

当协议DPoS处理多样的时间点，考虑到在质押分布种的改变，它仍然依赖FD,F
DLS去执行领导选择过程。在这个章节，我们战时如何实施FD,F
DLS，通过协议DLS,允许利益相关者去计算随意和辅助的必要信息，在领导选择种是必要的。

回忆，仅仅必要的不同，在FD,F和FD,F
DLS之间，是对于时间点e2, e3,，随机字符串2, 3, . . .连续的沈城。这个想法是简单的，协议DLS将用一个硬币抖动协议，去生成公正的随机，可以被用来定义值j ,j  2在最初的随机字符串和最初的诚实的利益相关者分布上启动。但是，至于敌对放会导致一个简单的硬币抖动协议失败，通过中止。因此，我们建立一个硬币抖动计划，带有“保证的输出交付”

在图形13中描述的协议DLS，使用一个公开的可检验的秘密分享（PVSS）

当在静态的质押情况，我们需要定义一个理想化的协议，行为犹如在真实协议中被采用的计算上的安全原始行为很好。再一次，我们将基于我们组合的论证，在这个理想化的版本上。我们注意我们离开iSPoS，如之前定义的，增加进一步的考虑，关于硬币抖动进程的理想的执行，生成对于领导选择过程的不可测性。我们使用的关于PVSS计划的假设是，作为结果的掷硬币的协议模仿一个完美的灯塔，带有区分优点。这个理的模拟是，在诚实大多数的情况下，有一个模拟器，和敌对方相互影响，生成不能区分的协议副本，当考虑到灯塔价值，在承诺阶段之后。我们注意使用【39】作为PVSS，一个模拟器能够完成模拟，在随机的语言模型，通过利用预言的可编程性。尽管使用一个随机的预言及时绝非必要。相同好处可以用过嵌入到创世块里的CRS获得。

**承诺和硬币抖动** 一个硬币抖动协议允许两方或者多方去获得一个一致的随机字符串，一个传统的方式去构建这样一个协议是通过使用承诺计划。在一个承诺计划里，一个提交者执行一个承诺时期没发送一个给定价值的证据到一个接受者，不需要显示它。后来，在一个开启相位，承诺者可以发送那个价值到接受者，使确信价值和在承诺阶段承诺的价值是完全一样的。这样的一个计划被称为捆绑，如果对于承诺者难以说服接收者，它被交付任意价值，除了它在承诺阶段发送的证据，它被称作捆绑，如果对于接受者很难认识到关于价值的任何东西，在打开阶段之前。我们用随机r来表示承诺阶段，消息m,通过Com(r,m)，开始为Open(r,m).

在一个标准的双方硬币抖动协议，一方通过取样另外一个一致地随机字符串u1和发送Com(r, u1)开始。然后，其他方发送Open(r, u1)，两方都计算输出u = u1  u2.注意，但是，在这个传统的协议，承诺者可能有选择地去“中止”这个协议（通过不打开承诺），一旦它观察到值u2.当这是一个两方设置的固有的问题。我们能够在多方设置里通过依赖可正式的秘密分享计划来避免这个问题，在协议参与者当中的诚实的大多数。

**可检验的秘密分享（VSS）** 一个迷你的分享计划允许一个经销商PD去分离一个秘密到n分享，到参与方P1, . . . , Pn，如此以致没有敌对方腐败直到t参与方能够恢复.在一个可验证的秘密的分享（VSS）计划，有一个额外的保障，诚实的参与方可以恢复，及时敌对方腐败了由参与方持有的分享，它控制，即使经销商本身是恶意的。我们定义一个VSS计划为一对有效的处理和重建算法（Deal,Rec）。处理算法Deal(n, )作为输入，分享的数字被生成n,和秘密一起，输出分享1, . . . , n.重建算法Rec作为输入分享1, . . . , n和输出秘密，只要不超过t分享被腐败（难以获得的分享被设置到?，经过考虑被腐败的）。Schoenmakers开发了一个简单的VSS计划，基于离散的算法，适合我们的目的。

**创建协议**  DLS。需要解决的主要问题，当意识到FD,F
DLS带有一个协议，由利益相关者运行，是生成统一的随机性，对于领导选择过程，当忍受敌对方，可能试图干涉，通过中止或者提供不正确的信息给参与方。为了生成统一的随机性j，对于位置，j  2,选择的利益相关者，对于时间点将采用一个硬币抖动计划，对于所有诚实的参与方，被保证去接受输出，只要有一个诚实的大多数。协议有两个阶段，发表意见和显示，被分解进阶段里。协议的阶段在图形12中展现。承诺阶段覆盖所有的承诺阶段，进行如下：对于1  i  n，利益相关者Ui取样一个一致的随机字符串ui 2 {0, 1}Rlog 和不可测性ri，对于潜在的承诺计划，生成分享i1
, . . . , in，并且公布Com(ri, ui)到区块链到区块链，和所有的分享的加密一起，在每个分别的利益相关者的公钥下。在4k位置后，选手移除他们链的l最近的区块，如果承诺来自利益相关者的大多数，发布在区块链上，从利益相关者大多数被接受，显示阶段开始（在其他情况，协议停止），在显示阶段，有两个阶段：显示阶段和恢复阶段。在显示阶段，对于1  i  n,利益相关者Ui发布Open(ri, ui)到区块链。在4k位置后，选手移除最近的k区块，识别所有的利益相关者，发布形式Open(ri, ui)的开头。在最后的恢复阶段，持续的2k位置，如果利益相关者Ua，最初提交一个承诺，被识别作为不是发布一个开头到它的承诺，诚实的节点能发布所有的分享a1 , . . . , an
in，为了用Rec(a1 , . . . , an
)去重建ua。最后，每个利益相关者适用值ui，从第二个循环获得的，去计算j = P
i ui.协议DLS在图形13中描述。我们主义不可能平行地去运行显示和恢复阶段，但是，为了改良的效力，我们选择循序的运行他们

**5.3 强健的交易账簿**

我们现在准备好去陈述这一张的主要结果，建立DPOS协议，带有协议DLS，作为一个子例行程序实施一个强奸的交易账簿，在我们假定的环境情况下。回忆，在动态质押情况下，我们必须去确保，敌对方不能开发质押随着时间改变的方式，腐败了一组利益相关者，将会使得在一个时间点，利益相关者的被选择的委员会的大多数的控制称为可能。为了去夺得在质押“转换”的从属物，我们引入如下性质。

**定义 5.1** 考虑两个位置sl1, sl2和一个执行E。质押在sl1和sl2之间转换时两个质押权重的最大的可能的统计距离，被定义，适用在链C1中反映的质押，一些诚实的利益相关者，在sl1和链c2上活跃，一些诚实的利益相关者活跃，在sl2，分别地。

考虑到上述定义，我们现在陈述如下定理

**定义 5.2** 固定参数k,R,L 2 N, ,  2 (0, 1).让R = 10k成为时间点长度，L系统的总寿命。假定敌对方被限制于1−
2 − 相关的质押，并且，SPOS协议满足普通的前缀性质，带有参数R, k和错误CP的可能性，链质量性质，带有参数μ  1/k, k，错误CQ的可能性，和链增长属性，带有参数  1/2,和错误CG的可能性。除外，假定DLS模仿一个完美的灯塔，带有有区别的优点DLS。

然后DPOS协议满足持续，带有参数k，和活跃度，带有参数u = 2k，遍及L位置的期间（或者Bad1/2发生），带有可能性1−(L/R)(CQ+CP+CG+
DLS)，假定是最大的质押转换，在10k位置的转换，腐败延迟D  2R − 4k，没有诚实的选手离线，对于超过k位置。

协议DLS

DLS是一个由被选举出的利益相关者的子集运行的，每个对应一个位置，在一个时间店ej，持续R = 10k位置，不带有表示为U1, . . . ,UR的普遍性损失（不是必须的有区分的），并且承担下列阶段：

1. **承诺阶段** (4k位置) 当时间点ej开始，对于1  i  n,利益相关者Ui抽样一个统一的随机字符串和不可测性ri，对于潜在的承诺计划，生成分享i1
   , . . . , in
     Deal(n, ui),同时，把每个分享ik加密，在利益相关者Uk’s的公钥。最后，Ui发布加密的分享和承诺Com(ri, ui)到区块链
2. **显示阶段**  (4k位置) 在位置4k后，对于1  i  n,利益相关者Ui打开它的承诺，通过发布Open(ri, ui) 到区块链，加入区块链包含有效的分享，来自U1, . . . ,UR的大多数；如果不是，每个Ui终止。
3. **恢复阶段** （2k位置）在位置8k之后，对于任何利益相关者Ua，没有参与到显示阶段，例如，没有在Cdk中发布一个Open(ra, ua)消息，对于1  i  R, U提交它的共享a
   i为了嵌入区块链。当所有分享a1 , . . . , an是存在的，每个利益相关者Ui能够计算Rec(a1 , . . . , an
   )去重建ua（独立的，是否Ua打开这个承诺）

epochrnd req的模拟然后如下：

- 考虑到输入(genblock req,Ui, ej , Sj ),利益相关者适用承诺价值，在区块链，去计算j = P
  l2L ul,当是利益相关者的子集，被在时间点ej选择。它返回(genblock,B0, Sj)，带有B0 = (Sj , j ).

证明 梗概 让我们首先考虑DPOS的执行，当FD,F
DLS被用来替代DLS.让BADr成为事件，三个性质CP,CQ, CG中任何违反，在循环r  1，当没有违反，他们的任何，先于r发生。很容易看到Pr[[rRBADr]  CQ+CP+CG.以这个事件的的否认为条件，我们可以重复论证，对于第二时间点，因为D  R，因此敌对方不能影响利益相关者选择，对于第二个时间点。他遵循Pr[[rLBADr]  (L/R)(CQ + CP + CG).现在容易看到持久性和活跃度持有条件作用，在上述事件的否定上：持久性的违反将违反普通的前缀。另一方面，活跃性的违反会违反链增长和链质量，对于规定的参数。

观察的上述结果将继续持有，及时FD,F
DLS被变弱去允许敌对方访问下一个时间点6k位置的的随机值，在时间点终点之前。

这是因为腐败延迟D  2R − 4k = 16k

最后，我们检查发生了什么，当FD,F
DLS被FD,F
LS替代，协议DLS的执行。考虑带有环境的执Z的执行，和敌对方A，和时间BAD，在执行中发生，带有一些可能性。我们建设一个敌对方A，在带有FD,F
DLS,的执行中操作，弱化如在之前的段落，包括时间BAD，带有粗略的相同的可能性A将操作如下：在第一个4k位置，他将用一个诚实的参与者去插入进区块链，诚实方的模拟的承诺。这是可行的，对于A，当在4k位置，链增长将导致区块链长，至少2k区块，因此在第一个k区块，由至少一个单个的诚实的被包含的区块。现在A将从FD,F
DLS获得，灯塔的值，他将穆尼所有承诺的开始，代表诚实的参与方。最后，在最后的2k位置，他将执行所有敌对方承诺的被迫的开头，不会被打开。协议模拟将被重复，对于每个时间点，定理的陈述如下：

**备注 2** 我们注意到易于扩展敌对方的模型去包括失败终止（和恢复）腐败，除了拜占庭腐败之外。混合的腐败设置的优点是，他是可行的去证明，我们能够容忍许多失败终止腐败（反复无常的高于50%），背后的直觉是简单的：分叉字符串分析仍然适用，即使位置领导者的任意比例被提供不活跃。仅仅的必要的条款，对于这个，将被扩展参数k,相反的成比例地，对于非停止的参与方的比率。我们省略进一步的细节。

**6. 匿名的沟通和更强的敌对方**

在上一章节创建的协议被证明安全，对于延迟的适应的腐败，意味着，在要求去腐败一个给定的参与方Ui之后，敌对方必须等D位置，在腐败实际发生之前。但是，是可取的，让D尽可能小，或者神农一起消除他去达成安全，对于一个标准的适应的敌对方。

延迟被要求，因为敌对方必须能够腐败参与方，一旦他知道，他们是位置领导者，对于给定的位置。但是，注意位置领导者被选择，通过变重公钥，通过质押，当敌对方仅仅能选择去腐败一个用户Ui，不需要知道它的公钥。因此，敌对方必须能够观察Ui和散开的函数之间的通信，为了决定哪个公钥和用户Ui有关联，探测到何时Ui被选择作为位置领导者。我们将战时我们消除延迟，通过扩展我们的模型，带有一个发送者匿名广播渠道（有分散的函数提供），有环境激活所有参与方，在每一个循环。我们一如如下修改，在理想的功能里。

- 弥散的功能：功能将会如章节2中描述的运行，除了它将移除关于每个信息发送者Us的信息，在发送给接受者Ur’的收件箱之前（输入胶带），因此确保发送者保持匿名
- 私钥和交易红能：功能会如章节2中描述的运行，吃了它将运行一个用户U的即可的腐败，在收到来自敌对方信息(Corrupt,U)之上

除了在理想功能中的这些修改，我们也改变了环境行为，通过要求它激活所有用户，在每一个位置slj 。让所有的参与方被激活，在每一个位置，导致一个尺寸的匿名设置，等于诚实的参与方的数量，使得其很难对于敌对方，联系一个给定的公钥，带有一个用户（例如，诚实参与方的任何人可以被联系到一个给定的公钥。不和腐败参与方关联）。在这个扩展的模型里，我们可以责备定理5.2,不带有延迟D，通过加强限制，被强加于环境，在如下方式：

- 我们将会说敌对方限制于不大于50%相关的质押对于长度D的窗口，如果对于长度D的连续的位置的的所有的集合，求和所有最大质押的腐败的私钥，有每个私钥持有，在D位置期间（在任何可能的Sj(r)，Uj是诚实的参与方），不超过最小总计质押的50%,在这个期间。在上述情况，被事件Bad1/2
  Dw欸饭，成为正确的，对于给定的质押。

使用上述加强的情况，我们可以移除腐败延迟要求D，在定理5.2，通过假定用Bad1/2
D .替代Bad1/2

**7. 动机**

到目前位置，我们的分析集中于用密码写的敌对方的设置，一组诚实的选手在敌对方在场的情况下操作。在这个章节，我们考虑理性选手的联合，和他们的动机去偏离诚实的协议操作。

**7.1 输入背书人**

为了提出激励，我们修改进一步我们基本的协议去分配两个不同的角色给利益相关者。如以前，在每个事件点，有一组被选举出来的利益相关者，运行安全的多方的掷硬币协议，是每个时间点的位置领导者。连同这些，有一个被称作背书人的利益相关者（不是必须打散）。现在每个位置有两种与之关联的利益相关者；位置领导者，发布区块如之前，并且，会背书输入的位置背书者会被包含进这个区块。而且，违反位置领导者，我们可以选举多个位置倍数这，对于每个位置，然而，不损失大部分的情况下，我们仅仅假定单个输入背书者，每个位置，在这个描述里。当它看上去像一个无关紧要的修改，它给我们一个改进的空间，因为下述原因：背书者的贡献会是可接受的，即使后面有d位置，d 2 N是一个参数。

注意，万一没有有效的背书者输入是存在的，当位置领导者将去发布区块，领导者将进行，并且发布一个空的区块，例如，一个区块，不带有任何实际的输入（例如，在交易账簿的情况下的交易）。注意位置背书者就像位置领导者，被选举出，通过质押考虑，因此，他们是一个典型的利益相关者总体的样本。在交易账簿的情况下，相同的交易可能被包含，通过许多输入背书者同时地。假使交易是一个多样的存在在区块链里，它的第一个出现将是它的“经典的”位置，在账簿里。增强的协议，DPOSwE，易于被视为有相同的持续和活跃性行为，如DPOS：带有背书人的修改不提供任何可能性，对于敌对方，去组织链增长，接受输入，或者称为持续的。但是，如果我们衡量链质量，按照包含的背书的输入的数量，这生成一个更加良好的结果：易于看到背书输入的数量，由一组利益相关者S引起，在任何链的k-长度部分，和相关的S的质押成比例，带有高的可能性。这起源于这个事实，它足够，单个诚实的区块未所有的背书的输入创建，最后的D位置的，去被包含进去。假定d  2k，利益相关者S的集合将称为背书者，在d位置的一个子集，带有可能性，和累积的质押成比例，因此结果如下。

如在BITCOIN中，发布区块的利益相关者被激励去参与协议，通过收集交易费。与bitcoin相反，当然，一个人不需要去以物质激励利益相关者去投入计算资源去发布区块。准确的说，可永兴和交易验证需要被激励。然而。他们必须被激励去经常在线。任何利益相关者，至少，必须在线和在如下情况下可操作

- 在位置，在一个位置之前，它是选举出来的利益相关者，所以，它查询网络，病获得当前的长期的区块链，和任何背书的输入，去包含进这个区块。
- 在这个位置，在这个期间，它被选举的利益相关者，因此它发布区块，包含背书的输入
- 在一个位置，在承诺期间，一个时间点，它被认为去发布VSS承诺，它的随机的字符串
- 在一个位置，在一个时间点的显示期间，它应该发布要求的开始的分享，和开始到它的承诺
- 总之，在足够的频率。去检查它是否是一个被选举出的利益相关者，对于下一个或当前的时间点
- 在一个位置，在期间，它是被选举出的输入背书者，因此，它发布背书的输入（例如，交易集），需要处理所以存在的交易，并且验证他们。

为了激励上述行动，在交易账簿的设置里，费用会被收集，从这些发布的交易去被包括进账簿，然后被转移到去区块发布者。在bitcoin,例如，费用能够被生交易区块的矿工收集，作为奖励。在我们的设置里，类似地，一个奖励可以被给到参与方，正在发布区块和背书输入的。奖励机制不必须是区块依靠的，在【34】中体长的。在我们的设置里，能够收集所有的交易费，包含金区块的序列里，在一个矿池里，然后分配那个矿池到所有的利益相关者，在这些位置期间参与的。例如，所有活跃的输入背书者可能收到奖励，和在循环期间，他们背书的输入的数量成比例（与他们背书的交易的实际数量的无关）。分配交易费用的其他方式实也是可行的（包括那个被bitcoin本身使用的-即使bitcoin方式被知道是脆弱的，对于攻击，例如，自我挖矿攻击）

奖励机制，我们将和输入背书者配对，操作如下。第一，我们设置背书的接受窗口d to be d = 2k，让C称为一个包含区块B0,B1, . . ..的窗口，考虑区块的序列。覆盖j-th时间点，用B1, . . . ,Bs表示，带有时间戳在{jR + 1, . . . , (j + 1)R + 2k}，包含一个r  0序列，背书的输入，来源于j-th时间点（当中的一些可能被包含作为j + 1的一部分）。我们定义总奖励池PR等于交易费用的总和，被包含进背书的的输入，对应j-th时间点。如果一个交易发生多次（作为不同背书的输入的一部分）或者甚至在冲突的版本，仅仅交易发生的第一次被考虑（并且被考虑未账簿的部分，在那个位置），在P的计算重，使用的总的订单被顺序包含，背书的输入，被包含进C。按照这些区块的次序，我们通过L1, . . . ,LR确定，位置领导者，对应时间点的位置，通过E1, . . . ,Er，输入背书者，贡献r背书的输入序列。随后，i-th利益相关者Ui能够索取一个奖励，相当于金额( · |{j | Ui = Ej}|/r +(1−) · |{j | Ui = Lj}|/R)P where  2 [0, 1].通过在4k后发布一个在任何时候的交易的“coinbase”类型来执行，在随后的时间点，到这个，一个奖励被索赔。

观察到上述奖励机制有下述特点：（i）他奖励选举委员会尘谷氨，对于仅仅称为委员会成员，和他们是否发布一个区块无关，(ii)他奖励输入背书者，带有输入，被贡献。（iii）他奖励实体，对于时间点j，在位置jR + 4k后。

我们继续战时我们的系统是一个-Nash（近似的）均衡，cf. [31,章节2.6.6].特别地，定理陈述任何从协议中脱离的结合，可以增加至多一个添加物到他的总奖励。他们拥有的质押不随着时间转变，协议有微不足道的成本去被执行。我们观察到总奖励（因此也实用的，通过我们的假设，在协议成本上）任何诚实选手的联合V可以从执行中提取，持续L = tR + 4k + 1 slots,等于：

RV (E) =
Xt
j=1
P
(j)
all


IEj
V (E)
R
+ (1 − )SLj
V (E)
rj
!
for

对于任何执行E，普通前缀带有参数k,rj是总的背书的输入，在j-th时间点发出（可能被包含，在任何时间，到第一个2k时间点的位置j + 1),，P
(j)是时间点j,的奖励吃，SLj
V (E)是V的会员被选举称为位置领导者的次数的数量，在时间点，IEj
V (E)，V的会员的次数被选择去背书一个输入，在时间点j.

在上述规划中的一个技术困难是选手的数量，他们相关的质押，和他们收到的奖励一样，基于交易，在协议执行本省的过程中生成。为了简化这个分析，我们将考虑一个二设置，选手的数量是静态的，

观察到实际的奖励，从一组理性的选手V中获的，在执行E中，可能不同于RV (E);例如V的联合可能从不背书一组输入，他们将获得更少数量的奖励。此外，观察到我们让RV (E)的值出于未定义，当E是一个执行，普通的前缀失败：他将使得考虑这个值是合理的，对于这样的执行，因为诚实参与方的协议的视角是有分歧的。然而，他不会影响到我们总的分析，因为这样的执行将发生，带有充足的小的可能性。

我们将建立这个事实，我们的协议是一个-纳什均衡，通过i哦证明联合V，甚至脱离合适的协议行为，他不能获得效用，超过RV (E)+，对于一些合适的常数 > 0.

**定理 7.1** 确定任何 > 0;协议中诚实的策略是一个-纳什均衡，针对任何联合命令一定笔录的质押，少于(1 − )/2 − ，对于一些常数,  2 (0, 1)，如在定理5.2,加入最大的总奖励Pall，在所有的可能的协议执行中提供的，被在中的多项式限制，当CQ + CP + CG + DLS在中是微不足道的。

证明梗概。 考虑离职的选手V的联合，限制如在定理的陈述中，参与协议执行，连同许多其他选手，忠实地遵循协议，对于L时间点的总数。我们将展示任何与协议的偏差，不会导致大体上较高的奖励，对于V。观察到基于定理5.2，不论V的策略怎样，带有可能性1 − (L/R)(CQ + CP + CG)，这个协议将会使得所有用户去获得奖励，他们被授权有资格称为位置领导者和输入背书者。后者起源于下面的。第一，来自才继续和活跃性，至少一个诚实的区块将被包含，每个K区块，因此，在每个时间点，所有的遵循这个协议的输入被试者，将有机会成熟输入背书者，和他们被选举的次数一样多的次数。第二，收到的奖励江河每个方是一个输入背书者的次数成比例，成功地发布一个区块，也他是位置领导者的次数相等。我们观察到除了带有可能性(L/R)(CQ+CP+CG)，通过联合收到的使用，等于RV .他遵循选手V预期效用至多E[RV ] + (L/R)(CQ + CP + CG)PAll,当PAll是奖励的最大数额，在所有可能的执行的寿命里产生的。结果遵循，通过在定理陈述中的假设，因为(L/R)(CQ + CP + CG)PAll  .

**注意 3**  在上述定理中，为简单起见，我们假定协议成本部影响最后的效用（其实这以上为着协议成本被假定为微不足道的）。然而，简单的去扩展证明去覆盖一个设置，一个负的属于被介绍，在结算函数，对于每个选手，和输入的次数成比例，被背书，对于MPC协议，传输的消息的数量，这个证明对这些修改是有叹息给的，因为背书的输入和MPC协议消息不能被敌对方扼杀。因此奖励函数可以被设置带有合适的重要性，对于这样的行为，抵消他们的成本，仍然注意提供的奖励被假定为“平的”，对于位置和背书的输入，因此成本也必须是平的。我们动身去未来的工作，一个更加精确的设置的调查研究，成本和奖励和实际计算步骤成比例，被需要去验证交易和发布区块

**注意 4** 描述的奖励函数，仅仅考虑一个实体成为输入背书者的次数，不考虑工作的数量，被应用去验证给定的交易。除外，不敏感的，是否一个位置领导者发布一个区块，在他分配的时间位置。我们下一个提供一些环境，在这些选择之后。首先假定位置领导者不会受到奖励，当他们不发布一个区块。容易看到当所有的参与方遵循这个协议，参与方将收到部分，从奖励池，和区块发布关联，大体上和他们的质押成比例。然而，一个恶意的联合能容易地增加奖励的比例，同执行一个区块扣缴税款攻击（在这个情况，这将相当于一个自私的挖矿攻击）。考虑到这发生，带有不可忽视的可能性，RV (E)的一个简单的定义，尊重这个安排是脆弱的去攻击，因此一个纳什均衡定理不能被展示。下一个，我们考虑扩展奖励函数的情况，因此输入背书者，被奖励，记忆他们验证的交易（与我们在上述定理考虑的平奖励相反）。特别的关怀是必要的去设计这个函数。实际上，简单的方式去实施他，如果第一个输入背书这去验证一个交易，是池子的一部分，制造一个更高的索取他的费用，然后，有一个策略，对于一个敌对方去偏离协议，改进奖励的比例：执行区块扣缴税款，和/或背书输入审查制度，去移除背书的输入，来自区块链，引起诚实的参与方。然后包含移除的交易，在背书的输入，将会被传输，在最后的可能的机会。如之前，考虑到攻击，定义RV (E)的自然的方式是对他易受影响的，因此一个纳什均衡定理不能被展示。

去改在备注3中提出的问题的可能方向是，分享交易费，在所有输入背书它的输入背书者。这意味着如下对于协议的修改：不管何时，你是一个输入背书者，你应该尝试包含所有交易，你已经收集，对于一系列的k位置，转播你背书的输入，在它从主链中被移除的情况。我们留下奖励机制的这样的种类的分析作为未来的工作。

**8 质押授权**

如之前的章节所讨论的，利益相关者必须在线，为了生成区块，当他们被选择成为位置领导者。但是，者可能对于利益相关者是没有吸引力的，带有一个小的质押在系统里。此外，要求选举出的利益相关者的大多数参与掷硬币协议，对于更新随机性，介绍一个负担，在利益相关者和网络上，因为它可能需要广播和存储大量承诺和分享。

我们减轻这个问题，通过提供对于减少利益相关者组的尺寸的方法，参与掷硬币协议。而不是，被选举的利益相关者，直接形成委员会，将运行掷硬币，一组代表将代表他们的利益行动。更多详情，我们提出一个委托计划，利益相关者授权其他实体。称作代表，可能成为利益相关者自己，去在掷硬币协议中代表他们。一个代表可能参与协议，只有在它代表一定数量的利益相关者，它的总计质押超过给定的门槛。这样的参与门槛确保“存储残片“攻击，目标是增加代表人数，为了伤害协议的执行，不能遭受一个大的处罚，因为它能够迫使委员会的尺寸，运行协议成为小的（没有任何价值，委托机制类似于矿池，在POW的区块链协议）

**8.1 最小委员会尺寸**

欣赏委托的好处，回忆在基础协议(DPoS)，一个委员会成员有质押权重选出的，带有可能性1/2 +  (这个成为诚实的选手持有的质押的部分），因此，诚实选手的数量，有k调用选择的，质押权重，是二项式分布。我们对恶意的大多数可能性感兴趣，右Chernoff限制直接控制。特别地，如果我们让Y成为次数，一个恶意委员会城北被选举，那么

Pr[Y  k/2] = Pr[Y  (1 + )(1/2 − )k]
 exp(−min{2, }(1/2 − )k/4)
< exp(−2(1/2 − )k/4)
for 

对于 = 2/(1 − 2).假定 < 1/4，它遵循 < 1.

考虑情况 = 0.05，那么我们右限制exp(−0.00138 · k)，提供1/1000的错误，只要k  5000。类似地，在情况 = 0.1，我们有限制exp(−0.00625k)，提供相同的错误，对于k  1100.

我们观察到，为了抵挡一个时间点的重要数量，不如215（如果我们让一个阶段等于一天，将是88年），需要错误可能性2−40，我们需要k  32648.

在情况，系统中的财富不是集中于以小组利益相者，上述选择限制于一个大的委员会（当然， 委员会的最大尺寸是k）

**8.2 委托计划**

委托的概念是简单的：任何利益相关者运行一个代表去生成区块，代表她的利益。在我们的协议的背景下，这样的计划能给一一个简单的方式实施，基于代理人签名。

一个利益相关者可以转让生成区块的权利，通过创建代理人签名私钥，允许委员去签署形式(st, d, slj)的消息（例如，消息的形式签署到协议DPoS中去证明区块是真实的）。为了限制代表的区块生成力量，也在一定的时间点/位置范围，利益相关者能够限制代理签署私钥的有效信息空间到自负床以位置数量slj结束。在特定的值的范围内。代表能用一个 代理签署私钥，来自一个给定的利益相关者去简单地运行协议DPoS，以她的利益。签署区块，这个利益相关者被选举去生成带有代理签署密钥。

这个简单的计划是安全的，由于可验证和滥用代理签名计划性质的预防，确保任何利益相关者能够验证一个代理签名密钥，实际上由特定的利益相关者发布，到一个特定的委托人，这个委托仅仅适用这些密钥签署信息，在密钥的有效信息空间里，分别地。我们注意到当代理签名被描述为高层的一般的原始人，容易建设这样的计划，从标准数字签名计划，通过代理委托，【10】中所显示的。在这个建设里，利益相关者，签署一个证件，指定代表身份（例如，它的公钥），有效的信息空间。稍后，代表能够在有效信息空间内签署消息，通过为这些消息提供签名，在它的自己的密钥，和它签署的证书一起。作为一个增加的邮件，代理签名计划也能够从合计的签名中建设，在这样一个方式，签名在代理签署密钥下生成，有必要的，和常规签名【10】一样的尺寸。

在上述设置里一个重要的开了是事实，一个利益相关者可能会撤回它的支持，到一个利益相关者，在代理签署密钥过期之前。观察到代理签署密钥能够被独特地识别出，因此，他们可能被撤回，通过一个证件撤回列表，在区块链内。

**8.2.1 合格门槛**

如上描述的委托可以改善存储残片，但是可能发生在质押分布。然而，者不阻止恶意的利益相关者去分隔它的质押到多个账户。通过从委托制止，引起一个非常大的委员会尺寸。为了解决这个，如上所述，门槛T，1%可能被申请。这意味着任何代表，代表小于一个部分，小于总质押的T，自动地被禁止成为一个委员会成员。这个可以被促进，通过重新分贝代表投票权，代表小于T，到其他代表，在确定性的方式（例如，从这些开始，带有最高的质押，破坏链接，根据字典编辑的顺序）。假设一个委员会被成立，C1, . . . ,Cm,来自k抽签的总数，通过质押权重。每个委员会成员将持有ki，这样的投票Pmi
=1 ki = k.基于上述合格门槛，它遵循m  T−1（最大的值是情况，所有的质押在T−1中分布，代表每个质押的T的持有）

**9. 攻击讨论**

我们下一个讨论许多实际的攻击和，显示他们是如何被影响，通过我们的建模和缓和的。

**双花攻击** 在双花攻击里，敌对方希望去恢复一个被网络确认的交易。攻击的目标是去发布一个交易。例如，从敌对方账户持有到受害人接收者的支付，有被确认的交易，然后恢复这个交易，通过，例如，包含一个账户一秒冲突交易。这样的交易不是可行的，在定理5.2的情况下。的确，持续确保一旦交易被诚实的选手确认，所有其他诚实的选手，来自那个点，将从来不同意，关于这个交易。因此，它将不可能去带有这个系统去一个状态，确认的交易是无效的（假定所有的定理的前提持有）。看下一个章节，对于实验的讨论，关于双花.

**无休止的攻击** 在质押无休止攻击，敌对方试图影响位置领导者选择过程去提高他被选择去生成区块的机会（可以用来执行其他攻击，比如双花）。基本上，当生成一个区块，被位置领导选择过程作为输入，敌对方首先测试若干可能区块头和内容，为了找到一个，给它最好的机会在未来被选择成为位置领导者。当这个攻击基于PoS的加密货币，收集随机性，对于位置领导选择过程，来自区块链本身的原始数据（例如，另外子区块头和内容），我们的协议使用一个标准的掷硬币协议，被证明去生成一个无偏见的统一的不可测性，如在章节5.2中讨论的。我们显示，敌对方不能一项在图形13中形成的不可测性，被保证是一致的随机的，因此保证位领导者被选举，带有和他们质押成比例的的可能性。

**交易拒绝攻击** 在一个交易拒绝攻击里，敌对方希望阻止特定的交易被确认。例如，敌对方可能想把一个特定的账户作为目标，阻止账户持有者去发布一个流出交易。这样一个攻击在定理5.2的情况下不是可行的。实际上，活跃性确保，假如交易被常识去插入，对于足够数量的位置，通过网络，它最终会被确认。

**去同步化攻击** 在一个去同步化攻击力，利益相关者表现诚实的，但是然而不能正确的同步，带有网络的剩余部分。这导致区块的不合事宜的发布，并且离线，在这个期间，当利益相关者应该参与。这样的攻击可以被安装，通过阻止参与方访问一个时间服务器，或者其他机制，允许参与方之间同步。此外，一个去同步化可能也发生，由于极其长的延迟，在消息传递中，我们的模型允许参与方去成为去同步的，通过包含他们到敌对方力，没有活跃性和持久性的保证被提供，对于去同步化的参与方，因此，我们可以变得安全，只要参与方带有少于50%的质押变得去同步化。如果超过参与方变得去同步化，我们的协议能失败。更普遍的模型，像局部同步，有趣的去在PoS设计设置中考虑。

**日食攻击** 在一个日食攻击，消息传递到利益相关被，被妨碍，由于一个破坏，在点对点的传递机制上。当在这个去同步化攻击的情况，我们的模型允许参与方去成为日食，通过包含他们到敌对方，被狗估计。没有活跃性和持续性的确认被提供给这样的参与方。

**51%攻击** 一个51%攻击发生不管何时敌对方控制超过系统中质押的大多数。容易看到位置的任何序列，在这样的情况，带有非常高的分叉可能性，因此，一旦系统找到它自己，在这样的设置力，诚实的利益相关者可能被防止到不同的分叉力，对于长的时间期间。持续性和活跃两者能够被妨碍。

**贿赂攻击** 在贿赂攻击，敌对方故意地支付矿工（通过加密货币或法币），去在特地的区块和分叉上工作，目标是生成任意的对敌对方有利的分叉（例如，通过支持一个双花攻击）。基于POW的加密货币的矿工不必须先拥有自己的质押，为了挖矿区块，这使得这个攻击策略可行。在这个设置力，如果敌对方提供一个高于正确地生成一个区块的奖励的贿赂，任何理性的矿工有一个清楚的动机去接受回落，并参与攻击，因为这增加了矿工的财务成过。但是，在我们基于PoS的协议，恶意的位置领导者，同意故意地攻击这个系统，不仅冒险去放弃任何他们的利益，他们能挣到的，从西瓜味诚实中，有可能冒险失去抵押资质的净值。注意位置领导者必须有投入到系统中的钱，为了能够生成区块，如果一个针对系统的攻击，被观察到，它可能使得货币价值下降。如果贿赂高于正确行为的奖励，货币贬值的损失能容易地抵消通过参与攻击获得的额外的利润。因此，贿赂攻击可能不那么有效，针对基于PoS的共识协议，相比基于POW的协议。当前，我们的合理性模型没有正式的包含这个攻击策略，调查它的效力，针对基于PoS的共识协议，被留作未来的工作

Long-range attacks An attacker who wishes to double spend at a later point in time can mount
a long-range attack [12] by computing a longer valid chain that starts right after the genesis block
where it is the single stakeholder actively participating in the protocol. Even if this attacker
owns a small fraction of the total stake, it can locally compute this chain generating only the
blocks for slots where it is elected the slot leader and keep generating blocks ahead of current
time until its alternative chain has more blocks than the main chain. Now, the attacker can post
a transaction to the main chain, wait for it to be confirmed (and for goods to be delivered in
exchange for the transaction) and present the longer alternative chain to invalidate its previously
confirmed transaction. This attack is ineffective against Ouroboros for two reasons: Protocol DLS
will only output valid leader selection data allowing for the protocol to continue if a majority of
the stakeholders participate (or have delegates participate on their behalf) and stakeholders will
reject blocks generated for slots that are far ahead of time. Since the alternative chain is generated
artificially with blocks and protocol messages generated solely by an attacker who controls a small
fraction of the stake the leader selection data needed to start new epochs will be considered invalid
by other nodes. Even if the attacker could find a strategy to generate an alternative chain with
valid leader selection data, presenting this chain and its blocks generated at slots that are far ahead
of time would not result in a successful attack since those







