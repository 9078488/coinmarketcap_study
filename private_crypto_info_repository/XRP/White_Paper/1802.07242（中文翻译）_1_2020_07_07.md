# XRP账簿共识协议分析

Brad Chase         Ethan MacBrough

Ripple研究

{bchase,emacbrough}@ripple.com

2018年2月21日

**摘要**

XRP账簿共识协议是之前发展的支持XRP账簿的共识协议。它是一个低延迟的拜占庭一致协议，能够在不需要网络成员节点全部一致的情况下达成共识。我们展示一个详细的解释，得益于算法和它的安全性和活跃度的源情况。

**1. 介绍**

XRP账簿是一个分布式支付系统，可以使得用户在世界范围内无缝的传送价值。作为运行在一个分布式点对点的网络中，XRP账簿和在防治资金双花和确保网络范围共识基于用户账户和余额的状态一样由相同的挑战。第一，Schwartz et al提出和实施的，XRP底层算法统拜占庭错误容忍一致协议而不是共同信任的子网络的算法，被称为XRP账簿共识协议或者缩写为XRP LCP.

理论上，XRO账簿网络是一个重复的状态机器。这个重复的状态是由网络中每个节点维护的账簿和由网络中客户提交的对应交易的状态交易。一旦节点同意交易集应用到状态，一个交易处理协议制定确定的用于在每个集里排序交易的规则，和如何应用交易去生成新的账簿状态。因此，XRP LCP的作用仅仅是使得网络在交易集上达成一致，而不针对这些交易的内容或结果。只要节点同意交易集，交易处理协议确保每个节点生成连续的账簿。作为一个拜占庭错误容忍协议，XRP LCO必须在甚至在出现错误或恶意参与者的情况下操作。

拜占庭错误容忍共识协议由一个丰富的故事，但是大多数在协议参与者上需要先存的一致。XRP LCP由区别的特点是，它确保连续，在仅仅在谁参与上部分一致，允许去中心化开放网络。和其他去中心化共识算法，像POW或者POS相比，XRP LCP有它的最初为用户提供较低的交易延迟和较高的吞吐量。但是，在网络参与者上没有统一的一致，用户仍然需要一个方式去决定对等网络的选择导致一个持续的网络状态。在这种设置里，每个用户单独地定义一个独特的网络列表或UNL,是节点集，它的信息会被听到，当做关于网络状态的决定。它是任意对的决定网络安全的正确节点的UNL的交集。正如在原来的白皮书中所描述的，最小的重叠要求最初通常被认为大概UNL的20%。随后一个独立的分析建议一个正确的限制替代大体是>40%。

考虑到这个混淆，这个工作中我们的目标是给一个XRP LCP清晰的和详细的解释，和获得UNL重合的必要情况，用于持续性和活跃度。我们将讨论XRP账簿的交易语义或作为电子货币的XRP的利益，但是替代把算法看作一个普通的共识协议。我们重估两个先前的重合结果，并且提供一个单个正确的限制，在一定程度上在1到10之间。我们也展示在最初的白皮书没有考虑到的一个更加一般的错误模式，但是照教规的在研究文献中适用，最小重合时间上粗略地大于UNL的90%。最终，我们展示在多样化的信任网络操作者的当前状态，XRP网络既安全，也不会变的停滞不前。

研究提供了一个确定的结果，关于在当前状态下XRP账簿的安全性。但是，为了支持在将来在选择UNL上有更高的可扩展性，我们更喜欢一个算法，更接近原来的期望重合限制。在姊妹白皮书中，我们展示了一个新奇的替代的称作“Cobalt”的共识算法，在一般错误模型中，降低重合限制到仅大于60%，不会被卡在满足重合限制的任何网络中，有若干其他性能使其最终更适合替代XRP LCP。这个论文因此主要为了展示XRP账簿在转换到Conbalt期间是安全的，鉴于计划的转换，XRP LCP上的对UNL配置相对更严格的要求必须被满足。

章节2定义了网络模型和定义了共识问题。章节3是对Ripple共识算法的一个更详细的描述。章节4中，我们证明被用来确保算法正确性的网络情况。最终，章节4以一个结果和方向的改进的讨论为结论。

**2. 网络模型和问题定义**

Pi是网络中带有标识符i的节点，比如用密码写的公钥。每个节点Pi可以自由的选择一个唯一的节点列表UNLi,是一个节点集（可能包含它自己），Pi会听他的信息作为XRP LCP的一部分。UNL代表网络子集，被pi共同信任不会串通去尝试七篇网络（参考10，用于这个名字的激励）。UNL为网络给定结构，一个节点出现在更多的UNL中，含蓄地拥有更大的影响。一个独立的节点在选在他们的UNL上有完全的自由裁量权，虽然我们在章节4中展示和其他UNL的最小重合对于和其他诚实节点的一致性和活跃性是必要的。我们不假定信任是对称的，因此例如可能有一个节点Pj ∈ UNLi，比如Pi /∈ UNLj。图形1展示了一个例子信任网络。

一个没有崩溃的，完全根据XRP LCP说明书行为的节点，被称为诚实或正确。我们用两个可交换的术语。任何不根据协议行为的节点被称为拜占庭。拜占庭行为包括不回复信息，发送错误的信息，甚至给不同方发送不同的信息。在章节4中，我们最初认为对在对手的限制惩治为拜占庭义务，陈述所有节点，-甚至拜占庭节点，不能给不同的节点发送不同信息。这个是最初的白皮书的一部分，假定这样的行为在点对点网络中可以被诚实节点识别和纠正。但是，由于异步和诚实节点被暂时分开的可能性，这个假设实际上最优情况下是脆弱的。因此，大量的我们的结果不依赖与这样假设，我们将清楚的阐述，当他被假定时。

对于任何节点，我们指示ni = |UNLi| ，定义法定人数，指示qi,一个大概制定UNLi中同意节点的最小数量的参数，Pi需要听到去提交一个觉点。每个节点集qi时它UNL尺寸的80%，或者，更精确的，qi=[0.8ni]。我们假定至多UNLi中至多ti 6 ni − qi节点可能时拜占庭错误。

当L代表一个账簿，这是系统的共享状态，包括账户设置，余额，订单簿等。两个账簿L,L′是相同的，如果他们代表相同的交易订单历史，从独特的起源账簿。每个账簿也有一个序列数seq(L),是一个比它的父账簿的序列号大的账簿。这个创世账簿的seq(L)=1。一个账簿L会被建立，通过根据协议规则应用一个交易序列T = [x0, x1, . . .]到它的父parent(L)。两个账簿可能有相同的父账簿和序列号，但是因为他们应用不同的交易而不同。注意虽然协议指定每个交易集有一个确定性的序列，因此对两个正确的节点不可能在不同的订单里应用相同的交易。

节点通过一个点对点的网络进行通信，和UNL结构没有规定的关系。我们仅仅假定每个节点pi和每个节点Pj ∈ UNLi,对于Pi有一个可信任的已验证的渠道去接受来自Pj的消息。为了实施这样验证的渠道，所有的消息都被接收者加密地签署和验证。每个节点用一个单通信原始广播，当调用节点Pj发送相同的消息到所有节点Pi，用于Pj ∈ UNLi.在附录A所展示的算法中，我们用对用的接受原始，被称做异步接受广播消息。

XRP LCP的结果是对一个节点用来完整的验证账簿。一个完全验证账簿是不可撤销和有权威的，反应了由网络用户提交，被共识算法接受的交易。完全的验证的一个账簿也完全地验证所有的他的祖先。由于这个原因，分叉是两个诚实的节点完全地验证矛盾的账簿的情况。这个网络被称为分叉安全，如果从来没有和一个可能容忍拜占庭错误配置的分叉。

虽然XRP LCP典型地被定义为术语账簿的全验证链，因此每个链上的账簿呆鸟一个确定顺序的交易序列，它也被认为一个原子的广播协议，带有成批交易的效率。形式上，一个原子广播协议是一个算法，一个客户集，任意数量的拜占庭错误，可以广播交易，每个节点可以接受一些这些交易，根据如下的特性：

1. ABC协议：如果一个正确的节点接受一笔交易到账簿，然后最终素偶的正确的节点接受这个交易进账簿。

2. ABC-线性一致性：如果一个正确的节点在交易x′之前接受交易x,那么所有的正确节点在x′之前接受交易x。
3. ABC-审查制度弹性：如果一个客户广播一个有效的交易x到所有正确的节点，x最终会被所有的节点接受

一个原子的播送算是是共识的一个特别变体。注意审查制度弹性是前进过程的形式化的定义。实际上，点对点的网络弱化了客户向所有正确的节点提交他们的交易的需求，因此正确的节点会互相重复提交的交易。大量送至这个网络，直到每个节点收到它。

为了评价XRP LCP的正确性，我们模拟点对点的网络，犹如他们有可以武断地行为的网络敌手控制。敌手控制所有消息的传递顺序，也至多对于任何正确的节点Pi,在UNLi中有ti节点。我们假定虽然敌手在计算方面讲是被限制的。特别，它不能破坏普遍接受的加密协议。拜占庭节点的身份不能提前被网络中的诚实节点知道。

因为原子播送是共识的一个变种，根据FLP结果我们不能保证在任意异步和错误节点中的前过程。相反，我们假定“弱异步”形式：在任何异步情形下安全必须被保证，但是审查制度的弹性仅在如下假设下确保：这个网络最终是有礼貌的，意思是信息在一些协议指定的最大延迟限制内发送，并且没有节点是错误的。

为了帮助加强在XRP账簿实施中的限制的延迟，若干探索性步骤被用来识别落后的节点，阻止网络中过多的信息和路线流量泛滥。协议参数在不同的信任的信息上参数上定义最大的延迟，试图有助于活跃度。虽然我们忽略了这个细节，去简化如下的展示，我们强调在实际实施和控制算法在现实世界的表现，这些事重要的事件的考虑。XRP LCP 仅仅是虚弱的异步的事实，它的性能取决于这些参数是算法的一个限制。Cobalt,提议的XRP LCP的替代版本没有这些限制。它用加密不可测性来规避FLP结果，确保前进过程，即使带有最大数量的容忍错误节点和不限制的异步。

表1 总结了我们概念，包括一些会在随后章节中解释的。

**3. XRP账簿共识协议**

XRP账簿共识协议包含3个主要组成部分：

- **审议** 节点反复的提交一个交易集，应用到先前的账簿里，基于从其他节点收到的提议。当一个节点相信足够的提议同意，它应用想用的交易到前面的账簿，根据账簿协议规则。它然后发布一个用于生成的账簿的验证。

Pi 网络中的节点
UNLi 由Pi选择的独特节点列表UNL
ni, qi, ti 尺寸，验证法定人数和最大的UNLi的最大拜占庭错误
L 账簿
seq(L) 账簿 L的序列号
ˆL 完全确认的账簿，带有最大的序列号（完全验证的小部件账簿）
˜L 审议的当前工作账簿
T = {x0, x1, . . .} 交易集
PT,r,L,i 节点 Pi’s r-th 应用到L的交易T的审议提议
VL,i 节点 Pi’s 确认的账簿L
supptip(L), suppbranch(L)  账簿L的提示和分支支持
uncommitted(s) 在序列号上自由的支持
φ(L,L′) 排序函数是 1 如果 L > L′ (by hash) and 0 otherwise
表 1: 概念概括

- **确认** 节点决定是否完全地确认一个账簿，基于信任节点发布的确认。一旦相同的账簿的确认的法定人数到达，账簿和它的祖先被视为完全确认，状态是有权威的和不可撤销的。
- **优先的分支** 节点决定账簿历史的优先的工作分支。在异步的时候，网络难度，或拜占庭失败，节点或许不会最初确认相同的账簿，对于一个给定的序列号。为了进行向前进程和完全第确认后面的账簿，节点用信任确认的账簿祖先去继续考虑网络上的有限的账簿。

简言之，对于每个序列号s,每个典发布一个确认Vl,i,用于账簿L，带有s=seq(L),期望被确认完全地确认。在文明的执行中，审议过程非常像验证的账簿匹配由信任点确认的账簿。在网络不能正常工作的情况下，优先分支确认点选择一个普通的分支，节点随后完全地验证相同的账簿L，带有seq(L)>S。这个审查和验证的两步序列和Buterin and
Griffith提出的POS终局配件类似。事实上，优先的分支协议和Sompolinsky and Zohar的GHOST共享一个共同的原则。在右边的虚线账户代表审议边界，节点目前和信任节点沟通，哪一个交易应用到下个账簿。

图形2是账簿历史的概要的观察，展示从单个节点的角度来看，这些不见是怎么交互去使账簿状态前进的。时间流动向右，带有两个在左边的灰色的账簿定义了完全的确认和有权威的账簿链，带有小部件账簿L.空的账簿代表两个冲突的账簿L,L′被不同的节点验证，但是没有收到法定人数去完全地确认。在这个原理图中，优先的分支决定上面的L′更可能被完全确认，因此那是用于节点活跃的审查循环的工作父账簿。

**3.1 审议**

审议时Ripple共识的不见，节点常识同意交易集去应用他们确认的账簿里。客户提交交易给一个或多个网络中的节点。每个节点维护这些未确定没有被包含在账簿内的交易集。从这个集开始，一个而节点重复的提议交易集，基于个体的交易，被UNL中节点提议的集中的交易。每个提议PT,r,L,i是如下的元组：

- T，提议的共识交易集的节点的当前推测
- r, 提议的循环数，和来自基于前面的账簿L的Pi的其他提议相关
- L,这些交易会应用的前面的账簿
- i, 广播这个提议的节点Pi的标识符

当在他的UNL中有足够的节点提议相同的交易集，一个节点发布一个确认，基于那个集，开始下一轮的确认。

图形3是高阶的确认的综述，在算法里正式的展示。一个节点最初调用START去开始一个新的确认循环，并且提议他的共识加偶i的最初视图。他异步地提交来自信任节点的新的提议，维护来自各自的最近的提议集。提议仅在这个情况下被考虑：如果他们都是用于相同的前面的账簿˜L.节点常规地更新它提议的共识交易集，回应新收到的节点提议，仅仅包括在至少threshold(r)呈现的交易，从可信任节最近的收到的提议。这个门槛作为一个UNL中节点的简单大多数开始，但是逐渐升高当确认轮开始。这确保慢的节点不能组织共识聚集。在XRP账簿实施中，门槛从0.5 → 0.65 → 0.70 → 0.95，当r增加。每个节点Pi声明共识达成，当它看到它的信任节点的法定人数qi同意交易集。然后应用共识交易去生成下一轮账簿L，广播它的确认VL,i，并且开始新一轮的确认。

要注意如下情况是重要的：一个节点或许仅仅确认带有给定的序列号的账簿。实际上不变量是对于节点Pi仅仅发布一个确认VL,i用于账本L，如果seq(L)大于任何由Pi先前确认的任何账簿。因此，如果在确认期间，一个节点决定它不在优先分支上工作，它将转换去到优先账簿上工作，但是不会发布一个确认，直到它赶上序列号，它在转换前所在的。

在XRP账簿确认实施中，协议时间参数决议节点提议的同步要求和用于介绍确认的情况。额外的等待期间，在审议月吞吐量阶段和交易处理延迟，和网络广播提议和交易集的吞吐量。还有协议规则：决定那个交易在最初的提议里和被失败包含进去的交易在随后的审议里重试。尽管这个偏离论文中的抽象算法，我们相信这个改变就能进隐藏了算法的展现，可以被视为为了增加交易吞吐量的优化。最重要的，安全和活跃结果，在章节4，不依赖这些审议的详情。

**3.2 确认**

确认是三个组成部分中最简单的，在算法中被概述。网络中的节点仅仅听来自信任节点的确认。如果节点Pi看到一个确认的法定人数qi，用于账簿L，然后它设置信的完全验证的小部件账簿ˆL到L。

**3.3 优先的分支**

验证其正常确认一个简单的账簿链，例如LA → LB → LC。但是在异步的时间内，网络难度，或者临时的拜占庭失败，在确认中，不是所有正确的节点或许以收到足够的确认结束，用于任何个体账簿去完全地验证。当遇到冲突的账簿，优先的分支是策略，决定账簿的优先链去转化，为了继续前进。它是基于最近验证账簿的共同的祖先，lastV als,和下面的数量：

1. 账簿L的小部件支持，是信任节点的数量，最近的确认的账簿是L。

supptip(L) = |{VL′,i ∈ lastV als : L = L′}|.

2. 账簿L分分支支持，是信任节点的数量，最近验证的账簿是L或从L下来的：

suppbranch(L) = supptip(L) + |{VL′,i ∈ lastV als : L ∈ ancestors(L′)}|,
(2)

ancestors(L′)是L′祖先的集合，父母，祖父母，曾祖父母等，所有的方式回到创世账簿

3. 对序列号S自由的支持，这是可信任节点的数量，最近验证的账簿是为了一个账簿，带比s低的序列没货带比最大账簿L确认低的序列，我们个人广播的

uncommitted(s) = |{VL′,i ∈ lastV als : seq(L′) < max(s, seq(L)). (3)

图形4展示了一个激励的例子，每个账簿用元组((supptip, suppbranch, uncommitted))注解，从节点的观点，最后验证LF，有5个可信任的节点，两个最后确认的LF，和每个确认中的LB, LD和 LE。优先的分支策略决定LD是优先的

优先的分支由算法提供。主观的，这个主意对于每个节点是保守的，仅仅转换到一个不同的分支，当它知道足够的节点已经承诺到账簿的那个链，这样一个替代链不可能再由更多的支持。优先账簿是由不幸祖先树找到的，从账簿L开始，是最近确认账簿的普通的祖先账簿。我们然后选择子账簿L′ ∈ children(L)，带有最高的suppbranch(L′)，那个将有最多的支持，即使所有的uncommitted(seq(L′))拾起一个冲突的姊妹账簿。如果我么可以选择一个而满足这个要求的L的子账簿，那么我们在L′的子账簿张重复这个过程。为了确保在步步的一个总的排序和打破子账簿间的联系。我们依赖函数φ(L′,L′′)，如果L′ > L′′，哈希是1否则是0。如果这个账簿所赵是我们当前账簿˜L的祖先，我们保持˜L作为优先账簿，因为我们还不知道我们在错误的分支上。

注意，如果在一个极度的不同步中，一个分支可能最初由单节点支持，当成为优先的。这意味着其他节点必须验证那个账簿的协议变量，在切换去仔细考虑它之前

**4. 分析**

已经从协议花店描述了XRP LCP，我们现在正式的证明它的安全性和活跃性的结果。

**4.1 安全性**

在这个章节中，我们将证明网络配置的情况的，确保不同的节点运行XRP LCP保持一致。

在如下的分析中，我们发现假定完全地验证一个账簿不需要完全地验证它的祖先是方便的。正如我们将发现的，会可能在一些配置里，对于两个节点完全地验证矛盾的账簿，带有不同的序列号，即使完全地验证相反的带u偶相同序列号的账簿是不可能的。前者和后者是一样又问题的，但是我们发现分成两份失败类型是方便的，分别地证明组织他们的的情况。

对于最初的分析，我们做了个简化的假设。论文的后面我们会再分析不带这些假设的问题。我们所做的假设是，拜占庭错误节点不能说服验证不同账簿的两个诚实节点。这个假设在原始的白皮书中有适用。由这个理由使其合理化：所有的通信通过在点对点网络中类的多播实现的，因此两个相反信息的“回声”会被及时的主义到，对于会被忽略的信息，因为信息是被前面的。不幸的是，这个假设不能保留一个完全的异步网络，因为网络的分割会隔离矛盾的信息时间最后长到允许损害发生。我们称这个假设未拜占庭义务，总是参考当我们使用它作为假设时。

假定拜占庭业务保留，我们现在分析什么时候可能使得两个节点完全地验证不同的账簿，在当个的共识循环中。轻微的修改注释，白皮书中建议的情况是两个节点Pi,Pj不能无安全地验证冲突的账簿，如果：

|UNLi ∩ UNLj | > max{ni − qi, nj − qj}.

正如建议的80%的法定人数，这个情况和白皮书所给定的实际情况更加容易等同。

|UNLi ∩ UNLj | > 0.2max{ni, nj}.

在随后的独立分析中，Armknecht et al.展示这个情况是不正确的。他们相反建议Pi,Pj不能完全地验证不同的账簿，如果且仅如果

|UNLi ∩ UNLj | > 2max{ni − qi, nj − qj}.

是正确的:如果上述情况保险，然后Pi和Pj完全地验证不同的账簿。但是这个谈话时不正确的，如下述议题所展示的。

**议题1.** 假定拜占庭义务，两个诚实的节点Pi,Pj不能完全地验证不能的账簿，带有相同的序列号iff

|UNLi ∩ UNLj | > ni − qi + nj − qj .

注意2max{ni − qi, nj − qj} > ni − qi + nj − qj ,但是ni − qi + nj − qj严格的小一些，不管何时ni − qi 6= nj − qj .因此由Armknecht et al.建议的情况时充分的，但不是必要的。

议题1的证明。我们线证明充足。假设Pi完全验证账簿L，并且|UNLi ∩ UNLj | > ni − qi + nj − qj .

让S成为UNLi中的节点集，验证L。因为Pi完全地验证L，|S| > qi.根据拜占庭义务，每个在S ∩ UNLj的节点不能发送一个验证到Pj,用于任何账簿L′ 6= L。因此它足够展示|S ∩ UNLj | > nj − qj，因此然后他们不能成为任何账簿L′ 6= L，带有qj，在UNLj中支持。

根据重合假设，我们有：

> |S ∩ UNLj | = |S| − |S \ UNLj |
> > | S    | −    | UNLi \ UNLj |
> > | ---- | ---- | ----------- |
> > |      |      |             |
> > = |S| − (|UNLi| − |UNLi ∩ UNLj |)
> > |S| − (ni − (ni − qi + nj − qj))
> > qi − (ni − (ni − qi + nj − qj))
> > = nj − qj .

对于必要性，我们先假设|UNLi ∩ UNLj | 6 nj − qj .然后再UNLi中的所有节点能够验证L，当在UNLj \ UNLi中所有节点验证L′,同时根据假设|UNLj \ UNLi| > qj，因此Pj完全地验证L′，当Pi完全地验证L.

现在假设|UNLi ∩UNLj | 6 ni−qi+nj −qj and |UNLi ∩UNLj | > nj −qj .然后：

|UNLi \ UNLj| = |UNLi| − |UNLi ∩ UNLj|
> ni − (ni − qi + nj − qj)
> = qi + qj − nj.

因此，如果在UNLi \UNLj中的所有节点验证L，并且在·UNLi∩UNLj中的节点nj −qj也验证L（时可能的因为|UNLi ∩UNLj | > nj −qjgenuine根据假设），然后Pi将受到(qi + qj − nj) + (nj − qj) = qi验证对于L，并且完全地验证L，同时如果i哦所有的在UNLi中的其他节点验证L′,然后因为在UNLj中仅仅节点nj − qj验证L，nj − (nj − qj) = qj节点将验证L′,所以Pj完全地验证L′。

假设80%的法定人数，这些重合的情况概括如下：

- Schwartz et al.: 每个节点对需要20%的最大尺寸的他们的各自的UNLs的重合
- Armknecht et al.:每个节点对需要41%的最大尺寸的他们的各自的UNLs的重合
- 实际情况：每个节点对需要41%的他们各自UNLs的平均重合

对文章的剩余部分，我们不再假设拜占庭义务性。在一个活的网络中，一个人会更倾向于安全性，而不是脆弱的启发式，建议不可能人一个拜占庭节点可以发送冲突的信息到不同的节点而不被抓。因此我们遵循研究惯例，假定拜占庭节点不能发送任意信息到任意节点。

对于任何节点对Pi和Pj,让Oi,j = |UNLi ∩ UNLj | and和让ti,j =
min{ti, tj ,Oi,j}。tij时在UNLi ∩ UNLj 中所允许的拜占庭错误数量的最大数目，假设至多在UNLi中有ti个错误，并且在UNLj中至多有tj个错误。

如下的引理在文章中是有用的：

**引理2** 如果一个诚实的节点Pi看到 对带有seq(L)=s账簿L的m验证，然后对于任何其他诚实的节点Pj,他们至少在UNLj中Oi,j+m−ni−ti,j个诚实的节点。此外，精确地在UNLj中Oi,j + m− ni − ti,j个诚实的节点验证L。

**推论 3.** 如果一个诚实的节点Pi看m验证用于带seq(L)=s的账簿L，然后Pj可以至多看到ni + nj − Oi,j − m + ti,j确认，用于任何带有seq(L′) = s的矛盾的账簿L′.此外，对于Pj能够看到精确地ni + nj − Oi,j −m+ ti,j验证，对于一个带有序列号s的一个矛盾的账簿L′。

证明。如果一个诚实的节点确认L,那么Pj不能收到对于来自它的任何矛盾的账簿L′。根据引理2，至少由Oi,j+m−ni−ti,诚实的检点验证L。如果每个再UNLj中的其他节点发送一个确认到Pj,用于矛盾的账簿L′,那么Pj可以收到至多（包括，通过引理2的次要句）

nj − (Oi,j + m− ni − ti,j ) = ni + nj − Oi,j − m+ ti,j

验证，用于带seq(L′) = s的L.

注意推论3不妨碍可能性：Pj会看到超过ni+nj −Oi,j −m+ti,j的验证用于一个带一个大于S的序列号的矛盾的账簿。实际上，不假定全体，一些事件是可能的，迫使算法去使用更加严厉的安全界限。

引理2的证明。这个证明和命题1的证明类似。

假定Pi看m确认用于L。再次让s成为再UNLi中的节点集，发送确认给Pi用于L,然后

|S ∩ UNLj | = |S| − |S \ UNLj |
> |S| − |UNLi \ UNLj |
> = |S| − (ni − Oi,j)
> = m− ni + Oi,j .

在S ∩ UNLj中有ti,j拜占庭节点，发给Pj一个验证，用于L之外的一些事情，所以至少m−ni+Oi,j−ti,j个诚实节点验证L。

对于第二点，假定在UNLi \ UNLj中的每个节点都确认L，UNLi ∩UNLj中ti,j个拜占庭节点发送一个用L的确认给PI,L′给Pj.在UNLi ∩ UNLj中有精确的m − ni + Oi,j − ti,j honest诚实节点，发送一个用于L的确认到Pj。因为在UNLj \ UNLi的每个节点可以确认除了L的账簿，有精确地m−ni +Oi,j −ti,j honest个诚实节点在UNLj中发送一个用于L的确认到Pj。

**命题 4.** Pj完全地验证一些带有seq(L) = s的账簿L，意味着Pj不能完全地验证任何带有相同序列号s iff Oi,j > (ni − qi) + (nj − qj) + ti,j 的任何矛盾的账簿。

证明。 让m = qi, 推论3告诉我们Pi完全地验证L，意味着Pj至多可以看到ni+nj−Oi,j −qi+ti,j确认，用于带有序列号s的矛盾的账簿。

因此，如果

qj > ni + nj − Oi,j − qi + ti,j
Oi,j > ni − qi + nj − qj + ti,j

那么Pj不能完全地验证带有序列号s的任何矛盾的账簿。

作为需要，如果Oi,j 6 (ni − qi) + (nj − qj) + ti,j ,那么推论2的第二语句意味着Pj不能精确地看到

ni + nj − Oi,j − qi + ti,j > ni + nj − ((ni − qi) + (nj − qj) + ti,j) − qi + ti,j
= qj

验证一个矛盾账簿L′，允许Pj完全地验证L′.

再次假定80%的法定人数和20%的容错，在白皮书中，这个重合情况可以被概括为大概61%的UNL重合。

为了看为什么在命题4的重合假设不能确保完全的安全，注意节点是能够从对序列s的审议退出的，然后不能完全地验证任何带有序列s的账簿，如下例所示。

**例5**

考虑一个有1个节点的完整网络。用X表示前5个节点，Y表示其他5个节点。正如图标5中所示，假设X中的所有节点开始审议，提议交易设置T = {x0, x1}，所有在Y中的节点开始审议提议交易集T ′ = {x0}.因此对于τ的交易门槛，收到用于T的τ个提议会导致诚实的节点ti'y提交

图形5： 例5的原理图。两个节点组X和Y通过分别提议T = {x0, x1} 和 T ′ = {x0}开始。左（右）盒子里反应由节点1（10）看到的提议，代表在组X(Y)中的苏偶偶节点。灰色箭头至少提议，被及时的收到去计算一个给定循环的门槛。注意在循环r-1,从节点5的提议不会由Y中的节点收到。这两个区分Z 和Z′由虚线的盒子代表。注意所有节点分享相同的单个UNL

T，当收到对于T的小于τ的提议，但是τ提议对于T或T ′会导致一个诚实的节点提议T ′,因为T ∩ T ′ = T ′.

让r成为交易门槛在审议循环r是65%，65%在循环r+1。通过如分段3.1中描述的松脱门槛协议，比如r存在。在第一r-1循环，X中的节点收到所有的提议，当在Y中的节点收到所有的提议除了来自X中的一个节点的提议。因为X中的节点提议T，当Y中的节点提议T ′,X中的节点继续提议T,当Y中的节点仅仅收到对于T的四个提议，继续提议T ′，在T和T ′上的假设。

现在在循环r中，所有的节点收到所有的意义。这导致所有的节点在循环r+1中提议T，一个网络错误导致没有节点收到其他人的提议。基于最近收到的审议提议，每个人假定所有的节点仍然提议他们在之前的循环所提议的。因此，在X中的节点仅仅看看对于T的5个提议，当Y中的节点看到仅仅对于T的6个建议（因为他们当然收到他们自己更新的提议）。没有人看到65%对于x1的支持，但是每个人看到对于x0的100%的支持，所有每个人提议T ′，在循环r+2.

现在提取网阔的任意分隔到两个集，Z和 Z′.在Z中的节点收到来自循环r+1的所有的提议，但是没有来自循环r+2的提议。因此他们看到对T的100%支持，并且验证T。同时，在Z′中的节点收到所有来自k+2循环的提议，看到对T ′的100%支持，并且验证T ′。因为我们可以从带有两个任意子集验证不同账簿中的审议出来。在这个情况里，如果|Z| > 2 并且 |Z′| > 2,然后没有节点完全地验证一个账簿，在共识循环中。

因为例5中的例子，我们因此我们做一个更显著的假设，审议可以带有任意结果终止。事实上，这个或许需要一个显著地降级的网络，但是尽管如此是一个真实的风险。从理论的角度，审议因此是完全不相关的；它纯粹是个最优化，使其如此，在民间的执行，大多数节点会去验证相同的账簿，允许每个节点完全地验证通常，在不从根本上改变协议的基础上被移除。

因此，转变我们的关注点到验证，不对审议结果做任何假设。我们需要证明如果任何节点完全验证账簿L，那么一个节点就不能验证一个账簿L′，seq(L′) > seq(L)和L′不是L的派生物。下述的引理提供了确保这个的路径。

**引理6** 如果对于每个而节点Pi,在UNLi中由超过ni/2的诚实节点，为带有seq(L)的账簿L提交一个验证，然后对于在UNLi中每个节点Pi，超过ni/2诚实节点将总是提交从L中派生出的账簿的验证。

证明。我们通过自相矛盾来证明。如果引理是不正确的，那么在引理的假定，必须由一些诚实的节点，不提交用于L的验证，最终提交一个用于带有seq(L′) >seq(L)的账簿L′的验证，L′不从L中派生。因为正确的节点仅仅能提交账簿的验证，带有序列，严格的大于任何账簿，他们之前为其提交国一个验证，这样的一个节点必须为L′提交它的验证，在为L提交验证后。因此让Pi成为诚实的节点，为L提交一个验证，随后第一个为不从L中派生的L′提交一个验证。

对于Pi唯一的方式去随后提交一个验证为一个账簿，在L分支西，如果它运行优先的分支算法，看到一个从L中下的账簿作为优先的。对于给定s 6 seq(L)，让parent(s,L)代表带有序列s的L的祖先。因为Pi通过假设为L提交一个验证，它认为账簿的所有验证，带有小于seq(L)的验证在优先的分支协议里是自由的。但是因为Pi是假定为第一个从L分支切换开的，在UNLi的ni/2的节点不能发送验证，用于任何带有seq(L′) > s序列的账簿L′。L′不是从L中派生的，因为对于每个s 6 seq(L),Pi不UNLi中节点的大多数作为自由的支持在s上，或者对parent(s,L)的分支支持。换句话说，对于所有s 6 seq(L),

suppbranch(parent(s,L)) > ni/2 − uncommitted(s).

对于给定的s < seq(L),假定parent(s,L)是当前的基础账簿，在算法3的行10的循环中。然而C[0] = parent(s + 1,L)或一些L′ 6= parent(s + 1,L) with parent(L′) = parent(s,L) and C[0] = L′.在随后的案例中，对于C[1]的分支支持必须至少和parent(s + 1,L)的分支支持相等（打破和φ的纽带）通过C的排序的定义。此外，对于C[0]的分支支持必须小于ni/2，因此在行16

 = suppbranch(C[0]) − suppbranch(C[1]) + φ(C[0],C[1])
6 suppbranch(C[0]) − suppbranch(parent(s + 1,L)) + 1
< ni/2 − suppbranch(parent(s + 1,L)) + 1
< ni/2 − (ni/2 − uncommitted(s + 1)) + 1
6 uncommitted(s + 1) + 1,

所以条件 > uncommitted(s+1)总是错误的。因此在随后的情况下Pi视parent(s,L)作为优先的账簿。在之前的情况下，Pi把parent(s + 1,L)看作优先账簿或继续带parent(s +1,L)的循环作为基础账簿。通过介绍，Pi被确保看到更多的在L上的账簿作为优先，所以Pi不能离开L分支，与我们关于Pi的假设矛盾。

如果在UNLi中超过ni/2的诚实节点仅仅验证L的派生物，然后一定所有的Pi不能完整地验证一个账簿，不是从L中派生出来的，因为否则就会有qi > ni/2节点，为一些账簿L′发送确认，带有序列号s′，不是从L中派生出来的。因此我们能展示共识是圈的，如果我们确保如果任何诚实节点完全的验证账簿L，带有序列号s,那么对每个节点Pi,在UNLi中超过ni/2的诚实节点必须验证L。如下命题给出确保这个性能的重合情况。

**命题 7 .** 考虑到两个诚实的节点Pi,Pj，Pi完全地验证带有seq(L) = s的账簿L，意味着在UNLj中有超过nj/2的诚实节点，验证Liff Oi,j > nj/2 + ni − qi + ti,j .

证明。这个证明直接和命题4的证明类似。除了没有限制共识被qi,我们限制它nj/2

**定理8** XRP LCP确保分叉安全如果Oi,j > nj/2+ni−qi +ti,j对于节点Pi,Pj 的对。

注意虽然命题7是一个iff陈述，在定理8的重合情况仅仅充分但不是必要的，对于XRP LCP的安全。这是因为引理6不是一个iff陈述。此外，有一些验证配置不能来自审议，破坏我们更显著的假设，任何东西来自审议。但是这个最弱的情况，可以纯粹的表达为对重合尺寸的限制。

再次假设80%的法定人数和20%的错误，在定理8的重合情况可以被概括为需要大概>90%de UNL重合。尽管相当小的边缘（一定比原来期望的小很多），这部运行少量的变种，对于XRP账簿网络的过渡是非常重要的， 推荐的UNL被独立个体推荐的。在UNLs上有一些扩展性是重要的，对于在信任操作者的多样化（当一个从来不能确保在参与者上达成一致，当参与者是独立的实体时）和在多样化过程（如果在在变化到UNL列表期间微小的部一致导致分叉，然后多样性总是太危险而不能执行）

**4.2 活跃性**

现在我们有一个具体度量标准，什么时候对于网络不可能分叉，我们想直到当前进的时候。如果一个活的网络停止前进，几乎和分叉具有一样的破坏性，因为商业可能依赖按时转账。不幸的时，根据FLP的结果，不可能确认前进在一个完全地异步的网络里。

在缺少证明网络总是前进的情况下，我们想至少证明网络不会堵住。换句话说，网络不能进入一个状态，一些诚实的节点从来不能完全地验证一个新账簿。

不幸的是，通常非常难证明XRP LCP确保前进，如下的例子展示可能堵住，在99%UNL重合和没有拜占庭错误的情况下。

**例9**

考虑一个102个点的在图6中画的网络。有两个UNLs,红色的X = {P1,P2, . . . ,P101}和蓝色的Y = {P2,P3, . . . ,P102}.点1-51使用X，点52-102用Y.有两个账簿，L 和 L′.监听X的节点全部验证L的派生无，当监听Y的节点全部验证L′的派生物。因为X中51 > 0.5|X|节点验证L的派生物。因此根据优先的分支协议所有，监听X的节点不能切换分支到L′。类似的，因为在Y中51 > 0.5|Y |节点全部验证L的派生物，监听Y的节点不能切换分支到L′。网络不能重新聚合，没有人工的干预。

在这个论文写完的时候，推荐的XRP信任模型让所有的节点监听单个的包含5个节点的UNL或1包含5个这些节点加上一个额外的节点的UNL(典型的是，额外的节点是自己；监听这些扩展UNLs的节点因此叫做“叶子”，因为分支轻微的离开核心网阔)。短期的去中心化的计划涉及扩展到一个更大的，但是任然互相认可的，单个网络，同时多样化节点操作者。丢失前进过程当调整一个新的节点列表不是一个大问题（因为只要每个人再次统一节点列表，前进会恢复，之前的章节确认小的变化，它不会分叉在过渡期间）；因此我们至少得到一个挣的结果，通过提供网络不会堵塞在一个完整的带有叶子的图表中。

**引理10.** 假定N是网络的一个关闭的子集（例如，在N中的每个节点的UNL被包括在N里，所以从N内部节点的角度，N是整个网阔），不会毒舌，不能分叉。假定Pi是一个不再N里的节点，比如UNLi = {Pi} ∪N′,在N′ ⊆ N 和
|N′| > qi.然后N ∪ {Pi}也不能堵塞

证明 因为N不能堵塞，所以总是正确，在N中的节点最终完全的验证一个新整部。因为N不能分叉，N中的所有节点仅仅完全的验证相同的账簿，所以最终有一些账簿用L，会被N中的每个节点完全的验证。因此在N中的每个节点都会验证L，因为·|UNLi ∩ N| = |N′| > qi，Pi也能完全地验证L。因此总是正确的：Pi最终完全地验证一个新账簿，所以Pi不能堵塞。

**定理11.** 假定所有的节点UNL法定人数设定为·n−⌊(n−1)/k⌋，对于整数k。XRP LCO不能再一个网络中堵塞，包含单个的一致统一的UNL X,尺寸至少k和任意数量的叶子验证者。

证明。 对于任何叶子验证者Pi,ni = |X| + 1;因为qi = |X| + 1 − ⌊(|X| + 1 −1)/k⌋ = |X|+1−⌊|X|/k⌋ 6 |X|,根据引理10，它足够展示不堵塞的完整的网络。

因此，假设有一个单个的一致统一的UNL X。假设再一些循环r,所有的验证信息会足够快的传递，所有拜占庭义务保留和每个节点看每个其他节点验证从循环r。然后优先分支算法将确切地推送所有节点到最流行的账簿L。因此在下一个循环里，所有节点会验证L的子账簿。如果在审议意见发送的消息传递时同步的，那么所有节点从循环1中看到相同的提议，所有对出带有相同账簿的审议(如果一些交易集被X中节点的80%共享)或也建议用于循环2的提议确定的从来自循环1的提议，所以所有的节点提议相同的在循环2中的交易集。因此每个节点提交一个用于相同账户的验证，并且所有节点完整的验证那个账簿。

**5 结论**

我们给了一个详细描述和对XRP账簿共识协议的彻底的分析，是一个达成共识的协议，不需要网络参与者的普遍的同意。我们的工作更正了先前在[10,1]的分析。我们展示定理8，大概>90%在参与着的统一被需要去确保网络安全。在单个带有叶子的扩展UNL的限制的情况，定理11展示了我们总能前进在没有节点是错误和网络被传递带有限制的延迟。在一些更普通的情况，带有参与者最小的不统一，我们不能确保网络前进。

在一个开放性的问题，是否在定理8中有重复的重复情况会被改进，通过一个更加详细的考虑网络的信任拓扑。一个更加复杂的情况，不是仅仅考虑成对发生的重合，也要考虑信息不直接地通过网络流动的方式或许有潜能对于给一个更精确的情况，对于确保安全。同样的，我们或许能够利用信任结构去更好的解释案例，当审议失败，按次序可能允许一个更加精确的对前进的理解。

尽管我们展示了XRP LCP被证明安全带有当前和不久的将来的网络的结构，常识减轻它的一些一些缺点，在姊妹论文中，我们展示了一个替代共识协议称做Cobalt.类似于XRP LCP, Cobalt 也能在网络中使用，缺乏在参与者或信任的统一的统一，但是以一个稳定的速度前进，在最大化拜占庭容错和任意异步存在的情况下。它仅仅需要>60%重合去匹配XRP LCP安全容忍。Cabalt也有若干其他属性，使其更简单的去分析实际中网络的健康程度。在这些情况下，我们相信Cobalt代表一个被鼓励的方向，对于更加未来的XRP网络的去中心化。

**致谢.** 感谢Haoxing Du 和 Joseph McGee在研究早期的合作。我们也感谢David Schwartz和 Stefan Thomas提供拥有的讨论和指导，和Rome Reginelli的细心的编辑。我们最后感谢我们在Ripple的同事的支持。这个工作有Ripple提供资金。

**参考文献**

[1] Frederik Armknecht, Ghassan O. Karame, Avikarsha Mandal, Franck
Youssef, and Erik Zenner. Ripple: Overview and outlook. In Trust and
Trustworthy Computing: 8th International Conference, TRUST 2015, Pro-
ceedings, pages 163–180. Springer International Publishing, 2015. ISBN
978-3-319-22846-4. doi: 10.1007/978-3-319-22846-4 10.
[2] V. Buterin and V. Griffith. Casper the friendly finality gadget. ArXiv
e-prints, October 2017. URL https://arxiv.org/abs/1710.09437.
[3] Miguel Castro and Barbara Liskov. Practical Byzantine fault tolerance. In
Proceedings of the Third Symposium on Operating Systems Design and Im-
plementation, OSDI ’99, pages 173–186, Berkeley, CA, USA, 1999. USENIX
Association. ISBN 1-880446-39-1.
[4] Tushar Deepak Chandra and Sam Toueg. Unreliable failure detectors
for reliable distributed systems. J. ACM, 43(2):225–267,
March 1996. ISSN 0004-5411. doi: 10.1145/226643.226647. URL
http://doi.acm.org/10.1145/226643.226647.
[5] Michael J. Fischer, Nancy A. Lynch, and Michael S. Paterson. Impossibility
of distributed consensus with one faulty process. J. ACM, 32(2):374–382,
April 1985. ISSN 0004-5411. doi: 10.1145/3149.214121.
[6] Ethan MacBrough. Cobalt: BFT governance in open networks. ArXiv
e-prints, February 2018.
[7] Satoshi Nakamoto. Bitcoin: A peer-to-peer electronic cash system. 2009.
URL http://www.bitcoin.org/bitcoin.pdf.
[8] M. Pease, R. Shostak, and L. Lamport. Reaching agreement
in the presence of faults. J. ACM, 27(2):228–234, April
1980. ISSN 0004-5411. doi: 10.1145/322186.322188. URL
http://doi.acm.org/10.1145/322186.322188.
[9] Fred B. Schneider. Distributed systems (2nd ed.). chapter Replication
Management Using the State-machine Approach, pages 169–197. ACM
Press/Addison-Wesley Publishing Co., New York, NY, USA, 1993. ISBN
0-201-62427-3.
[10] David Schwartz, Noah Youngs, and Arthur Britto. The Ripple protocol
consensus algorithm. Ripple Labs Inc White Paper, 2014. URL
https://ripple.com/files/ripple_consensus_whitepaper.pdf.
[11] Yonatan Sompolinsky and Aviv Zohar. Secure high-rate transaction processing
in bitcoin. In Financial Cryptography and Data Security, pages
507–527, Berlin, Heidelberg, 2015. Springer Berlin Heidelberg. ISBN 978-
3-662-47854-7.
[12] Stefan Thomas. How we are further decentralizing the XRP
ledger to bolster robustness for enterprise use, 2017. URL
https://ripple.com/insights/how-we-are-further-decentralizing-the-ripple-consensus-ledger

**A 算法**

在附录里，我们提供了对于在章节3中描述的Ripple共识的3个不见的伪代码。注意在章节2的网络模型下，一个由节点Pi广播的消息事被所有的节点接受的，包括Pi自己。

算法1 1 从Pi角度的审议
1: smax ← 0 ⊲ Track the largest validated ledger sequence number
2: function Start(L)
3: ˜L ← L, r ← 0
4: T ← pending transactions
5: props ← {} ⊲ props is a map from node to proposal
6: Initialize props with previously received proposals for ˜L
7: broadcast PT,r,˜L,i
8: end function
9: receive PT′,r′,L,j do
10: if Pj ∈ UNLi and ˜L = L and r′ > props[j].r then
11: props[j] = PT′,r′,L,j
12: end if
13: end receive
14: function Update() ⊲ Called at a regular, protocol defined interval
15: if ˜L 6=PreferredLedger() then
16: start(preferredLedger())
17: else
18: UpdatePosition()
19: if CheckConsensus() then
20: ˜L ← apply(T, ˜L)
21: if seq(˜ L) > smax then
22: broadcast V˜L,i
23: smax ← seq(˜ L)
24: end if
25: Start(˜L)
26: end if
27: end if
28: end function
算法1 1 从Pi角度的审议(继续)
29: function UpdatePosition()
30: Tall ← SP∈props P.T ⊲ Set of all proposed transactions
31: τ ← threshold(r)ni
32: T ← {x ∈ Tall : support(x) > τ} ⊲ support is number of nodes
proposing x
33: r ← r + 1
34: broadcast PT,r,˜L,i
35: end function
36: function CheckConsensus()
37: na ← |{P ∈ props : P.T = T }| ⊲ Node positions agreeing with our position
38: return na ≥ qi
39: end function
Algorithm 2 Validation from the perspective of Pi
1: vals = {} ⊲ vals is a map from L to the set of nodes that validated L
2: receive VL,j do
3: if Pj ∈ UNLi then
4: vals[L] ← vals[L] ∪ j
5: if |vals[L]| ≥ qi and seq(L) > seq(ˆL) then
6: ˆL ← L
7: end if
8: end if
9: end receive
算法 3 从Pi角度的优先网络
1: lastV als = {} ⊲ lastV als is a map from trusted node to its most recent
validated ledger
2: receive VL,j do
3: if Pj ∈ UNLi then
4: lastV als[j] ← L
5: end if
6: end receive
7: function PreferredLedger( )
8: L ← earliest common ancestor of ledgers in lastV als
9: done = False
10: while |children(L)| > 0 and not done do
11: C ← Sorted array of children(L) by descreasing suppbranch, breaking
ties with φ
12:  ← suppbranchC[0]
13: if |children(L)| > 1 then
14:  ←  − suppbranchC[1] + φ(C[0],C[1])
15: end if
16: if  > uncommitted(seq(L) + 1) then
17: L ← C[0]
18: else
19: done ← True
20: end if
21: end while
22: if L ∈ ancestors(˜L) then
23: return ˜L
24: else
25: return L
26: end if
27: end function


