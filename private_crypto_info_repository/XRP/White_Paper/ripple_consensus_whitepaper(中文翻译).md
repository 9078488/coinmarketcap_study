瑞波协议共识算法

David Schwartz
david@ripple.com

Noah Youngs
nyoungs@nyu.edu

Arthur Britto
arthur@ripple.com

这个白皮书不能反映账簿共识协议和其分析的当前状态。

我们将继续保留这个草稿用作历史价值，但不应再作为参考。

共识协议的更新的分析和介绍，请参阅arXiv:1802.07242 (https://arxiv.org/abs/1802.07242)， 发布于2018年2月20日

摘要

当拜占庭将军问题存在若干共识算法，特别当它适用于分布式支付系统，许多遇到高延迟，由需要网络中所有的节点同步通讯的要求导致。

在这个作品中，我们提出一个新奇的共识算法，规避这个要求，通过在更大的网络中使用共同信任的子网络。

我么展示这些子网络需要的“信任”事实上是最小限度的，并且通过成员节点有操守的选择可以进一步减少。

此外，我们展示最小限度的联通被需要用来在整个网络中维持一致。

结果是低延迟的共识机制，面对拜占庭失败时，仍然能够保持健壮。

我们在瑞波协议的具体展现这个算法。

内容

1. 介绍

2. 定义，形式化和先前的工作

2.1 瑞波协议组成部分

2.2 形式化

2.3 现行的共识算法

2.4 正式的共识目标

3. 瑞波共识机制

3.1 定义

3.2 正确性

3.3 协议

3.4 效用

    收敛 . 启发式和程序

4. 模拟代码

5. 讨论

6. 确认

   参考文献

   **1.介绍** 


近年来，对分布式共识系统的兴趣和研究显著的增加，主要集中在分布式支付网络上。

这样的网络允许快速的，低成本的交易，不被中心化资源控制。

当这样的系统的经济利益和缺点值得研究，这个工作集中于所有分布式支付系统必须面对的一些技术挑战。

问题各异，我们把它们归合成三大类：
正确性、协议和效用。

关于正确性，我们的意思是一个分布式需要必须能识别出正确性的和欺骗性交易之间的不同。

在传统的基于信任的设置中，这是通过机构和加密签名来实现的，保证交易真正的来自所声称的机构。

在分布式系统中，但是，没有这样的信任，因为任何和所有网络中的成员的身份可能都无法得知。

因此，对于正确性的替代方式必须使用。

协议指的是指面对一个去中心化的系统维持一个总体的信任。

这个类似于正确性问题，不同的是事实上网络中的一个恶意用户或许不能创建一个欺骗性的交易（挑衅正确性），
他可以创建许多正确的交易，以某种方式让彼此意识不到对方，因此组合去创建一个欺骗性的行为。

例如，一个恶意用户可能进行两笔同时的购买，在账户里只有够购买一次的钱，但是不够付两个一起的钱。

因此，每笔交易单独的是正确的，但是如果在这样的方式下同时进行，分布式网络作为一个整体意识不到两个，一个清楚的问题的出现，通常被认为是“双花问题”。

因此协议问题可以概括成仅仅一套全局的识别的交易在网络中村的要求。

效应是一个更抽象点的问题，我们通常把它定义为一个分布式支付系统的“有效性”，但是实际上大多数经常简化为系统的延迟。

一个分布式支付系统，同时正确和一致，但是需要一年去处理一笔交易，例如，明显是个不可能生成的支付系统。

这些事件中的许多问题在现代分布式电脑系统出现之前就被探索，通过一个被称为“拜占庭将军问题”的问题。

在这个问题中，一组将军每个人控制一个军队的一部分，必须向每个人派出信使协同一次进攻。

因为将军们在一个不熟悉的并且敌对的领土上，信使可能不能成功的到达目的地（正像分布式网络中的节点可能失败，或者发送毁坏的信息替代有意的信息）。

问题的额外一面是一些将军可能是叛徒，单独地或一起共谋，所以信息可能会到达哪些打算建立一个错误的计划，注定是诚实的将军失败（正如一个分布式系统中的恶意成员可能尝试说服系统去接受一个欺骗性的交易，或一些可信任交易的多个版本，会导致双花）。

因此，一个分布式支付系统必须在面对标准错误和所谓的“拜占庭”失败时足够健壮，由网络中的索格资源引起和调节。

在这个工作中，我们分析一个分布式支付系统的独特的实现：Ripple协议。

我们关注用来实现以上正确性，一致性和效应目标的算法，显示所有的都满足（在必要的和预先设定的相容极限，能很好的理解）。

此外，我们提供模仿共识攻错的代码，带有可参数花的网络尺寸，恶意用户的数量，和信息发送延迟。

**2.定义，形式化和先前的工作** 

我们从定义Ripple协议的部件开始。

为了证明正确性，一致和功用性能，我们先将这些性能形式化为公理。

当一起分组，形成共识的概念：网络中的节点所在的状态达成正确的一致。

我们然后强调一些先前和共识算法相关的结果，并且在我们形式化框架内最终声明Ripple协议共识的目标。

**2.1 Ripple协议组件** 

我们通过来定义如下术语来开始我们对Ripple网络的描述：

- **服务器**：一个服务器是指一个运行Ripple服务器软件的任何实体（与仅仅让用户发送和接受资金截然相反），参与共识过程
- **账簿：** 账簿是每个用户的账户里货币数量的记录，代表网络的“地面实况”。这个账簿重复更新成功通过共识过程的交易。
- **最后关闭账簿** 最后挂壁的账簿是最近的账簿，由共识过程批准，隐私代表网络的当前状态
- **开放式账簿** 开放式是一个节点的当前操作状态（每个节点维护它自己的开放式账簿）。由给定服务器的终端用户发起的交易应用于哪个服务器的开放式账簿，但是交易不认为是最终的，直到他们通过共识过程，这个开放式账簿成为最后关闭账簿。
- **唯一的节点列表(UNL):** 每个服务器，s,维护一个唯一的节点列表，是一套s查询的其他服务器，当决定共识。当决定共识时（与网络中的每个节点截然相反），只有s的UNL中的其他成员的投票。 因此UNL代表作为共同的网络子集，被s“信任”不会传统去尝试欺骗这个网络。注意“信任”的定义不要求UNL中的每个个体成员被信任。
- **提案人：** 任何服务器都可以广播需要包含在共识过程的交易，并且每个服务器尝试包含每笔有效交易当一个新的共识阶段开始，但是，只有来自一个s服务器的UNL上的服务器的提议被s考虑。

**2.2 形式化** 

我们用术语 *无错误的*  指的是网络中诚实无错误的节点。相反地，一个 *错误的* 节点是指遇到可错的节点，可能是诚实的（由于数据损坏，执行错误等），或恶意的（拜占庭错误）。 我们把验证一笔交易的概念分为一个简单的二进制的决定问题：每个节点必须从被给定为值为0或1的信息决定。

在Attiya, Dolev, and Gill, 1984[3]中，我们根据如下3个公理来定义共识：

1. **(C1):** 所有无错误的节点在有限的时间内做一个决定
2. **(C2):** 所有的无错误的节点达成相同的决定价值
3. **(C3):** 对所有的无错误的节点，0和1两者都是可能的值。（这个移除了所有节点决定0或1的不重要的解决方式，不管0或1所代表信息）

**2.3 现行的共识算法**

在面对拜占庭错误时达成共识的算法方面，已经有了很多的研究。这个之前的工作包括扩展到情况：网络中的参与者没有被提前知道，当信息异步发送信息（对于一个个体节点用来达成一个决定的时间没有限制），有一个关于强共识和弱共识的定义之间关系的描述。

在共识算法的之前共工作中，一个相关的结果是来自Fischer, Lynch, and Patterson,1985 [4]的，证明在异步情况下，对一个共识算法来说无终止时有可能的，甚至带有错误的过程。这个引入了基于时间启发法的必要性，去确保收敛（或者至少重复非收敛的迭代）。我们将在第三部门中描述Ripple协议的启发式。

共识算法的强度通常用它所能容忍的错误过程的部分的方式来衡量。可证明的是：拜占庭将军问题（已经假定同步并且知道参与者）的解决方案中没有能容忍冲过（n-1）/3的拜占庭错误，或者网络中33%做出恶意行为的[2].这个解决方式不，但是，要求节点之间（数字签名）传输的信息的可验证的真实性。如果信息的不可伪造性的保证是可能的，在同步情况下，算法就可以在一个更高的错误容忍情况下存在。

在同步情况下，对于拜占庭共识有若干的较复杂的算法被提出。FaB Paxos [5]在一个n个节点的网络中将容忍（n-1）/5个拜占庭错误，相当于可以最多容忍网络中20%的节点恶意串通。Attiya, Doyev, and Gill [3]对于异步情况引入一个阶段算法，可以容忍（n-1）/4的错误，至多网络的25%。最终，Alchieri et al., 2008 [6]提出BFT-CUP，可以在异步带有未知参与者的情况下达成拜占庭共识，最多可以容忍（n-1）/3的失败，但是对基础网络的连通性有额外的限制。



**2.4 正式的共识目标**



在这个工作中我们的目标是展示Ripple协议所使用的共识算法能在每个关闭账簿达成共识（即使共识是所有交易被拒绝的不重要的共识），不重要的共识仅仅在一个一致的可能性下达成的共识，甚至面对拜占庭失败。

因为网络中的每个节点只对来自可信节点（在它的UNL中的其他节点）的提议进行投票，同时因为每个节点可能有不同的UNL,我们也显示仅有的一个共识需要到达所有节点，不管是不是UNL成员。目标也是防止网络中的“分叉”：两个不连贯的节点集分别独立的达成共识，两个不同的最后关闭账簿被在美分节点集中的节点观察到。

最后，我们显示Ripple协议能够在面对（n-1）/5失败的情况下达成目标，但是我们也展示Ripple协议处理若干其他加强可用性的其他需要的特点。



**3. Ripple共识算法**

Ripple协议共识算法（RPCA）被所有节点应用到每几秒钟，为了维护网络的正确性和协议性。一旦达成共识，当前账簿被认为“关闭”，并且变成最后关闭的账簿。假定共识算法是成功的，并且网络中没有其他分叉，网络中所有的节点维护的最后关闭账簿是完全相同的。



**3.1 定义**

RPCA循环发生，在每一个循环中：

- 最初，每个服务器获取所有交易，视为优先于共识循环的开始，已经被应用（这些可能包含由服务器终端用户发起的新交易，交易从一个先前的共识处理过延迟等），以一个被称为“候选人集合”列表的形式公开。
- 每个服务器然后合并它UNL中的所有服务器的候选人集合，对所有交易的真实性投票。
- 收到超过最小比列的“是”投票的交易会传递到下一个循环。如果有一个，当一个交易没有收到足够的投票会被丢弃或者包含到下一个账簿的共识处理的开始的候选人集合
- 共识的最后一轮需要最少服务器的UNL的80%同意交易。所有满足要求的交易会被应用到账簿，并且关闭那个账簿，成为新的最后关闭账簿。

**3.2 正确性**

为了达成正确性，考虑到拜占庭错误的最大数量，它必须显示在共识中不可能确认一笔欺骗性的交易，除非错误的节点超过公差。RPCA的正确性证明直接跟随：因为一笔交易只要得到服务器的UNL的80%同意才能通过，只要UNL中的80%是诚实的，没有欺骗性的交易会被批准。因此，对于网络中n个节点的UNL，只要达到如下情况就能保持正确性：

*公式*

f是拜占庭错误的数量。实际上，甚至在面对（n-1）/5+1个拜占庭错误的情况下，正确性仍然可以在技术上被保持。共识过程会失败，但是仍然不可能确认一个欺骗性的交易。事实上，需要(4n+1)/5个拜占庭错误才能让不正确的交易被确认。我们称第二极限为弱正确性极限，称前极限为强正确性。

另外应该注意到不是所有的“欺骗性”交易会造成威胁，即使在共识中确认了。一个用户尝试在两笔资金中双花资金，例如，即使在共识过程中两笔交易都被应用，第二笔会失败，因为自己不再存在。健壮性取决于交易被确切地应，网络中的所有节点应用确切的规则，对交易的相同的集合。

对一个有点不通用的分析，让我们假定任何节点决定串通加入不法联盟的可能性为  pc.正确性的可能性被给定为 p*,：

*公式*

可能性代表补发联盟保持再拜占庭错误最大极限以下的尺寸，给定为pc。因为这个可能性是一个二项式分布，pc的值大于20%会导致期望的联盟尺寸超过网络中的20%，阻碍共识过程。实际上，一个UNL不是随机选择的，而宁可说是以最小化pc为目的。因为节点不是匿名的，而宁可说密码上可辨认的，从大陆，国家，行业，意识形态的混合体中选择节点的UNL，会使得pc的值远小于20%。例如，反诽谤联盟和威斯特布路浸信会串通去欺骗这个网络当然远远小于20%。即使UNL有一个相对大的pc，比如15%，正确的可能性即使仅有200个节点再UNL里也是极高的：97.8%。

不正确的可能性作为一个UNL尺寸的函数，对于不同的pc值的图示在图形1中描述。注意纵轴代表不法联盟阻碍共识的可能性，因此较低的值代表共识成功的可能性更大。如图所示，即使pc超过10%，当UNL增长超过100个节点，共识被阻碍的可能性会很快的变得可以忽略的。

**3.3 一致**

为了满足这个一致要求，必须显示所有非错误的节点在相同的交易集上达成共识，不管他们的UNL。因为每个服务器的UNL可能是不同的，一致无法被正确证明天生地确保。例如，对UNL的成员资格没有限制，当ntotal时整个网络中的节点的数量，UNL的尺寸不超过0.2*ntotal,那么分叉是可能的。这个有个例子可以是哦买（在图2中绘制）：想象在UNL图表中有两个派系，每个都超过0.2* * ntotal.派系，我的意思是每个节点的UNL是节点的相同集的节点集。因为这两个派系不共享任何成员，可能各自独立地达成一个正确的共识，违反一致。如果两个派系的连通性超过0.2*ntotal,那么分叉就不可能存在，因为派系间的不一致会组织共识达到需要的80%的一致门槛。

需要用来证明一致的联通上限被给定为：

*公式*

上限假定一个UNL的类似于派系结构，例如，UNL包含其他节点在这些集合中的节点形式集。这个上限确保没有两个派系能在冲突的交易上达成共识，因为不可能达到共识所需要的80%的门槛。更杨哥上限是可能的，当UNL之间不直接的边缘也被考虑。例如，如果网络的结构不是类似于派系的，分叉会更难达成，由于所有节点的UNL有更多的纠缠。去注意到没有对交叉节点的性质进行假定是有趣的。两个UNL的交叉可能包含错误的节点，但是只要交叉的尺寸大于确保一致所需的极限，错误节点的总数量小于满足强正确所需的极限。换言之，一致仅仅依赖节点交叉的尺寸，不依赖错误节点交叉的尺寸。

**3.4 实用**

当实用的组件时主观的，事实上收敛是可证明的：共识过程会在有限的时间内被终止。

**3.4.1 收敛** 

当定义收敛作为RPCA在账簿里带有很强的正确性达成共识所在的点，并且那个账户成为最后关闭的账户。注意当技术性的弱正确性仍然代表算法的收敛，仅在微小的事件中收敛，当提议C3被违反，并且没有交易被确认过。从以上结果，我们在面对最多(n-1)/5的拜占庭失败时强正确性总是达成，只有一个共识在整个网络中达成共识，只要满足UNL-连通性要求（等式3），共识在有限的时间内达成。

因为共识算法本身是确定性的，有预先调整的寻魂数量，t,在共识被终止前，当前的交易集被宣布通过或不通过（即使这失手没有交易有超过80%的需要的一致，这个共识仅用于细微的共识），对于算法终止的限制因素是节点间的通信延迟。为了限制数量，节点的响应时间被监控，延迟变的币预先设置的限制b还要大的节点会从所有的UNL中移除。当这个保证共识会在一个tb上限内终止，注意描述上述正确性和一致的限制必须被所有的最终UNL满足时很重要的，在将会被丢弃的所有节点被丢弃。如果情况适用所有节点的最初的UNL，但是一些节点由于延迟被移除，正确性和一致性保证不会自动有效，但是必须被新的UNL集满足。

**3.4.2 启发法和程序**

如上所属，延迟限制启发式会对Ripple网络中的苏偶偶节点执行，确保共识算法会被收敛。此外，还有一些其他的启发式和程序对RPCA提供效用。

- 在每个共识循环中，有2秒的时间窗口让所有节点提交他们最初的候选人集合。当这个对每个共识循环提出最低两秒的限制，也可以保证有合理延迟的所有节点有能力参与共识过程
- 当投票会记录在用于共识循环的账本中，节点会被标示和从网络中移除，因为一些常见的易于识别的恶意行为。这些包括在每笔交易上投“否”的节点和持续建议不被共识验证的交易。
- 仔细挑选并展示的默认UNL提供给所有yoghurt，最少数量pc,在3.2中有描述。当用户可以兵器应该选择他们自己的UNL时，默认节点列表确保即使幼稚的用户参加共识过程也能有极大的可能性达成正确性和一致。
- 网络分离检测算法也被用来避免网络中分叉。当共识算法证明在最后关闭的账簿中的交易时正确的，它不禁止在网络中的连通性较差的不同分部催在超过一个最后关闭账簿的可能性。为了尝试和识别是否发生分离，每个节点监测它的UNL的活跃成员的尺寸。当这个尺寸突然降到低于一个预设的门槛，可能一个分离发生了。为了阻止在一个UNL的大部分由临时延迟的情况下的错误的正数，节点被允许公布一个“部分验证”，他们不在里面处理或对交易进行投票，但是声明仍然参与共识过程，与在一个不连接的自网络中形成一个不同的共识过程。
- 当可能只在一个共识循环中应用RPCA，效用通过多个循环获得，每个带有一个最小需要的一致比列，在最后带有80%要求的最后一个循环之前。这些循环允许检测延迟节点，在以些这样的节点导致网络中交易速度的瓶颈。这些节点可以在较低要求的循环中不落后，但是落后并被识别为门槛增加。在一轮共识循环中，可能是一些交易超过80%的门槛的情况，较慢的节点能跟上，降低整个网络的交易速度

**4. 模拟编码**

提供的模拟编码证明RPCA的循环，带有可参数化的特征（网络中的节点数量，恶意节点的数量，信息延迟，等），模拟器从最完美的不一致开始（网络中的一半节点最初提交“是”，其他一般提交“否”），然后开始共识过程，展示每个阶段中网络中的是/否的数量，当节点记忆他们UNL成员的提议而调整他们的提议。当到达80%的门槛，共识达成。我们鼓励读者用定义在“Sim.cpp"开头的常量的不同值来实验，为了熟悉在不同情况下的共识过程。

**5. 讨论**

我们已经描述了RPCA,满足我们上述概述的正确性，一致和效用的情况。结果是Ripple协议能够在大约几秒的时间里处理安全的可信任的交易：用来完成一个共识循环的时间长度。根据在章节2中概述的限制，这些交易被证明是安全的，当在异步拜占庭共识的文献中没有很强的存在，在成员资格中允许快速的收敛和灵活性。当这些放在一起，这些特性使得Ripple网络可以作为一个快速的低成本全球支付网络来运行，同时带有能很好的理解的安全和可靠性性能。

我们展示Ripple协议被证明是安全的，只要等式1和等式3中描述的限制被满足，这个没什么用，这些事最大限制，实际上，网路在显著地不那么严格的情况下可能也是安全的。认识到如下也是很重要的，但是，满足限制不是RPCA本身固有的，而宁可说是需要所有用户的UNL的管理。提供给所有用户的默认UNL已经足够了，但是一个用户对UNL进行改变，必须在理解上述限制的情况下完成。此外，对全局网络结构的监测是需要的，为了确保等式3中的限制可以被满足，一致总是被满足。

我们相信RPCA对于分布式支付系统代表重要的向前一步，因为i低延迟运行许多之前在较高延迟的共识方法很难或者甚至不可能的金融交易类型得以实现。

**6.感谢 **

Ripple实验室想答谢所有Ripple共识算法开发过程中涉及的人员。特别是，Arthur Britto,他在交易集上的工作，Jed McCaleb,首创的Ripple协议共识概念，David Schwartz，他在“失败的一致时一致被延迟”共识方面的工作。Ripple实验室也想大写Noah Youngs，准备和检查这个论文。

**参考文献**

[1] Nakamoto, Satoshi. “Bitcoin: A peer-to-peer electronic
cash system.” Consulted 1.2012 (2008): 28.
[2] Lamport, Leslie, Robert Shostak, and Marshall
Pease. “The Byzantine generals problem.” ACM
Transactions on Programming Languages and Systems
(TOPLAS) 4.3 (1982): 382-401.
[3] Attiya, C., D. Dolev, and J. Gill. “Asynchronous
Byzantine Agreement.” Proc. 3rd. Annual ACM
Symposium on Principles of Distributed Computing.
1984.

[4] Fischer, Michael J., Nancy A. Lynch, and Michael
S. Paterson. “Impossibility of distributed consensus
with one faulty process.” Journal of the ACM (JACM)
32.2 (1985): 374-382.
[5] Martin, J-P., and Lorenzo Alvisi. “Fast byzantine
consensus.” Dependable and Secure Computing,
IEEE Transactions on 3.3 (2006): 202-215.
[6] Alchieri, Eduardo AP, et al. “Byzantine consensus
with unknown participants.” Principles of Distributed
Systems. Springer Berlin Heidelberg, 2008. 22-40.
8








































