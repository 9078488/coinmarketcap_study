下一代智能合约与DAPP平台。

在项目发布之前介绍以太坊的论文，文章后期有过修改。

中本聪在2009开发的比特币被大家奉为对钱和现金的彻底的改变。是第一个没有背书和自身价值，没有中心化的发行者和控制者的数字资产的范列。但是，比特币实验中另外一个大概更重要的是奠定了将区块链技术作为分布式共识的工具的基础，大家的注意力迅速转向比特币的另外一面。目前常被提及的可选择的区块链应用包括:使用上链资产去代表定制货币和金融工具（染色币），基于实体的所有权（智能产权），不可替代的资产（NAMECOIN），还有在代码中加入一部分强制规则直接控制数字资产的更加复杂的应用（智能合约），甚至去中心化的自治组织（DAOs）.以太坊打算提供一个带有内置完全成熟的图灵完备的编程语言的区块链，内置的编程语言可以编写任意状态交易的功能，用户可以编写以上提及的系统，另外还有很多我们现在还不能想象到的系统，仅仅需要用几行代码写出对应的逻辑。

比特币及现存的一些概念介绍

历史

作为状态转换的比特币

挖矿

默克尔树

供选择的区块链应用

脚本撰写

以太坊

哲学

以太坊账户

消息和交易

消息

以太坊状态转换功能

代码执行

区块链和挖矿

应用

代币系统

金融衍生产品和稳定币

身份和名誉系统

去中心化文件存储

去中心化自治组织

更多的应用

杂录和概念

修正版GHOST安装

交易费

计算和图灵完备

货币和发行

挖矿中心化

可扩展性

结论

注解和延伸阅读

注解

延伸阅读

比特币及现存的一些概念介绍

历史

去中心化数字货币的概念和选择性应用，比如财产登记已经出现很久了。乔姆盲签十九世纪八九十年代是匿名的电子现金协议，主要依赖密码原语，可以提供高度隐私的货币。但是由于其依赖于中心化的中间人而没有被大规模的接受。1998年，Weidai的B-money是第一引入用解计算谜题创造货币和去中心化共识的思想的协议，但是缺少怎么实施去中心化共识的细节。2005年，Hal Finney引入可重复的工作证明概念，是一个结合了 b-money的思路和Adam Back的可计算难度的哈希谜题去创建加密货币的概念，但是由于需要依赖可信赖的计算作为前提再次失败。2009年，中本聪第一次使得去中心化在实践中实现，其结合了通过公匙密码管理所有权和被称之为POW的记录谁拥有代币共识机制。

POW背后的机制在空间上是一个重大的突破，因为它同时解决了两个问题：1.它提供了一个简单的适度的共识机制，使得网络中的节点可以共同同意一个权威的对BTC账簿状态的更新.2.它提供了一个允许自由加入共识过程的机制，解决了决定谁可以影响共识的政治问题，同时避免了女巫攻击。它是通过用经济门槛（在共识投票过程中的单个节点的权重直接和这个节点的算力成比例的）代替正式的门槛（比如需要登记成为一个特定名单的机构）。自那以后，有人提出可选择的方案POS，根据所持有的货币的比例计算其节点的权重，而不是根据计算资源。两种方式的优缺点不在本文的讨论范围内，但是值的注意的是两种方式都可用作加密货币的主干网。

这是以太坊创始人Vitalik Buterin关于以太坊的一篇博客。这是另外一篇涉及更多历史的博客。

比特币作为一个状态交易系统




从技术观点来看，加密货币的账簿，比如比特币，可以看作一个状态交易系统。这个“状态”包含所有存在的比特币的所有权状态和一个状态交易函数，这个函数用于获取一个状态和交易并输出一个新的状态作为结果。比如在一个标准的银行系统里，这个状态是资产负债表。交易时一个把X美元从A账户转移到B账户的请求。状态交易函数在A的账户里减少X美元，在B账户里增加X美元。如果一开始A的账户余额少于X美元，状态交易函数就会返回错误。因此，一个函数可以定义成如下形式：

APPLY(S,TX) -> S' or ERROR

在银行系统里定义为如下形式：

APPLY({ Alice: $50, Bob: $50 },"send $20 from Alice to Bob") = { Alice: $30, Bob: $70 }

但是：

APPLY({ Alice: $50, Bob: $50 },"send $70 from Alice to Bob") = ERROR

“状态”在比特币中时所有已挖出的未花费的所有代币（专业的讲为“未花费的交易输出”或UTXO）的集合。每个UTXO有一个面额和所有权人(有一个20字节的地址定义，是一个必须的加密公钥)。一个交易包含多个输入和输出。每个输入包含一个已存在的UTXO的引用和由所有权地址对应的私钥所创立的加密签名，每个输出包含一个加入状态的新的UTXO。

状态交易函数APPLY(S,TX) -> S'可以粗略的定义为如下的：

1.用于在TX的每个输入

如果引用的UTXO不在S里，则返回错误

如果提供的签名不符合UTXO的所有权者，则返回错误

2.如果所有输入的UTXO的面值总和小于输出UTXO的面值总和，则返回错误

3.输出加上所有输出UTXO，减去所有输入UTXO的S'

第一步的前半步防止交易发出者使用不存在的代币，第一步的下半步防止交易发出者使用别人的代币。第二步执行价值保护。为了用这个来支付，协议如下。假设Alice要发送11.7 BTC给Bob。首先，Alice寻找一组属于她的累计不属于11.7 BTC可用的UTXO。实际上，A lice很难得到精确的11.7 BTC。比如说她能得到的最小值是6+4+2=12。那么她就创立一个包含三个输入和两个输出的交易。第一个输出11.7 BTC，Bob的地址是这笔输出的所有权人，第二个输出是生于的“零钱”0.3 BTC，所有权者是Alice本人。

挖矿 




如果我们有权进入可信赖的中心化的服务，系统是否这样实施不是那么重要；它可以如这样描述进行简单的编码，用一个中心化的服务器的硬盘去记录状态。但是我们想试图用比特币建立一个去中心化的货币系统，所以我们需要结合状态交易系统和共识系统，这样可以确保每个人都同意交易订单。比特币的区去中心化的共识过程需要网络中的节点连续不断的试图创立交易打包，又称区块。这个网络打算每10分钟出一个块，每个块需要包含一个时间戳，一个随机数，一个对之前区块的引用（比如它的Hash）以及在上个区块结束后发生的所有交易的列表。随着时间的推进，它将会创造一个持续的，日益增长的区块链，这个区块链可以不断地更新去描绘比特币账本最新的账簿。

检查这个区块是否有效可以用如下范例来表达：

1.检查这个区块所引用的前区块是否存在并有效。

2.检查这个区块的时间戳是否币前去快大，并且在将来小于两小时。

3.在前区块末尾用S[0]去代表状态

4.假设TX是包含n笔交易的区块交易列表，循环0...n-1，设置S[i+1] = APPLY(S[i],TX[i])，如果任何应用返回错误，退出并返回错误

5.返回正确，就在这个区块的末尾把S[n]登记为状态

本质上，区块中的每笔交易必须从在交易执行进新状态之前的工人状态中提供一个有效的状态转变。注意这个状态不以任何方式在区块中编码。它纯粹是由一个有效节点记录的抽象概念，只能从创世快开始为每个区块（安全的）计算，从而在每个区块里应用每笔交易。此外注意矿工把交易打包进区块的顺序，如果在一个区块里由A和B两笔交易，B消费了一个由A创立的UTXO,A在B前面，这个区块就有效，否在就无效。

上述提及的在其它系统中所没有的的有效情况是要求“工作证明”。精确的情况就是每个区块的由256位数字表示的双SHA256 哈希值必须小于一个动态调节的目标（到写到2187为止）。这样做的目的是使区块创立具有计算上面的难度，从而阻止有人通过女巫攻击重做整个区块链使区块链对其有利。因为SHA256是设计成一个完全不可预测的伪随机数函数，建立一个区块的唯一有效方法仅仅是反复试验，重复的增加随机数去看是否和新哈希值匹配。对于~2187的目前目标，网络平均需要进行~269 次的尝试计算，才能找到一个区块。每 2016个区块，网络会对这个目标进行重新校准，因此通常每10分钟由网络中的某个节点创建一个区块。为了给矿工的计算工作付报酬，每个区块的矿工有权在区块里包含一笔给他们自己新挖出的12.5 BTC的交易。此外，任何输入面额大于输出面额的交易，这个差额也会作为“交易费”给矿工。偶尔，这也仅仅是发行BTC的机制，创始状态根本不包含任何代币。

为了更好的理解挖矿的目的，让我们测试下如果由恶意攻击者会发生什么。
因为比特币的基础密码学被认为是安全的，攻击者将会把没有被密码学直接保护的比特币系统的一部分作为目标：交易次序。攻击者的策略很简单：

1.发送100BTC给商店购买商品（最好是可以快速交付的电子产品）

2.等待收货

3.创立一个发送相同的100BTC给自己的另外一个交易

4.使网络相信，他发送给自己的那笔交易时先发生的

一旦第一步发生，一些矿工在几分钟后就会把这笔交易加入到区块里面,比如270号区块。大概1个小时后，另外5个区块会加入到这个链上，在这区块之后。这个区块间接的指向这笔交易，因此确认它。这个时候，商店将会最终接受这笔付款并发货。因此我们假设这是一个数字商品，可以即使交付。现在攻击者创立另外一笔发送100BTC给他自己的交易。如果这个攻击者仅仅把它释放到荒野，交易不会被处理。矿工会尝试运行APPLY(S,TX)会发现TX在消费一个在状态中不再存在的UTXO ，所以攻击者会创立一个区块链的分叉，从挖另外一个版本的指向相同的269号区块作为根源的270号区块，但是用新的交易替代旧的交易。因为区块数据是不同的，这将要求重做工作证明。此外，攻击者的新版本的270号区块有一个不同的哈希值，所以原始的271到275号区块不会指向它。因此，原来的链和攻击者的新链是完全分开的。规则是在分叉长，最长的链会被当作事实。所以，合法的矿工会在275号区块链上工作，而攻击者独自在270号链上工作。攻击者为了让它的链成为最长的，它需要比剩余的网络算力总和还要多的算力去赶上（因此，51%攻击）

默克尔树




左侧：它足以表达仅仅一小部分在默克尔树中的节点去证明一个分支的有效性。

右侧：更改默克尔树的任何部分的任何尝试最终都会导致链上的某处出现不一致。

比特一个重要的可扩展性的特点是区块存储在多层数据结构中。区块的哈希值实际上仅仅是区块数据头的哈希值，大概200字节的一个数据块，其中包含时间戳，随机数，之前的区块哈希值，在区块中存储所有数据的叫做默克尔树的数据结构的根哈希值。默克尔树是一种二级制的树，由一组带有在树底部带有大量包含基础数据的分支节点的节点，一组每个节点是它的两个子节点的哈希值的中间节点，最后是一个由它的两个子节点构成的代表树的最上层的单个的根节点构成。默克尔树的目的是允许区块中的数据逐个的传输：一个节点能从一个来源只下载区块头信息，从另外一个来源来的和它们树相关的一个部分，同时仍然仍保证所有的数据都是正确的。这样能行的原因是哈希值是向上传送：加入一个恶意用户尝试把一个假的交易替换进默克尔树的底部，这个改变会导致上面的节点改变，然后再改变上面的节点，最终改变这颗树的根部和因此改变的区块的哈希值，最终导致协议会把它登记为一个完全不同的区块（几乎必定是一个无效的工作证明）

默克尔树协议被证明对长期持续性是必不可少的。在比特币网络中的一个存储和处理每个区块的整体的全节点，在2014年4月在比特币网络中占据15GB磁盘空间,并且每月超过1GB的增长。现在，对于桌面电脑可行，但手机不行。过些时候，未来商业和业余爱好者能参与。一个叫做“简化支付验证”（SPV）的协议允许另外一类叫做“轻节点”的节点存在，轻节点值下载区块头，在区块头上验证工作证明，然后下载和他们相关的交易的相关的分支。这样使得轻节点只要下载整个区块链的一小部分就能有很强的安全保障下判定任何比特币交易的状态和他们的余额。

替换的区块链应用

以区块链为基础的，并把它应用到其它概念中的想法已经有很长的历史。1998年，Nick Szabo 提出带有所有权者授权的安全财产所有权，一个描述“重复的数据库技术的新进展”可以允许以区块链为基础的系统去储存谁拥有哪块土地的登记信息的文档，建立了一个详尽的包含移民生活，相反占有权，格鲁吉亚土地税等概念的框架。但是不幸的在那个时候没有有效的重复的数据库系统，所以这个协议实际上从来没有被实施。2009年后，一旦比特币的去中心化共识被发展出来后，许多可替代的应用涌现。

域名币-2010年建立，域名比最准确的描述是一个去中心化的域名注册数据库。在去中心化的协议中，比如Tor, BTC，比特信,他们需要一些方法去识别账户，然后其它人可以和它互动，但是在已存在的方案中，唯一能用的标识符是一种伪随机数的哈希值，比如1LW79wp5ZBqaHW1jL5TCiBCrhQYtHagUWy。理想的情况下，人们希望可以用类似于“George”的名字。但是，问题是如果一个创建了一个叫“George”的账户，其它人也能用相同的过程把“Geoge"登记为他们自己的名字，并模仿它。唯一的解决方法是先申请范例。当第一个注册者注册成功后，第二个注册者就会失败。一个完美的适合比特币共识协议的问题。域名币是最古老的，最成功的，用这个思路来做的域名登记系统的实例。

染色币-染色币的目的是充当一个允许人们创造他们自己的数字货币的协议，或者在比特币网络中一个货币一个重要的简单情形，只有一个单位的数字代币。在染色币协议中，一个人通过公开的对一个特定的比特币UTXO赋予一个颜色去发行一个新的货币。这个协议递归地定义其它UTXO的颜色和交易建立他们花费的输入的颜色一样（在混合色输入的情况下会应用一些特殊的规则）。这允许用户去维护仅包含特定颜色的UTXO的钱包，并类似于常规比特的方法发送他们，通过区块链跟踪去决定他们所收到的任何UTXO的颜色。

 元币-元币背后的思路是有一个基于比特币的协议，用比特币交易去存储元币交易，但是又一个不同的状态转换函数，APPLY'。因为元币协议无法阻止无效的元币交易出现在比特币交易中，所以增加了一个规则：如果APPLY'(S,TX)返回错误，这个协议默认APPLY'(S,TX) = S。这是创立任意的无端的加密协议的简单的机制，潜在的带有不能再比特币自己身上实施的高级特征，但是开发成本非常低，因为挖矿的复杂性和网络已经通过比特币协议处理。元币被应用的一些财务合约，姓名登记和去中心化交易所。

因此，总体上又两种方式建议共识协议：建议一个独立的网络和建议一个基于比特币的网络。前一种方式很难实施，当其合理的在域名币合理的成功的情况下。每个独立的实现需要启动一个独立的区块链，并且建立和测试所有的状态转换和网络代码。此外，我们预测这套用于去中心化共识技术的应用遵循幂次分布，大多数应用将会太小而不能保证其自己的区块链，并且我们注意到存在大量的去中心化应用，特别是去中心化自治组织，需要相互之间互动。

另外一方面，以比特币为基础的方式有一个缺点，它不继承比特币的简化支付验证的特点。SPV对比特币有用，是因为它可以用区块链深度代表有效性。在某一时刻,一旦一笔交易的祖先追随足够远，就可以安全的讲它是状态的合法的一部分。基于区块链的元币协议，从另外一方面看，不能强迫区块链不去把具有自己协议环境的无效交易包含进来。因此，一个完全安全的安全的SPV协议实现需要一直回溯扫描到比特币区块链的开头去去判定特定的交易是否有效。一般，所有基于比特币的元币协议的轻量级的实现都依赖一个可信的服务器提供的数据，可以说这是一个次佳的结果，特别是当一个加密货币的目的是去除对信任的需要。

脚本撰写

即使没有任何扩展，比特币协议实际上可以帮助实现智能合约概念的初级版本。比特币中的 UTXO只能由一个公钥拥有，也能用更加复杂的用简单的基于栈的编程语言表达的脚本。在这种模式中，一个花费交易的UTXO必须提供符合这个脚本的数据。甚至，即使基础的公钥所有权机制通过一个脚本来实现：脚本将椭圆形曲线签名作为输入，对交易和拥有UTXO的地址进行验证，如果验证成功就返回1，否在就返回0.另外，更加复杂的，脚本应用于各种各样额外的情况。比如，一个人编写要求三个给定私钥中的两个签名去验证（ 多重签名）的脚本，是对合作账户、安全储蓄账户和一些商业第三方存管有用的设置。脚本也可以用于支付奖金给计算问题的解决方案，甚至可以编写这样的脚本如果你可以提供你发送了一个这个面额的狗狗币交易给我的SPV证明，这个比特币UTXO就是你的，本质上允许去中心化的跨加密货币的交易所。

但是，部署在比特币上的脚本语言由如下重要的的缺陷：

缺乏图灵完备-这是说，当出现大的比特币脚本语言支持的计算子集，它几乎不支持所有事情。主要缺少的范畴是循环。这样做是为了在交易验证时避免无限循环；理论上上，对于脚本程序设计员来说时一个可克服的障碍，因为任何循环可以用带有If语句的基础代码简单的重复许多遍，但是这会导致脚本在空间使用上很低效。比如，实施一个可替代的椭圆形曲线签名算法将需要在代码中独立的包含 256 次乘数循环。

价值盲区-没法让一个UTXO脚本提供一个对可取金额的深入的控制。  一个拥有强大用途的语言合约会是一个套头交易契约，在这里，A和B放进价值 $1000 的BTC，30天后，脚本发送价值$1000 的BTC给A，剩下的给B.这将需要一个预言机去判定1BTC的美元价格，但是即使那样，相对现存的全部中心化的解决方案，在信任和基础设施需求方面是一个重大的进步。但是UTOX是所有或没有,所以唯一完成的方式是通过许多不同面值的UTXO的应付（比如，一个 2k的UTXO,每K最多30），让O去选取发送给A和B的UTXO.

缺少状态-一个UTXO可以在花费和未被花费，没有机会实施保留超出这个的其它内部状态的多级的合约或脚本。这使得很难取做多级选项合约，去中心化交易所的出价，两级加密承诺协议（对安全的计算奖励很有必要)。这也意味着UTXO 只能用于建立简单的一次性的合约，而不是更复杂的状态性的合约，比如去中心化的组织，这让元币协议很难实施。二进制状态加上价值盲区也意味着另外一个重要的应用，取款限制没办法实现。

区块链盲区-UTXO 不了解区块链数据，比如随机数，时间戳和前一个区块的哈希值。这通过剥夺脚本语言的不可测性的可能的价值来源严重限制了在博彩和若干其它领域的应用。

因此我们看到在加密货币基础上，我们有三个方法去建立高级的应用：建立一个新的区块链，用基于比特币的脚本，和建立一个基于比特币的元币协议。建立一个新区块链可以使得在建立特征集的时候拥有无限的自由，但是以开发时间，引导工作和安全为代价。用脚本很容易实施和标准化，但是会非常限制它的性能，元币协议，简单，但是又扩展性方面的缺陷。用以太坊，我们想建立一个可替代的框架，提供一个开发简单但收获更大，甚至更强大的轻量级客户端性能，同时允许应用共用一个区块链经济和安全。

以太坊

以太坊的目的是建立一个用于建立去中心化应用的可替代的协议，提供一天要完全不同的交易，我们相信它将对大量的去中心化应用十分有用，特别注重快速的开发时间，小型的很少用的应用的安全性，和不同应用高效的交互是重要的。以太坊通过必要的根本的抽象的基础层来做这些：内置图灵完备编程语言的区块链，允许任何人编写智能合约和去中心化应用，可以建立任意关于所有权，交易格式和状态转换函数的规则。可以用两行代码去编写最基本的域名币，用低于20行的代码建立比如货币和荣誉系统的其它协议。也可以基于这个平台建立智能合约，包含价值的加密盒子只有在一定的条件被满足后才会解锁。因为增加了图灵完备，价值意识，区块链意识和状态的能力，比比特币脚本提供更多的能力。

哲学

以太坊的设计打算遵循以下原则:

1.简易：以太坊协议应该尽可能的简单，即使在数据存储和时间损失的成本上面。一个普通的程序员能理想地可以遵循和实施说明书。以致完全能认识到史无前例的加密货币带来的民主潜能。而且，以太坊的愿景是作为对所有人开发的协议。会增加复杂性的优化应该不被包含，除非这个优化能带来大量的好处。

2.普遍性：以太坊的设计哲学的基础部分是没有特点。反而，以太坊提供一个内置的图灵完备的脚本语言，程序员可以用它来创建任何智能合约或者可进行数学定于的交易类型。想创造你自己的金融衍生产品？用以太坊，你想创造自己的货币？把它设置成以太坊合约。想建立一个全面的后台程序或天网防火墙？你或许需要几千个连锁的合约，并且确保慷慨的增进它，做这个，但是没有什么可以阻止你是由触手可及的以太坊。

3.模块性：以太坊协议的各个部分尽可能做的模块化和可分离的。在开发课程中，我们的目的是建立一个程序，在一个人在一个地方制作一个小的协议修改，应用套件在没有任何修改的情况下继续运行。创新，比如Ethash（参照黄皮书附录或wiki文章），修改的帕特里夏树（黄皮书，wiki）,和RLP（黄皮书，wiki）应该是单独的功能齐全的库。因此，即使他们在以太坊中使用，即使以太坊不需要某些特性。这些特性也可以用在其它协议中。以太坊要最大可能的这样做，去造福整个加密货币的生态系统，而不仅仅是自己。

4.灵活：以太坊的详情不是一成不变的。尽快我们是非常明智的修改为更改为高级构造，比如用分片路线图，抽象执行，将数据的有效性加入共识。随后的开发过程中的计算测试会让我们发现这些更改，比如对协议架构或对以太坊虚拟机器（EVM）,充分的提高可扩展性或安全。如果发现任何这样的机会，我们会开发它。

5.非歧视性和非审查：这个协议不应该积极的限制和阻止特殊类别的使用。协议中的所有管理机制应该设计成有系统的管理危害，而不是尝试反对特别的不良的应用。一个程序员甚至可以在以太坊上运行无限循环，他们愿意支付每计算步交易费多长时间，就可以运行多长时间。

以太坊账户

在以太坊里，状态由称作“账户”的对象构成，每个账户由一个20字节的地址，状态转换是直接在账户之间直接转移价值和信息。以太坊账户包含四个字段：

随机数-用来确保每笔交易只能被执行一次的计数器

账户的当前以太坊余额

账户的合约代码，如果存在

账户存储（默认为空）

以太币是以太坊内部主要的加密燃料，用来支付交易费。通常由两种类型账户：外部所有的账户，由私钥控制，合约账户，由他们的合约代码控制。外部所有的账户没有代码，通过建立和签署一笔交易，可以从外部所有账户发送信息；在一个合约账户，每次合约账户收到一个消息，它的代码就会激活，允许它读写内部存储器和依次发送其它信息或者创立合约。

注意以太坊中的合约不应被视作应该被履行或遵守的某些东西。而是更像以太坊执行环境里的自治代理。当被一个消息或者交易戳一下时，总是执行一段特定的代码，并且对其以太坊的余额有直接的控制权，他们自己的私钥/价值存储跟踪永久变量。

消息和交易

在以太坊中所使用的术语“交易”是指签署的存储一个从外部所有账户发出的信息的数据包，交易包括：

收到一个消息

识别发送者的签名

发送发发给接收方的以太坊金额

可选数据字段

一个STARTGAS值，代表最大允许花费的计算步数交易执行

一个GASPRICE值，代表发送方支付给每个交易步的费用

前三个时在任何加密货币中都期望的标准字段，数据字段默认没有函数，但是虚拟机器有个合约可以调用数据的操作码。比如，一个合约的功能是链上域名登记服务。它将解释传给它的包含两个字段的数据，第一个字段是登记的域名，第二个字段是登记的IP地址。合约将会从消息数据中阅读这些值，并对其进行合适的存储。

STARTGAS和GASPRICE对以太坊的服务模型的反拒绝是非常重要的。用来防止意外的或敌意的无限循环或在代码中的其它计算浪费，每笔交易都需要设置一个它能使用的代码执行的计算步数的上限。计算的基本单位是"gas",通常，一个计算不算消耗1gas,但是一些操作消耗更好的gas,因为它们从计算方面上讲更昂贵或者增加了需要存储的作为状态的一部分的数据数量。在交易数据中，也有一个5gas/字节的交易费用。费用系统的目的是要求攻击者为他们消耗的资源支付对应的费用，包括计算、带宽和存储。因此任何导致消耗更多数量的任何这些资源的交易必须有和增量对应的gas费用。

消息

合约可以给其它合约发送“消息”。消息是从不连续的虚拟对象，仅仅在以太坊执行环境中存在。一个消息包含：

消息的发送者（暗含的）

消息的接受者

和消息一起转移的以太币金额

一个可选字段

一个STARTGAS值

本质上，一个消息就像一笔交易，除了它是由合约产生的，而不是外部行动者。当一个合约当前执行代码执行用来生成和执行消息的CALL操作码，便生成消息。和交易类似，消息会使得接受方的账户运行它自己的代码。合约之间发生关系的方式和外部角色的做法相同。

注意由交易或合约分配的GAS限额适用于交易和子操作消耗的GAS总和。比如，如果外部角色用100gas发送一笔交易给B,在发送一个消息给C之前B消耗了600gas,在返回之前，C的内部执行消耗了300gas,然后在用完GAS之前，B还可以消耗100gas。

以太坊状态转换功能


以太坊的状态转换功能，APPLY(S,TX) -> S'，可定义如下：

1.检查交易是否符合语法规则（比如，值的数字正确），签名有效，随机数和发送者账户的随机数匹配。如不，返回错误。

2.用STARTGAS * GASPRICE计算交易费，从签名中判定发送者地址。从发送者的账户余额里减去交易费和增加发送者的随机数。如果余额不足，则返回错误。

3.初始化GAS = STARTGAS，拿走一定数量的gas//字节去支付交易中的字节。

4.将交易金额从发送者账户发送到接收者账户。如果接受者账户不存在，建立一个。如果接收者账户是一个合约，运行合约代码，完成或者直至Gas消耗完。

5.如果因为交易者没有足够的钱或者代码执行消耗完了GAS,价值传输失败，将状态改变恢复原样，除了支付的交易费，交易费会增加到矿工的账户里。

6.否在，退还剩余的交易费给发送者。将消耗的GAS的交易费发送给矿工。

比如，假设合约代码如下：

if !self.storage[calldataload(0)]:

    self.storage[calldataload(0)] = calldataload(32)

注意，实际上合同代码是写在低级别EVM 代码里。这个代码是写在Serpent里，是一种高级别语言，为清楚起见，能够编译成EVM代码。价格合约的存储一开始是空的，一个交易时发送10ether的价值，2000gas,0.001ether 交易费价格，64字节的价格。字节 0-31代表数字2， 32-63代表字符串CHARLIE。状态转换功能过程在这个情况下如下：

1.检查这个交易是有效的和完整的

2.检查交易发送者至少有 2000 * 0.001 = 2 ether。如果是的，从发送者账户扣除2ether。

3.初始化gas=2000,假设这个交易是170字节长，字节交易费是5，减掉850，剩下1150。

4.从发送者的账户里减掉10ether,并把它加到接收者的账户上。

5.运行代码。假若这样，这就简单了：它将检查如果索引2的合约存储被使用。注意它若不是，将存储设置在索引2上，值设置为charlie。假设这个消耗 187gas,剩下的gas金额是：1150 - 187 = 963

6.将963 * 0.001 = 0.963 ether 的增加回发送者的账户，并返回结果状态。

在交易的接收端，如果没有合约，总的交易费是简单地和给定的GASPRICE乘上交易字节的长度相等，并且和交易一起发送的数据不相关。

在恢复原样方面，注意消息和交易等同工作：如果一个消息执行用完GAS。然后消息执行和所有和由这个执行触发的执行，恢复原样，但是根源执行不需要恢复原样。这意味着一个合约调用另外一个合约是安全的。如果A用Ggas调用B，A的执行被保证最多失去G gas。最后，注意由一个操作码，CREATE，建立一个合约，它的执行机制一般和call类似，没有例外，执行的输出决定一个新建立的合约的代码。

代码执行

以太坊中的合约代码是用低级别的，基于栈字节码语言来写的，被称为“以太坊虚拟机器代码”或“EVM代码”。这个代码包含一连串的字节，每个字节代表一个操作。通常，代码执行时一个包含在目前的程序计数器（从零开始）并在项目计数器上增加1的重复执行操作的无限循环 ，直到到达代码结尾或者一个错误或STOP 或 RETURN 说明被探测到。这个操作可以利用存储数据的三种空间：

-栈，后进先出值可以增加或减去的容器

-存储器，一个极其可扩大的字节数组

-合约的长期存储，一个键或值的存储。不像栈和内存，在计算结束后会被重置，存储长期存续。

代码可以访问这个值，发送者和进来消息的数据，和区块头数据，可以返回数据的字节数组作为输出的代码。EVM代码正式执行的模型是惊人地简单。当以太坊虚拟机器运行，完全的计算状态可以通过元组定义(block_state, transaction, message, code, memory, stack, pc, gas)，block_state是一个包含所有账户，包含余额，包含存储的总体状态。在每一轮执行的开始， 现行指令取code的pcth字节找到，   在如何影响数组方面，每个指令有其自己的定义，比如从栈中加两个并增加他们的总和，gas减1，pc加1。SSTORE从栈中减掉两个上面的项目，在合约储存中在由第二个项目规定的指数处插入第二个项目，然而通过即时编译有许多办法可以优化以太坊虚拟机器，一个基本的以太坊实现可以通过几百行代码实现。

区块和挖矿




以太坊区块链在许多方面和比特币区块链类似，尽管它们肯定有一些不同。关于区块构架，以太坊和比特币主要的不同是，不像比特币（只包含一份交易列表），以太坊区块包含他们两者：交易列表和最近的状态，除此之外，两个其它值，区块数值和难度也存储在区块当中。以太坊中基本的区块有效算法如下：

1.检查引用的前区块是否存在并有效。
2.检查区块的时间戳大于引用的前区块，少于未来15分钟。

3.检查区块数字，难度，交易根源，叔根源，gas上限（各种各样的低级别的以太坊特有的概念）是否有效

4.检查区块上的工作证明是否有效

5.在前区块的末尾，让S[0]作为状态

6.让TX作为含有n笔交易的区块列表，对于所有i in 0...n-1, set S[i+1] = APPLY(S[i],TX[i])，如果任何应用返回错误，或者区块总gas消费超过GASLIMIT，返回错误。

7.设置S_FINAL为S[n]，但是增加付给矿工的区块奖励。

8.检查状态S_FINAL的默克尔树根源和区块头提供的最终状态根源相等。如果是，区块有效，如果不是，则无效。

乍一看，这些方法看上去很不高效，因为它需要用每个区块存储状态，但实际上，效率是比的上比特币的。原因是状态存储在树形结构里，每个区块后只有一小部分需要改变。因此，一般而言，两个相邻的区块的树的大部分都是一样的，因此数据可以储存一次，通过指针引用两次（比如，子树的harsh）,一种特殊的叫做帕特丽夏树可以完成它，包括对默克尔树概念的一个更改，允许节点高效地插入或删除，不仅仅是更改。此外，因为所有的状态信息是上个区块的一部分，所以没有必要存储整个区块链历史，这个策略如果应用到比特币中，可以在空间里提供5-20x的存储。

一个常被问到的问题是合约代码在"sh哪里"执行，在物理硬件方面。这有个简单的回答：执行合约代码的过程是状态转换函数定义的一部分，是区块验证算法的一部分。如果一笔交易增加到区块B,交易产生的代码执行由所有现在和未来下载和验证区块B的节点执行。

应用

通常，在以太坊上有三种类型的应用。第一类是金融应用，给用户提供更强大的管理和进入使用他们钱的合约方法。包括替代货币，金融衍生工具，套头交易契约，储蓄的钱包,遗嘱,最后甚至全面的雇佣合约。第二类是半金融应用，涉及钱，但是又很多非货币方面的工作需要做。最完美的例子时自我实施的算力解决方案问题的赏金。最后，一些应用，比如，投票，去中心化治理等和金融完全无关的。

代币系统

链上代币系统有很多应用，从替代资产，比如USD，黄金，公司股票的替代货币，代表智能产权，安全的不可伪造的优惠券的个人代币，甚至和传统价值根本没有关系的代币系统，用作激励的分数制度。在以太坊上部署代币系统惊人地简单。理解这个的关键点是货币，代币系统从根本上是一个带如下操作的数据库：从A处减掉X单位，把X单位增加给B，还有两个条件，（1）在交易之前，A至少有X个单位（2）交易得到A正式认可的。部署一个代币系统所要做的是把这个逻辑做到合约里。

在 Serpent中部署一个代币系统最基本的代码如下：

def send(to, value):

    if self.storage[msg.sender] >= value:

        self.storage[msg.sender] = self.storage[msg.sender] - value

        self.storage[to] = self.storage[to] + value

这是上述文档中描述的银行系统状态转换函数的必要的逐字的实施。还需要再增加一些额外行数的代码来提供起初分发货币单位的第一步，和其它一些边缘情况，理想地，增加一个函数使得其它合于可以查询一个地址的余额。但是，这是所有的。理论上，基于以太坊的代币系统作为子货币系统可能包含另外一个链上基于比特币的元币货币所缺乏的一个重要特点，直接来用那个货币来支付手续费的能力。它将实施的方法是合约将维护一个 ether余额，用其偿还ether去支付给发送者手续费，通过收集内部获得手续费并转卖的持续的运行拍卖的货币单位，将会再装满余额。用户需要用ether去激活他们账户，但是一旦有ether，就可以重复使用，因为合约每次都会退还。

金融衍生产品和稳定币

金融衍生产品是智能合约的最普通的应用和在代码中实施的最简单的，实施金融合约的主要挑战是他们大部分需要引用外部价格触发器;比如，一个合适的应用是一个 套期保值来对抗ether的关于美元的波动性，但是做这个需要知道合约知道ETH/USD 的值。最简单的方法是通过由特定方（ 比如NASDAQ）维护的“数据供应”合约，这样这一方就能有能力根据需要更新合约。提供一个允许其它合约给那个合约发送一条消息，取回提供价格的回复。

考虑到这些决定性的组成部分，套头交易契约看上去像如下这样：

1.等待A方投入1000ether

2.等待B方投入1000ether

3.记录1000 ether的价值，根据查询数据供应合约来计算，在存储里，说明这是$x

4.30天后，允许A或B"恢复合约的活动"去发送价值为 $x的ether(根据再次查询数据供应合约得到新价格去计算)给A，剩下的给B

这样的合约在加密商务里有重大的潜能，加密货币的其中一个主要问题是其不稳定性。但是有一些用户和商人也许想安全便利的处理他们的加密资产，他们也许不想面对一天失去他们资金价值的23%的预期。直到现在，最常被提议的是证券发行者支持的资产，这个想法是一个发行者创造一个子货币，他们可以创造或废除单位，它将会给任何提供他们（线下）一个单位标的资产（比如USD或黄金）的任何人一个单位这种货币。这个发行者然后承诺提供一个单位的标的资产给任何返还一个单位加密资产的任何人。这个机制允许任何非加密资产升级为加密资产，假如发行者可信任。

实际上，但是，发行者不是总是可信任的，在一些情况下，银行的基础结构太脆弱，或太敌对，对于这样的服务存在。金融衍生产品提供了一个替代。这里，一个去中心化的赌加密参考资产（比如，ETH）的价格会上升的投机者市场扮演这个角色，而不是单个的提供资金支持资产的发行者。不像发行者，投机者没有选择去默认契约的它们一方，因为套头交易契约根据协议将它们的资金由第三者暂为保管。注意，这个方式不是完全去中心化的，因为仍然需要一个可信任的来源提供价格触发器。虽然可论证地在基础设施需求发面甚至有一个重大的改进（不像一个发行者，发起一个价格输入不需要任何许可）和减少诈骗的可能性。

身份和荣誉系统

所有替代加密货币中最早的，Namecoin,尝试去使用一个像比特币的区块链去去提供一个域名登记吸系统，用户可以在公共数据库和其它数据一起登记它们的域名。主要的引用的使用场景是DNS系统，把类似于"bitcoin.org"的域名（或者在域名案例中，"bitcoin.bit"）映射到IP地址。其它使用的情况是Email证明，或者潜在的更先进的荣誉系统。这是一个在以太坊上提供一个像域名币的姓名登记系统的基本的合约：

def register(name, value):

    if !self.storage[name]:

        self.storage[name] = value

这个合约非常简单，可以被增加的以太坊网络上的数据库，不能被更改或移除。任何人都可以带有一些值的名称，并且这个登记将永远存在。一个更加复杂的域名登记系统也会有一个允许其它合约查询它的“函数子语句”，也有一个可以让域名所有权者（比如，第一个注册的）改变数据或者转让所有权的机制。在上面甚至可以增加荣誉和web信任功能。

去中心化文件存储

在过去的几年里，涌现出许多流行的在线文件存储的初创企业，最突出的是Dropbox，争取用户上传一份它们硬盘的备份，有存储备份的服务，用免费一个月作为用户进入的交换。但是，这时候文件存储市场有时相对低效。对于现有方案的一个粗略的看法是,特别是在“恐怖谷” 20-200 GB层级的，既没有免费额度，也没有公司层级的折扣，主流存储的每月价格比你单个月付支付的整个硬盘成本还要高。以太坊合约允许发展一个去中心化文件存储生态系统，个体用户可以通过租出它们自己的硬盘赚取少量的钱，没用的空间可以用作更远的降低文件存储成本。

这样一个装置的支柱部分是叫做“去中心化Dropbox合约”。这个合约工作如下。第一，一个人把想要的数据分解为区块，加密每个区块来保证隐私，此外建立一个默克尔树。然后建立一个由如下规则的合约，每N个区块，合约将会在默克尔树中获取一个随机的索引（用前区块的hash,从合约代码进入，作为随机性的来源）。给第一个提供SPV交易的实体x ether, 像树中的特别索引中区块的所有权证明 。当一个用户想重新下载它们的文件，它们可以使用一个微支付渠道协议（比如，支付1Szabo/32字节）去恢复文件，手续费最优的方案是让支付者直到最后才发布交易，而不是代替用一个相对获利更多的用同样的随机数每32字节后的交易替代。

这个协议的重要的特点是，虽然看上去像一个人信任许多随机节点不会决定忘记它，一个可以通过秘密分享将文件分解为很多片将风险降到接近0，查看合约可以看到每片任然为一些节点所有。如果一个合约仍然付款，那就提供一个加密的证明某个人仍然存储文件。

去中心化自治组织

“去中心化自治组织”大体的概念是，由一定量成员或股东的虚拟实体，或许，由67%的大多数，就可以使用实体的资金或者修改代码。成员共同决定组织如何分配资金。分配DAO的资金的方式从奖金，工资到甚至更独特的机制，比如，奖励工作的内部货币。这个本质上是复制传统公司或非盈利组织的法律外表，只是用加密区块链技术执行。目前大量关于DAOs 的讨论围绕DAC资本主义模型进行，有分股份的股东和可交易的股份；作为替代，或许描述为“去中心化自治社区”在做决定时让所有成员有相同的话语权，需要67%的现有成员同意才可以增加或删除一个成员。一个人只能有一个会员身份需要由团体共同实施。

如何编程一个DAO的大纲如下。最简单的设计仅仅是，如果三分之二同意一个变更，自我改变的代码的一部分改变。虽然代码理论上是不可变的，一个人可以很简单地应付这个问题，通过在单独的合约里拥有代码块，去拥有可变性。在一个DAO的合约里的简单的实施，有三种交易类型，由交易中提供的数据去辨别：

- [0,i,K,V]用索引i去登记一个提议，改变存储索引为K的地址的值为V。

- [1,i]登记一个支持提议i的投票

- [2,i]完成提议i如果由足够的投标

这个合约会为当中的每一个提供子语句。它会维护一个所有开放的存储改变的记录，和谁给它投标的列表。它也由一个所有成员的列表。当存储改变得到三分之二成员的投票，最后交易就会执行这个改变。一个更复杂的纲要是有内置的投票能力，对于发送交易，增加移除成员，甚至提供清楚的明主形式的投票授权（比如，任何人可以指派某个人给其投票，指派是可迁的，如果A指派B，B指派C，那么最后C决定A的投票）。这个使得DAO可以有组织地成长为一个去中心化社区，允许人们最终委托过滤掉对于专家谁是会员的任务，虽然不像在现在的系统里，专家可以随着时间轻易的加入或去掉现有的因为个体社区改变它们的结盟。

对于去中心化公司的一个替代模型，一个账户可以有0或者更多的股份，需要三分之二的股份去做决策，一个完整的纲要涉及资产惯例功能，买卖股票的能力，接受出价的能力（最好在合约里有一个订单匹配机制）。委托也存在于流动明主类型，生成一个董事会的概念。

更多的应用

1.储蓄钱包。假设Alice像让的资金安全，她担心自己丢了或者其它人黑了她的私钥。她把ether放在一个有BOB,一个银行，如下合约里：

- Alice单个人最多每天能提取资金总额的1%

- Bob单个最多每天能提取资金总额的1%，但是Alice有能力用她的KEY做一个关闭BOB这个能力的交易。

- Alice和Bob一起可以提取任何金额

通常，1%每天对Alice足够了，如果Alice想提取更多，可以联系BOB寻求帮助。如果Alice的Key被黑了，她可以跑到BOB那把资金转到另外一个新合约里。如果她丢了KEY,BOB最终会把资金取出来。如果BOB原来是恶意的，她可以关掉他提现的能力。

2.公司保险。一个人可以很简单的做一个金融衍生工具，但是用天气作为数据供应，而不是任何价格指数。如果爱荷华州的农民购买一个金融衍生产品，基于爱荷华州的降雨相反的付出，然后，如果干旱，农民就会自动收到钱，如果有足够的雨，农民就会高兴，因为他们的庄家会丰收，通常这可以扩展到其它自然灾害的保险上。

3.去中心化的数据供应。对于差异的金融合约，实际上通过叫做SchellingCoin的协议有可以对数据供应去中心化。SchellingCoin基本按照如下工作：N方在系统里输入规定数据（比如ETH/USD价格）的值，值被存储，在第25个百分位到75个百分位的每个人会得到一个代币作为奖励，每个人都有提供其它人也会提供的答案的动机，唯一的大部分参与者都会现实地同意的是明显的默认值：事实。这个可以创建一个去中心化的协议，理论上可以提供任何值的数字，包括ETH/USD的价格，柏林的温度或者甚至特别难的计算的结果。

4.智能多签托管。比特币允许多签交易合约，比如，指定5把私钥的3个就可以花费资金。以太坊允许更多的粒度。比如，五个当中的四个可以花费所有，五个当中的三个最多每天可以使用10%，五个当中的两个最多每天可以使用 0.5% 。此外，以太坊的多签是异步的-两方可以在不同的时间在链上登记签名，最后的签名会自动发送交易。

5.云计算。EVM技术也可以用来建立一个可证实的计算环境，允许用户去要求其它人完成计算，然后可选择的要求提供在一定的随机选择的检查点完成的很好的证明。这可以建立一个云计算市场，用户可以用他们的桌面电脑，笔记本或专门的服务器参与， 抽检和押金可以用来确保系统是可信任的（例如，节点不能获益地作弊）。然后，这个系统可能不是适用于所有的任务。比如，需要更高界别的工序间交流不是很容易由许多云节点完成。其他任务，但是，更简单地使程序（适合）进行计算；像ETI@home, folding@home和遗传算法项目可以很容易的在这个平台上实施。

6.点对点的赌博。任何数量的点对点赌博协议，比如， Frank Stajano and Richard Clayton's Cyberdice，可以在以太坊区块链上实施。最简单的赌博协议实际上仅仅是关于下一个区块哈希值的不同的一个合约。更高级的协议也在这个基础上建立，建立近零交易费的不能作弊的赌博服务。

8.预测市场。提供一个预言或SchellingCoin，预测市场也容易实施，预测市场和SchellingCoin可能证明为第一个主流的futarchy的应用，作为去中心化组织的管理协议。

9.链上去中心化市场。用身份和荣誉系统作为基础。

杂集和担心

修改的GHOST实施

“贪婪的最重的观察的子树” (GHOST) 协议是一个第一次是在2013年12月被Yonatan Sompolinsky 和Aviv Zohar采用的一个创新。GHOST背后动机是带快速确认时间的区块链目前由于高陈旧率降低了安全性-因为区块需要一定的时间在网络里传输。如果矿工A挖到一个区块，然后矿工B碰巧挖到另外一个区块，在矿工A的区块传送到B之前。矿工B的区块将会以浪费结束，不会有助于网络安全。此外，由一个中心化的事件：如果矿工A是一个由30%算力的矿池，矿工B由10%的算力，A就会在70%的时间里有产生陈旧的区块的风险（因为其它30%的时间A产生最后的区块，所以会立即得到挖矿数据）然而B会在90%的时间里有产生陈旧区块的风险。因此，如果区块间隔足够小使得陈旧率过高。一个意愿本质上仅仅通过尺寸的优点会更有效。结合着两个影响。产生区块快的区块链可能导致一个矿池有足够比例的网络算力去实际上控制挖矿过程。

Sompolinsky和Zohar描述， GHOST 解决了网络安全缺失的第一个事件，通过把陈旧区块包含到哪个是最长链的计算里。换言之，不仅仅是一个区块的父区块或进一步的祖先区块，还有区块祖先的陈旧子块（以太坊术语，“叔伯”）被增加到 哪个区块有最大的支持它的工作证明的 计算里。去解决第二个时间中心化偏向，我们胜过 Sompolinsky和Zohar提出的协议，给陈旧的区块也发放奖励：一个陈旧区块收到基础奖励的87.5%，侄区块包含陈旧区块的收到剩下12.5%。交易费，但是，不奖励给"叔伯"。

以太坊实施一个简化版的GHOST,仅仅下降7个层级。明确地，定义如下：

- 一个区块必须指定一个父区块，必须指定0个或多个叔伯区块-

- 包含在区块B的叔伯区块必须由如下属性：

- 它必须有一个B的第K代祖先的直接子块，2 <= k <= 7。

- 它不能是B的祖先

- 叔伯区块必须有一个有效的区块头，但是不需要是一个之前被验证过的或者甚至有效的区块

- 叔伯区块必须和包含在前面的区块里的叔伯区块不同，和其它包含在相同区块里的叔伯区块不同（非双重包含）

- 在区块B在每有一个叔伯B，区块B的矿工获得额外 3.125% 的基础奖励，矿工U获得 93.75%的一个标准的交易奖励

这个GHOST的限制版本，可包括在内的叔伯仅仅最多7代，因为两个原因被采用。第一，无限制的版本包含过多的复杂到哪个指定区块的叔伯是有效的计算。第二，用在以太坊中的有补偿的无限 GHOST去除了矿工在主链挖矿，而不是到公开攻击者的链上挖矿的动机。

手续费

因为每笔发布到区块链的交易利用这个网络下载和验证它的成本，这需要一些管理机制，代表性地，涉及到交易费，去避免滥用。默认的方法，在比特币中使用的，单纯的依赖自愿的费用，依赖矿工作为守门人和设置最低限度。这个方法在比特币社区被顺利的明确地接受，因为它是基于市场的，允许矿工和交易发送者之间的供需来决定价格。这个问题是，但是，交易处理不是一个市场。尽管直观上很有吸引力把交易处理解释为矿工提供给发送者的一种服务，实际上，一个矿工包括的每笔交易需要由网络中的每个节点来处理，所以交易处理的大部分是由第三方们承担的，而不是决定是否把它包含进来的矿工，公地悲剧问题可能会发生。

但是，正如基于市场机制会出现这个缺点，当给一个不确切的简化假设，魔法般的取消它。论证如下，假设：

1.一个交易导致K操作，给任何矿工提供kR奖励，这个矿工把它包含在事先由发送者，k和r设置的k大概对矿工可见。

2.一个操作由一个c的处理成本给任何节点（例如，所以节点都由相同的效率）

3.由N个挖矿节点，每个精确的拥有相等的处理算力（列入总计的1/N）

4.没有不挖矿的全节点存在

一个矿工将愿意处理交易如果预期奖励币成本高。因此，预期奖励是kR/N，因为矿工有1/N机会处理下一个区块，处理成本简单的讲是kC。因此，矿工将会包含交易，当kR/N > kC, or R > NC。注意，R是发送者提供的每次操作的费用，NC是整个网络一起处理一笔交易的成本。因此，矿工有动机包含这些交易，总的功利利益大于成本。

但是，在现实中，这些假设还有一些很重要的偏差。

1.矿工不比其它节点支付更高的成本去处理交易，因此额外的验证时间会延迟区块传播，因此，增加区块成为一个陈旧区块的机会。

2.存在不挖矿的全节点

3.实际上挖矿算力分布实际上是非常不平等的

4.投机者，政治敌人，和疯子，他们的功用包括危害网络，是存在的。他们可以聪明的设置合约，合约里他们的成本比其它验证节点低很多

（1）给矿工提供了一个包含更少交易的倾向（2）增加NC.因此，这两种效应至少部分相互抵消。（3）（4）是主要的事件；去解决他们，我们只要建议一个浮动的盖：没有节点可以的操作比长期平均指数移动的BLK_LIMIT_FACTOR高，明确地：

blk.oplimit = floor((blk.parent.oplimit \* (EMAFACTOR - 1) +

floor(parent.opcount \* BLK\_LIMIT\_FACTOR)) / EMA\_FACTOR)

BLK_LIMIT_FACTOR和 EMA_FACTOR是暂时分别设置为65536 和 1.5 的常数，但是我们可能在进一步分析后改变它。

这是另外一个在比特币中抑制大区块的因素：大区块会花费更多的时间去传播，因此就有更大可能性成为陈旧的块。在以太坊中，消费较高Gas的区块会花费更长的时间去传播，两个原因：本身就很大，需要更长的时间处理交易状态转换去验证。在比特币中，延迟抑制是一个重要的考虑。因为GHOST协议，在以太坊中会更少。因此，依赖控制的区块限制提供一个更加稳定的底线。

计算和图灵完备

一个重要的值得注意的是以太坊虚拟机器是图灵完备的；这意味着EVM代码可以编码任何可以理解的地实施的计算，包括无限循环。EVM代码允许两种方式来循环。1.JUMP指示允许程序跳回代码中的前一个点，JUMPI说明做有条件的跳跃，允许类似于while x < 27: x = x * 2的语句。2.合约可以调用其它合约，能进行递归循环。这自然导致一个问题：恶意的用户能不能通过迫使他们进入无限循环而本质上关闭矿工和全节点？有这个问题是因为在计算机科学里被称作的停机问题：在通常情况下，没有办法辨别一个指定的程序将永远关闭。

正如在状态转换那章所描述的，我们的方案是要求一个交易设置所允许执行的计算步数的最大数，如果执行太长而回复原样，手续费仍然是要付的。消息也是相同的方法。展示我们方案的动机，看下下面的案例：

一个攻击者创建一个无限循环的合约，给矿工发送一个激活循环的交易。矿工将会处理交易，运行无限循环，并等gas耗尽。即使执行耗尽gas，中途停下来，交易仍然是有效的，矿工仍然为每一个计算步向攻击者索取手续费。

一个攻击者创建一个很长的无限循环，目的时强迫矿工计算这么长时间，在这段时间里，计算完成的少些区块就会出来，矿工就不能包含交易来索取交易费。但是这个攻击者需要提供一个STARTGAS执行所做的计算步数的数目，矿工就会提前知道计算会时极度大的计算步数。

攻击者看到带有像send(A,contract.storage[A]); contract.storage[A] = 0的形式的代码的合约，发送一笔交易，只有足够的gas运行第一步，但是不够第二步（例如，取现，但是不余额降低）。合约作者不需要担心保护防止这样的攻击。因为在变化过程中半路停止，会恢复原样。

一个金融合约工作是通过取9个专营数据供应的中位数取最小化风险。一个攻击者接管其中一个数据供应，被设计为可更改的，在DAOs这一章描述的通过变量地址调用机制，转变为运行一个无限循环。因此尝试迫使任何尝试从金融合约里索取资金的，耗尽gas。但是，财务合约可以在消息上设置一个限制取防止这个问题。

图灵完备的替代是图灵不完备，JUMP 和 JUMPI不存在，在任何给定的时间只允许一份合约在调用栈堆里存在。在这个系统里，描述的系统费用和我们解决方案的有效性的不确定性是不必要的。因为执行一个合约的成本由它的尺寸限制。此外，图灵不完备甚至不是一个大的限制。由于所有的合约案例，我们内部持有的，目前为止，只有一个需要循环，甚至这个循环可以被移除，通过做一行代码做26次重复，考虑图灵完备的严重影响，有限的好处，为什么仅仅由一个图灵完备的语言？实际上，但是，图灵不完备远不是一个解决问题的优雅方案。为什么，细想下下面的合约：

C0: call(C1); call(C1);

C1: call(C2); call(C2);

C2: call(C3); call(C3);

...

C49: call(C50); call(C50);

C50: (run one step of a program and record the change in storage)

现在，发送一笔交易给A。因此，在51笔交易里，我们有一个占据250计算步的合约。矿工可以提前发下逻辑炸弹，维护一个每个合约指定所能花费的计算步的最大值，为合约递归调用其它合约计算这个，但是这将要求矿工禁止建立其它合约的合约（因为建立和执行以上所有的26个合约可以很容易的整合到一个合约里），另外一个问题点是消息的地址字段是一个变量，所以通常甚至不能提前分辨一个给定的合约调用其它合约。因此，总而言之，总而言之，我们有个令人惊讶的决定：图灵完备是出人意料的易于管理，缺乏图灵完备意味着出人意料的难管理，除非确切的相同控制是合适的-在那种情况下，为什么让协议具备图灵完备？

货币和发行

以太坊网络包含它自己的内置货币，ether，有双重目的：提供一个主要的流动性层去允许不同类型的数字资产之间高效的交换，更重要的是，提供一个支付交易手续费的机制。为了方便和避免以后的争议（参看现在在比特币中争论的mBTC/uBTC/satoshi ），面额提前描述为：

1: wei

1012: szabo

1015: finney

1018: ether

这个应该被看做"dollars" 和 "cents" 或 "BTC" 和 "satoshi"的扩展版本。在不久的将来，我们希望"ether"用作平常交易，"finney"用作小额交易，szabo" 和 "wei" 用于关于交易费和协议实施的技术讨论，剩下的面额以后会有用，这时候不应该包含到客户端里。

发行模型如下：

Ether会以货币销售方式发行，价格为1000-2000 ether/BTC，一个为以太坊组织提供资金，支付开发的机制，被其它平台，比如Mastercoin 和 NXT成功的用过。早期购买者会获得更大的折扣。销售中收到的BTC全部用作给开发者发工资和奖金和投资在以太坊上和加密货币生态系统的的盈利或非盈利项目。

0.099x 所售总额（60102216 ETH）分配给组织去补偿早期的贡献者和在创世快之前支付以太坊面额的费用

0.099x 所售总额将作为长期储备

0.26x所售总额在那个点之后永远每年分配给矿工

货币单位 1.198X 1.458X 2.498X购买者83.5% 68.6% 40.0%储备花费预售8.26% 6.79% 3.96% 储备用做售后8.26% 6.79% 3.96% 矿工 0% 17.8% 52.0%

长期供应增长率（%）




尽管是线性货币发行，像比特币一样，随着时间，供应增长率然而会趋向0.

在以上模型里两个选择是1.捐赠池的存在和大小 2永久增长的线性供应的的存在，和比特币中由封顶供应相反。捐赠池的理由如下。如果捐赠池不存在，线性发行减少到0.217x 以提供相同的通胀率，总的ether数量会少16.5%，每个单位的价值高19.8%。因此，在均衡中19.8%的ether会在销售中被购买，所以每个单位会再次准确地和以前等值。组织也有 1.198x 的BTC,考虑分为两部分：原始的BTC和额外的 0.198x.所以这个情况和捐赠等价，但是又一个不同：组织纯粹的持有BTC,所以不被激励去支持ether单位价值。

永久的线性增长模型降低了在比特币中看到的过度的财富集中，给现在和未来的人们一个公平的机会去获得货币单位，同时保持一个强烈的获取和持有ether的动机，因为“供应增长率”百分比仍然随着时间趋向于0。我们也推理由于粗心代币总是随着时间会丢失，死亡等。代币丢失可以做一个总供应量每年的模型，流通中的总货币供应，实际上稳定在一个和每年发行量/丢失率的值（比如，丢失率是1%，一旦供应达到 26X ，0.26X 会被挖出，0.26X每年会丢失，达到一个平衡）

注意，在未来，以太坊为了安全将会转换为proof-of-stake模式，减少发行需要大概在0- 0.05X/年。如果以太坊组织丢失资金或者其它原因消失了，我们会留下“社会合约”：任何人有权建议一个以太坊未来候选版本，唯一的条件是以太的数量大体上和60102216 * (1.198 + 0.26 * n)相等，n是创世块之后的年数。创立者可只有的众筹或者否在指定一些或所有在PoS驱动供应扩充和最大允许的供应扩张用于开发。候选人更新不符合社会合约将无可非议地的分叉为依从的版本。

挖矿中心化

比特币挖矿机制是让矿工反复不断地的在区块头轻微的修改版本上计算SHA256 ，直到最后一个节点提出一个哈希值小于目标值的版本（现在大概在2192）。但是，这种挖矿机制对两种形式的中心化是很脆弱的。第一，挖矿的生态由ASICs（特定应用的集成电路）支配，计算机芯片为之设计的，效率高几千倍，在比特币挖矿这个特定任务上。这意味着比特币挖矿不再是一个高去中心化和平等注意的追求。要高效的参与需要数百万美元。第二，大部分矿工不再实际上再本地验证区块；而是依赖一个中心化的矿池去提供区块头。这个问题可能更坏：写这个文章时，前三大矿池非直接地控制了大概50%的比特币网络的算力，虽然这个可以缓和的，如果一个矿池或联合尝试发起51%攻击，矿工可以转换到其它矿池上。

以太坊的当前目的是用一个挖矿机制，矿工被要求从状态中取来随机数据，计算从区块链中最后的N 区块中随机选择的交易。这有两个重要的好处，第一，以太坊合约可以包含任何种类的计算，所以以太坊ASIC必然是可以用作通用目的的ASIC -例如，更好的CPU。第二，挖矿需要进入整个区块链，迫使矿工去存储整个区块链，至少可以验证每笔交易。这去除了对去中心化矿池的需求。虽然矿池然后可以起到是奖励分布均等的合理作用，这个功能也可以由非中心化控制的点对点的矿池做的很好。

这个模型没有被测试过，也许会有一些困难在避免一定的聪明的优化的路上，当用合约执行作为挖矿机制。这个机制有个显著的有趣的特征是允许任何人污染这个井。通过引入大量的特别地设计阻碍ASICs.的合约进区块链。存在让 ASIC 制造商用这个手段相互攻击的经济激励。因此，这个解决方案是我们用最基本的适应的经济人方案，而不是纯粹的一个技术方案。

可扩展性

一个通常关于以太坊的担心是可扩展性。像比特币，以太坊遇到一个缺点，每笔交易都需要网阔中的每个节点处理。在比特币中，当前区块链的尺寸是15 GB，每小时增加MB。如果用比特币网络去处理Visa的每秒2000笔交易，就会每3秒钟增加1MB(每小时1GB,每年8TB)。以太坊会遭遇相似的增长模型，由于在以太坊区块链上有很多应用，不仅仅像比特币只是一个货币，所以情况会更糟糕。但是由于以太坊全节点只存储状态而不是整个区块链历史，所以情况会改善。

大的区块尺寸的问题有中心化的风险，如果区块链尺寸增加到，比如说100 TB，可能的情况是只有一小部分大型商业机构运行全节点，常规用户使用SPV轻节点。在这样一个情况，这将引发潜在的担心，全节点结合在一起，并同意在盈利的方式下欺骗（例如，改变区块回报，给它们自己BTC）。轻节点无法立即检测到它们。当然，至少一个诚实的全节点可能存在，几个小时后，欺骗的信息会通过像Reddit这样的渠道曝光，但是在那个点就太迟了：它将取决于普通用户集合它们的努力把特定的区块列入黑名单。一个大的，在相似层面不可实行的协作问题可以成功发起51%攻击。在比特币的情况里，目前是一个问题，但是又一个由Peter Todd 提出可以缓和这个问题的区块链修改。

在短期内，以太坊将用两个额外的方法去处理这个问题。第一，因为基于区块链的挖矿机制，至少每个矿工会被迫使成为一个全节点，建立一个较低的全节点数量额限制。第二也是更重要的，我们会在区块链中包含一个中间的状态的树根在处理每笔交易之后。即使区块验证是中心化的，只要诚实的验证节点存在，中心化问题可以通过一个验证协议规避。如果以恶搞矿工发布一个无效的区块，那么这个区块必定是很差的格式化的或状态S[n]是不正确的。因为S[0]为我们所知是正确的，那必定有一些错误的第一状态S[i]，当S[i-1]是正确的。验证节点会提供索引i,   和包含需要去处理APPLY(S[i-1],TX[i]) -> S[i]的Patricia树节点的子集的“无效证明”一起。节点能用那些Patricia节点去运行那部分计算，去看生成的S[i]和提供的S[i]不匹配。

其它，更复杂的，攻击涉及恶意矿工发布不完整的节点，决定节点是否有效的全部信息不存在，这个的解决方案是质询-响应协议，验证节点以目标交易指数的形式发布“质询”，直到收到一个节点一个轻节点不区块作为不可信的，直到另外一个节点，是否矿工或另外一个验证者，提供一个Patricia 节点的子集作为有效证明。

结论

以太坊协议最初构思为一个升级版本的加密货币。提供高级的特征，比如链上第三方存管，提现限额，金融合约，赌博市场，可能通过一个高普遍的编程语言。以太坊协议不直接支持任何应用，存在图灵完备编程语言意味着理论上可以为任何交易类型或应用创建任意合约。关于以太坊更有趣的是，但是，以太坊协议远不止货币。有关去中心化存储的协议，去中心化计算和去中心化预测市场，在其它许多这样的概念当中，有本质上增加计算行业效率的潜力。通过为第一次增加一个经济层，为其它点对点协议提供一个大的促进。最后，还有许多和钱根本无关的应用。

通过以太坊协议实施的任意状态转换函数的概念提供了一个具有独特潜力的平台，相比封闭式的，单一目的的，用作在数据存储，博彩，或金融等特定应用的协议，以太坊设计为开放式的，我们相信在未来几年里它很适合作为大量金融和非金融协议的基础层。

脚注和延展阅读

1.一个富有经验的的读者会注意到实际上比特币地址是椭圆曲线公匙的hash值，不是公钥本身。但是事实上完美地让加密术语去引用公钥哈希值作为公钥本身。这是因为密码使用法可以被看做定制的数字签名算法，公钥有 ECC 公钥哈希值组成，签名由用ECC签名串级起来的ECC公钥构成。机制涉及检查签名中的ECC 公钥，针对作为公钥的ECC公钥哈希值，然后验证参照ECC公钥的ECC签名。

2.技术上，是前11个区块的中位数。

3.以太坊协议应该越简单越好，但是也有必要有高阶的复杂性，例如对于规模，对于内化存储成本，带宽和I/O，为了安全，隐私和透明等。当复杂性存在，文档必须尽可能清楚，简洁、最新的，这样未受过以太坊训练的人可以学它，并成为专家。

4.以太坊虚拟机参照黄皮书（作为说明书和从scratch建立客户端的参考），还有很多主题在Ethereum wiki，例如分片开发，核心开发，dapp开发，研究，Casper研发，还有 ethresear.ch用作研究和未来实施。

5.另外一个表达方式是抽象概念。最新的路线图是抽象执行,允许执行引擎不必要服从一个权威的的说明。例如，可以为特定的应用定制，和碎片一样。执行引擎的异质性会很清晰地在路线图里表述。 还有各种各样的分片，Vlad Zamfir定义的。

6.在内部，2和 "CHARLIE"都是数字，后者二进位资料次序基于256表达。数字在0和2256-1之间。

延展阅读

1.内在规定:http://bitcoinmagazine.com/8640/an-exploration-of-intrinsic-value-what-it-is-why-bitcoin-doesnt-have-it-and-why-bitcoin-does-have-it/

2.智能财产：https://en.bitcoin.it/wiki/Smart\_Property

3.智能合约：https://en.bitcoin.it/wiki/Contracts

4.B-money：http://www.weidai.com/bmoney.txt

5.可重复的工作证明：http://www.finney.org/\~hal/rpow/

6.所有者授权的安全财产：http://szabo.best.vwh.net/securetitle.html

7.比特币白皮书： http://bitcoin.org/bitcoin.pdf

8.域名币：https://namecoin.org/

9.Zooko的三角：http://en.wikipedia.org/wiki/Zooko's\_triangle

10.染色币白皮书：https://docs.google.com/a/buterin.com/document/d/1AnkP\_cVZTCMLIzw4DvsW6M8Q2JC0lIzrTLuoWu2z1BE/edit

11.万事达币白皮书：https://github.com/mastercoin-MSC/spec

12.去中心化自治公司，比特币杂志：http://bitcoinmagazine.com/7050/bootstrapping-a-decentralized-autonomous-corporation-part-i/

13.简单支付验证：

https://en.bitcoin.it/wiki/Scalability\#Simplifiedpaymentverification

14.默克尔树

http://en.wikipedia.org/wiki/Merkle\_tree

15.Patricia树

16.GHOST: https://eprint.iacr.org/2013/881.pdf

17. StorJ and 自治代理, Jeff Garzik: http://garzikrants.blogspot.ca/2013/01/storj-and-bitcoin-autonomous-agents.html

18. Mike Hearn on 智能协议在图灵节: http://www.youtube.com/watch?v=Pu4PAMFPo5Y

19.Ethereum RLP: https://github.com/ethereum/wiki/wiki/%5BEnglish%5D-RLP

20.Ethereum 默克尔 Patricia 树: https://github.com/ethereum/wiki/wiki/%5BEnglish%5D-Patricia-Tree

21.Peter Todd on 默克尔总树: http://sourceforge.net/p/bitcoin/mailman/message/31709140/

白皮书历史，参造https://github.com/ethereum/wiki/blob/old-before-deleting-all-files-go-to-wiki-wiki-instead/old-whitepaper-for-historical-reference.md\#historical-sources-of-the-white-paper